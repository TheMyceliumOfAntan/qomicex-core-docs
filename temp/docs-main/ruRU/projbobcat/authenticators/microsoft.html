<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Система аутентификации Microsoft | Qomicex.Core API文档 </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Система аутентификации Microsoft | Qomicex.Core API文档 ">
      
      
      <link rel="icon" href="../../../../../favicon.ico">
      <link rel="stylesheet" href="../../../../../public/docfx.min.css">
      <link rel="stylesheet" href="../../../../../public/main.css">
      <meta name="docfx:navrel" content="../../../../../toc.html">
      <meta name="docfx:tocrel" content="../../../../../toc.html">
      
      <meta name="docfx:rel" content="../../../../../">
      
      
      <meta name="docfx:docurl" content="https://github.com/TheMyceliumOfAntan/Qomicex.Avalonia/blob/main/Qomicex.Docs/temp/docs-main/ruRU/projbobcat/authenticators/microsoft.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../../../../../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../../../../index.html">
            <img id="logo" class="svg" src="../../../../../logo.svg" alt="Qomicex.Core">
            Qomicex.Core
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">

      <div class="content">
        <div class="actionbar">

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="система-аутентификации-microsoft">Система аутентификации Microsoft</h1>

<p>[[toc]]</p>
<p>Эта системы аутентификации реализует новый процесс аутентификации на основе Azure, который применим ко всем версиям Minecraft, которые в настоящее время обслуживаются.</p>
<h2 id="подготовка">Подготовка</h2>
<p>Поскольку новый процесс аутентификации использует метод аутентификации на основе Azure.
Поэтому, прежде чем начать, убедитесь, что вы завершили <a href="/ruRU/projbobcat/createNewAzureApp">конфигурацию приложения Azure</a>.</p>
<p>После завершения регистрации приложения Azure убедитесь, что вы завершили <a href="/ruRU/projbobcat/installationAndConfig.md#%D0%BD%D0%B0%D1%81%D1%82%D1%80%D0%BE%D0%B9%D0%BA%D0%B0-%D0%B0%D1%83%D1%82%D0%B5%D0%BD%D1%82%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%82%D0%BE%D1%80%D0%B0-%D0%B2%D1%85%D0%BE%D0%B4%D0%B0-%D0%B2-microsoft">инициализацию аутентификатора Microsoft</a> в точке входа программы.</p>
<h3 id="настройка-метода-предоставления-кэшированных-учетных-данных">Настройка метода предоставления кэшированных учетных данных</h3>
<p>Из-за особенностей этой системи аутентификации разработчикам необходимо сохранять <strong>токен обновления</strong> и <strong>время истечения срока действия</strong>, возвращаемые при первой аутентификации, чтобы помочь аутентификатору завершить аутентификацию.
При аутентификации аутентификатор сначала вызовет этот метод, чтобы проверить действительность локального кэша токенов. Если локальный токен все еще действителен, результат аутентификации будет возвращен напрямую.
Если токен, кэшированный локально, истек, разработчику необходимо вручную запросить новый токен, а затем вернуть обновленный токен.</p>
<p>Ниже мы приводим пример реализации этого метода:</p>
<pre><code class="lang-c#">public async Task&lt;(bool, GraphAuthResultModel?)&gt; CacheTokenProviderAsync()
{
    if (string.IsNullOrEmpty(XBLToken)) return (false,  default);
    if (string.IsNullOrEmpty(XBLRefreshToken)) return (false,  default);

    // Рассчитать время истечения срока действия // [!code focus]
    var expireDate = LastRefreshedTime.AddSeconds(ExpiresIn); // [!code focus]

    // Если локальный кэшированный токен все еще действителен, вернуть текущий токен напрямую // [!code focus]
    // В противном случае используйте токен обновления для запроса нового токена // [!code focus]
    if (expireDate &gt; DateTime.Now)
    {
        var result = new GraphAuthResultModel // [!code focus]
        { // [!code focus]
            ExpiresIn = (int)(expireDate - DateTime.Now).TotalSeconds,  // [!code focus]
            AccessToken = XBLToken,  // [!code focus]
            RefreshToken = XBLRefreshToken // [!code focus]
        }; // [!code focus]

        return (true,  result); // [!code focus]
    }
    
    // Запросить новый токен входа // [!code focus]
    var refreshReqDic = new List&lt;KeyValuePair&lt;string,  string&gt;&gt; // [!code focus]
    { // [!code focus]
        new(&quot;client_id&quot;,  MicrosoftAuthenticator.ApiSettings.ClientId),  // [!code focus]
        new(&quot;refresh_token&quot;,  XBLRefreshToken),  // [!code focus]
        new(&quot;grant_type&quot;,  &quot;refresh_token&quot;) // [!code focus]
    }; // [!code focus]

    using var refreshReq = new HttpRequestMessage(HttpMethod.Post,  MicrosoftAuthenticator.MSRefreshTokenRequestUrl) // [!code focus]
    { // [!code focus]
        Content = new FormUrlEncodedContent(refreshReqDic) // [!code focus]
    }; // [!code focus]

    using var refreshRes = await DefaultClient.SendAsync(refreshReq);
    var refreshContent = await refreshRes.Content.ReadAsStringAsync();
    var refreshModel = MicrosoftAuthenticator.ResolveMSGraphResult(refreshContent,
    GraphAuthResultModelContext.Default.GraphAuthResultModel);

    if (refreshModel is not GraphAuthResultModel model)
    {
        if (refreshModel is GraphResponseErrorModel error) // [!code focus]
        { // [!code focus]
            // Обработка неудачной операции обновления здесь // [!code focus]
        } // [!code focus]

        return (false,  default);
    }

    return (true,  model);
}
</code></pre>
<h3 id="настройка-метода-отображения-кода-аутентификации-потока-устройства-при-первом-входе">Настройка метода отображения кода аутентификации потока устройства при первом входе</h3>
<p>Поскольку мы используем аутентификацию потока устройства для аутентификации учетной записи Microsoft игрока.
Поэтому нам нужен дополнительный метод для отображения пользователю одноразового ключа и адреса аутентификации, необходимых для аутентификации потока устройства.</p>
<p>Ниже приведен пример этого метода:</p>
<pre><code class="lang-c#">private void DeviceTokenNotifier(DeviceIdResponseModel deviceIdResponseModel)
{
    // Отображение полученных данных обратного вызова на внешнем интерфейсе
    DeviceCodeResponse = deviceIdResponseModel;
}
</code></pre>
<p><strong>DeviceIdResponseModel</strong> содержит всю информацию, необходимую пользователю для завершения аутентификации:</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Название</th>
<th style="text-align: center;">Действие</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">UserCode</td>
<td style="text-align: center;">Ключ, необходимый для аутентификации пользователя</td>
</tr>
<tr>
<td style="text-align: center;">VerificationUri</td>
<td style="text-align: center;">Адрес аутентификации, который пользователи должны посетить для выполнения последующих шагов аутентификации</td>
</tr>
<tr>
<td style="text-align: center;">ExpiresIn</td>
<td style="text-align: center;">Время истечения срока действия кода аутентификации (секунды)</td>
</tr>
</tbody>
</table>
<p>Ниже вы можете увидеть пример интерфейса отображения:</p>
<p><img src="/img/projbobcat/authenticators/device_token_auth_display_demo.png" alt="device_token_demo"></p>
<p>В этом интерфейсе вам необходимо включить как минимум следующее содержимое:</p>
<ul>
<li>Ключ, необходимый для входа</li>
<li>Конкретный адрес аутентификации</li>
<li>Краткая подсказка по работе, чтобы помочь пользователям завершить операцию аутентификации</li>
</ul>
<h2 id="инициализация-аутентификатора">Инициализация аутентификатора</h2>
<h3 id="первая-аутентификация">Первая аутентификация</h3>
<p>:::warning</p>
<p>Убедитесь, что вы подготовили <strong>метод отображения кода аутентификации потока устройства при первом входе</strong> перед выполнением следующего процесса, чтобы убедиться, что пользователи могут получить правильную информацию для первого входа!</p>
<p>:::</p>
<p>Инициализация аутентификатора:</p>
<pre><code class="lang-c#">var microsoftAuthenticator = new MicrosoftAuthenticator
{
    LauncherAccountParser = launcherAccountParser
};
</code></pre>
<p>В приведенном выше блоке кода замените эти параметры в соответствии с вашей реальной ситуацией:</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Элемент</th>
<th style="text-align: center;">Описание</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">launcherAccountParser</td>
<td style="text-align: center;">Для инициализации парсера учетных записей лаунчера см. здесь</td>
</tr>
</tbody>
</table>
<h3 id="не-первая-аутентификация">Не первая аутентификация</h3>
<p>Не первая аутентификация — это использование кэша токенов, полученного при первой аутентификации, для вторичной аутентификации.
В основном он проверяет, действительны ли локальные учетные данные через CacheTokenProviderAsync. Если токен, кэшированный локально, истек, он будет обновлен в этом методе.</p>
<p>Инициализация аутентификатора:</p>
<pre><code class="lang-c#">var microsoftAuthenticator = new MicrosoftAuthenticator
{
    CacheTokenProvider = CacheTokenProviderAsync,
    Email = &quot;[EMAIL]&quot;,
    LauncherAccountParser = launcherAccountParser
};
</code></pre>
<p>В приведенном выше блоке кода замените эти параметры в соответствии с вашей реальной ситуацией:</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Элемент</th>
<th style="text-align: center;">Описание</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">launcherAccountParser</td>
<td style="text-align: center;">Для инициализации парсера учетных записей лаунчера см. здесь</td>
</tr>
<tr>
<td style="text-align: center;">[EMAIL]</td>
<td style="text-align: center;">Адрес электронной почты учетной записи аутентификации</td>
</tr>
</tbody>
</table>
<p>:::tip</p>
<p>Для инициализации <strong>launcherAccountParser</strong> (парсера игровых профилей) см. страницу <a href="/ruRU/projbobcat/additionalParsers/gameProfileParser">Парсер игровых профилей</a>.</p>
<p>:::</p>
<h2 id="получение-результата-аутентификации-первая-аутентификация">Получение результата аутентификации (первая аутентификация)</h2>
<p>После завершения инициализации системи аутентификации вам нужно только вызвать метод аутентификации аутентификатора Microsoft для первоначальной аутентификации учетной записи.</p>
<p>Ниже приведен пример кода аутентификации:</p>
<pre><code class="lang-c#">// Получить результат аутентификации // [!code focus]
// DeviceTokenNotifier — это метод отображения информации, упомянутый ранее // [!code focus]
var authResult = await msAuth.GetMSAuthResult(DeviceTokenNotifier); // [!code focus]

if (authResult == null)
{
    // Обработка неудачной аутентификации // [!code focus]
}

// Разбор полей пользователя из токена Jwt // [!code focus]
var claims = JwtTokenHelper.GetTokenInfo(authResult.IdToken); // [!code focus]
var email = claims.TryGetValue(&quot;email&quot;, out var outEmail) ? outEmail : null; // [!code focus]

if (string.IsNullOrEmpty(email))
{
    // Невозможно разобрать адрес электронной почты пользователя из учетных данных Jwt, рассматривается как сбой аутентификации // [!code focus]
    // Это, скорее всего, вызвано сбоем конфигурации приложения Azure или Scope // [!code focus]
}

// Сохранение необходимой информации о пользователе на локальный диск для подготовки к следующей аутентификации // [!code focus]
var msInfoModel = new MSAccountInfoModel
{
    XBLToken = authResult.AccessToken, // [!code focus]
    XBLRefreshToken = authResult.RefreshToken, // [!code focus]
    ExpiresIn = authResult.ExpiresIn, // [!code focus]
    Email = email // [!code focus]
};
</code></pre>
<h2 id="получение-результата-аутентификации-не-первая-аутентификация">Получение результата аутентификации (не первая аутентификация)</h2>
<p>После завершения инициализации системи аутентификации вам нужно только вызвать метод аутентификации аутентификатора Microsoft для завершения аутентификации учетной записи.</p>
<p>В асинхронном контексте используйте <strong>AuthTaskAsync</strong> для завершения аутентификации:</p>
<pre><code class="lang-c#">var authResult = await microsoftAuthenticator.AuthTaskAsync(false);
</code></pre>
<p>В синхронном контексте используйте <strong>Auth</strong> для завершения аутентификации:</p>
<pre><code class="lang-c#">var authResult = microsoftAuthenticator.Auth();
</code></pre>
<h2 id="интерпретация-результата-аутентификации">Интерпретация результата аутентификации</h2>
<p>После завершения метода аутентификации оно вернет результат аутентификации, который является объектом родительского типа <a href="https://github.com/Corona-Studio/ProjBobcat/blob/master/ProjBobcat/ProjBobcat/Class/Model/Auth/AuthResultBase.cs">AuthResultBase</a>.
Все результаты аутентификации содержат значение перечисления <strong>AuthStatus</strong>, которое напрямую указывает на успех или неудачу аутентификации.
Ниже вы можете увидеть интерпретацию результата аутентификации:</p>
<h3 id="неудачный-результат-аутентификации">Неудачный результат аутентификации</h3>
<p>Определив, является ли <strong>Error</strong> пустым, вы можете легко определить, является ли результат аутентификации, возвращенный системой аутентификации, действительным.
Объект <strong>Error</strong> будет содержать следующие поля, чтобы сообщить вам некоторые подробности:</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Поле</th>
<th style="text-align: center;">Описание</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">authResult.Error.Cause</td>
<td style="text-align: center;">Конкретная причина проблемы</td>
</tr>
<tr>
<td style="text-align: center;">authResult.Error.Error</td>
<td style="text-align: center;">Название ошибки</td>
</tr>
<tr>
<td style="text-align: center;">authResult.Error.ErrorMessage</td>
<td style="text-align: center;">Подробная информация об ошибке, может содержать решение</td>
</tr>
</tbody>
</table>
<h3 id="успешный-результат-аутентификации">Успешный результат аутентификации</h3>
<p>Если поле <strong>Error</strong> в результате аутентификации пусто, это означает, что эта аутентификация действительна. Успешный результат аутентификации будет содержать следующую информацию:</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Поле</th>
<th style="text-align: center;">Описание</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">authResult.Id</td>
<td style="text-align: center;">Уникальный идентификатор этого имени пользователя, ProjBobcat использует определенный метод генерации для генерации этого идентификатора</td>
</tr>
<tr>
<td style="text-align: center;">authResult.AccessToken</td>
<td style="text-align: center;">Учетные данные авторизации учетной записи пользователя</td>
</tr>
<tr>
<td style="text-align: center;">authResult.Profiles</td>
<td style="text-align: center;">Список доступных ролей для пользователя, может содержать несколько доступных ролей</td>
</tr>
<tr>
<td style="text-align: center;">authResult.SelectedProfile</td>
<td style="text-align: center;">Текущая выбранная роль пользователя, это поле может быть пустым. Если оно пустое, пользователю необходимо предложить выбрать вручную.</td>
</tr>
<tr>
<td style="text-align: center;">authResult.User</td>
<td style="text-align: center;">Сводка информации об учетной записи пользователя, содержит некоторую основную информацию об учетной записи</td>
</tr>
<tr>
<td style="text-align: center;">authResult.LocalId</td>
<td style="text-align: center;">Локальный ID, обычно случайно сгенерированный UUID</td>
</tr>
<tr>
<td style="text-align: center;">authResult.RemoteId</td>
<td style="text-align: center;">Удаленный ID, возвращенный сервером аутентификации, обычно уникальный идентификатор пользователя</td>
</tr>
<tr>
<td style="text-align: center;">authResult.XBoxUid</td>
<td style="text-align: center;">XBox Live UID</td>
</tr>
<tr>
<td style="text-align: center;">authResult.Email</td>
<td style="text-align: center;">Адрес электронной почты, используемый для аутентификации</td>
</tr>
<tr>
<td style="text-align: center;">authResult.CurrentAuthTime</td>
<td style="text-align: center;">Текущее время аутентификации, <strong>разработчикам необходимо сохранить это поле, чтобы помочь подтвердить действительность локального кэшированного токена</strong></td>
</tr>
<tr>
<td style="text-align: center;">authResult.ExpiresIn</td>
<td style="text-align: center;">Время истечения срока действия токена (единица измерения: секунды), <strong>разработчикам необходимо сохранить это поле, чтобы помочь подтвердить действительность локального кэшированного токена</strong></td>
</tr>
<tr>
<td style="text-align: center;">authResult.RefreshToken</td>
<td style="text-align: center;">Токен обновления, <strong>разработчикам необходимо сохранить это поле, чтобы помочь обновить просроченные токены</strong></td>
</tr>
<tr>
<td style="text-align: center;">authResult.Skin</td>
<td style="text-align: center;">URL-адрес скина учетной записи пользователя</td>
</tr>
</tbody>
</table>
<p>:::warning</p>
<p>Пожалуйста, используйте соответствующие ограничения или шифрование для безопасного хранения конфиденциальных данных, связанных с токенами пользователей. Утечка этой части данных может привести к потерям.</p>
<p>:::</p>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/TheMyceliumOfAntan/Qomicex.Avalonia/blob/main/Qomicex.Docs/temp/docs-main/ruRU/projbobcat/authenticators/microsoft.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          Qomicex.Avalonia
        </div>
      </div>
    </footer>
  </body>
</html>
