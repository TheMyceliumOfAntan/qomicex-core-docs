{
  "api/Qomicex.Core.Class1.html": {
    "href": "api/Qomicex.Core.Class1.html",
    "title": "Class Class1 | Qomicex.Core API文档",
    "summary": "Class Class1 Namespace Qomicex.Core Assembly Qomicex.Core.dll public class Class1 Inheritance object Class1 Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString()"
  },
  "api/Qomicex.Core.DataModules.DataDetails.Account.html": {
    "href": "api/Qomicex.Core.DataModules.DataDetails.Account.html",
    "title": "Class DataModules.DataDetails.Account | Qomicex.Core API文档",
    "summary": "Class DataModules.DataDetails.Account Namespace Qomicex.Core Assembly Qomicex.Core.dll public class DataModules.DataDetails.Account Inheritance object DataModules.DataDetails.Account Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields AccessToken public string AccessToken Field Value string LoginMethod public string LoginMethod Field Value string Name public string Name Field Value string RefreshToken public string RefreshToken Field Value string Token public string Token Field Value string Uuid public string Uuid Field Value string"
  },
  "api/Qomicex.Core.DataModules.DataDetails.Java.html": {
    "href": "api/Qomicex.Core.DataModules.DataDetails.Java.html",
    "title": "Class DataModules.DataDetails.Java | Qomicex.Core API文档",
    "summary": "Class DataModules.DataDetails.Java Namespace Qomicex.Core Assembly Qomicex.Core.dll public class DataModules.DataDetails.Java Inheritance object DataModules.DataDetails.Java Derived JavaHelper.JavaInfoExtended Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields Arch public string Arch Field Value string Name public string Name Field Value string Path public string Path Field Value string Type public string Type Field Value string Version public string Version Field Value string VersionID public int VersionID Field Value int"
  },
  "api/Qomicex.Core.DataModules.DataDetails.Launcher.WindowSize.html": {
    "href": "api/Qomicex.Core.DataModules.DataDetails.Launcher.WindowSize.html",
    "title": "Class DataModules.DataDetails.Launcher.WindowSize | Qomicex.Core API文档",
    "summary": "Class DataModules.DataDetails.Launcher.WindowSize Namespace Qomicex.Core Assembly Qomicex.Core.dll public class DataModules.DataDetails.Launcher.WindowSize Inheritance object DataModules.DataDetails.Launcher.WindowSize Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields Width public string Width Field Value string height public string height Field Value string"
  },
  "api/Qomicex.Core.DataModules.DataDetails.Launcher.html": {
    "href": "api/Qomicex.Core.DataModules.DataDetails.Launcher.html",
    "title": "Class DataModules.DataDetails.Launcher | Qomicex.Core API文档",
    "summary": "Class DataModules.DataDetails.Launcher Namespace Qomicex.Core Assembly Qomicex.Core.dll public class DataModules.DataDetails.Launcher Inheritance object DataModules.DataDetails.Launcher Derived Launcher.LauncherParam Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields Account public DataModules.DataDetails.Account Account Field Value DataModules.DataDetails.Account AdditionalParam public string AdditionalParam Field Value string DevideVersion public bool DevideVersion Field Value bool Java public DataModules.DataDetails.Java Java Field Value DataModules.DataDetails.Java MaxMemory public string MaxMemory Field Value string Version public string Version Field Value string"
  },
  "api/Qomicex.Core.DataModules.DataDetails.Version.html": {
    "href": "api/Qomicex.Core.DataModules.DataDetails.Version.html",
    "title": "Class DataModules.DataDetails.Version | Qomicex.Core API文档",
    "summary": "Class DataModules.DataDetails.Version Namespace Qomicex.Core Assembly Qomicex.Core.dll public class DataModules.DataDetails.Version Inheritance object DataModules.DataDetails.Version Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors Version(string) public Version(string gameDir = \"\") Parameters gameDir string Fields GameDir public string GameDir Field Value string GameVersion public string GameVersion Field Value string State public string State Field Value string StateDescribe public string StateDescribe Field Value string Type public string[] Type Field Value string[] VersionDir public string VersionDir Field Value string Properties Name public string Name { get; set; } Property Value string"
  },
  "api/Qomicex.Core.DataModules.DataDetails.html": {
    "href": "api/Qomicex.Core.DataModules.DataDetails.html",
    "title": "Class DataModules.DataDetails | Qomicex.Core API文档",
    "summary": "Class DataModules.DataDetails Namespace Qomicex.Core Assembly Qomicex.Core.dll public class DataModules.DataDetails Inheritance object DataModules.DataDetails Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString()"
  },
  "api/Qomicex.Core.DataModules.State.StateCode.html": {
    "href": "api/Qomicex.Core.DataModules.State.StateCode.html",
    "title": "Enum DataModules.State.StateCode | Qomicex.Core API文档",
    "summary": "Enum DataModules.State.StateCode Namespace Qomicex.Core Assembly Qomicex.Core.dll public enum DataModules.State.StateCode Fields Available = 0 MissingFiles = 1 Unknown = 3 WrongId = 2"
  },
  "api/Qomicex.Core.DataModules.State.html": {
    "href": "api/Qomicex.Core.DataModules.State.html",
    "title": "Struct DataModules.State | Qomicex.Core API文档",
    "summary": "Struct DataModules.State Namespace Qomicex.Core Assembly Qomicex.Core.dll public struct DataModules.State Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors State() public State() Fields Code public int Code Field Value int Describe public string Describe Field Value string Name public string Name Field Value string"
  },
  "api/Qomicex.Core.DataModules.SystemInfo.html": {
    "href": "api/Qomicex.Core.DataModules.SystemInfo.html",
    "title": "Struct DataModules.SystemInfo | Qomicex.Core API文档",
    "summary": "Struct DataModules.SystemInfo Namespace Qomicex.Core Assembly Qomicex.Core.dll public struct DataModules.SystemInfo Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors SystemInfo() public SystemInfo() Fields Architecture public string Architecture Field Value string OS public string OS Field Value string OSName public string OSName Field Value string OSVersion public string OSVersion Field Value string OSVersionID public string OSVersionID Field Value string"
  },
  "api/Qomicex.Core.DataModules.html": {
    "href": "api/Qomicex.Core.DataModules.html",
    "title": "Class DataModules | Qomicex.Core API文档",
    "summary": "Class DataModules Namespace Qomicex.Core Assembly Qomicex.Core.dll public class DataModules Inheritance object DataModules Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString()"
  },
  "api/Qomicex.Core.Modules.Helpers.Account.Microsoft.OAuthResponse.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Account.Microsoft.OAuthResponse.html",
    "title": "Class Microsoft.OAuthResponse | Qomicex.Core API文档",
    "summary": "Class Microsoft.OAuthResponse Namespace Qomicex.Core.Modules.Helpers.Account Assembly Qomicex.Core.dll public class Microsoft.OAuthResponse Inheritance object Microsoft.OAuthResponse Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields DeviceCode public string DeviceCode Field Value string UserCode public string UserCode Field Value string VerificationUri public string VerificationUri Field Value string Properties ExpiresIn public int ExpiresIn { get; set; } Property Value int Interval public int Interval { get; set; } Property Value int"
  },
  "api/Qomicex.Core.Modules.Helpers.Account.Microsoft.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Account.Microsoft.html",
    "title": "Class Microsoft | Qomicex.Core API文档",
    "summary": "Class Microsoft Namespace Qomicex.Core.Modules.Helpers.Account Assembly Qomicex.Core.dll public class Microsoft Inheritance object Microsoft Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods GetUserAuthorizationState(OAuthResponse) public Task<Dictionary<string, string>> GetUserAuthorizationState(Microsoft.OAuthResponse oAuthResponse) Parameters oAuthResponse Microsoft.OAuthResponse Returns Task<Dictionary<string, string>> GetUserInfo(string, string) public Task<DataModules.DataDetails.Account> GetUserInfo(string accessToken, string refresh_token) Parameters accessToken string refresh_token string Returns Task<DataModules.DataDetails.Account> OAuthLogin() public Task<Microsoft.OAuthResponse> OAuthLogin() Returns Task<Microsoft.OAuthResponse> RefreshUserInfo(string) public Task<DataModules.DataDetails.Account> RefreshUserInfo(string refreshToken) Parameters refreshToken string Returns Task<DataModules.DataDetails.Account>"
  },
  "api/Qomicex.Core.Modules.Helpers.Account.Tongyi.TongyiAccount.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Account.Tongyi.TongyiAccount.html",
    "title": "Class Tongyi.TongyiAccount | Qomicex.Core API文档",
    "summary": "Class Tongyi.TongyiAccount Namespace Qomicex.Core.Modules.Helpers.Account Assembly Qomicex.Core.dll 表示一个 统一通行证 身份验证游戏账户。 public class Tongyi.TongyiAccount Inheritance object Tongyi.TongyiAccount Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties AccessToken 访问令牌。 public string? AccessToken { get; set; } Property Value string ClientToken 客户端令牌。 public string? ClientToken { get; set; } Property Value string IsExpired 令牌是否已过期。 public bool IsExpired { get; set; } Property Value bool IssuedAt 令牌签发时间。 public DateTimeOffset IssuedAt { get; set; } Property Value DateTimeOffset Name 角色名称。 public string? Name { get; set; } Property Value string UserId 用户 ID。 public string? UserId { get; set; } Property Value string UserType 用户类型。 public string? UserType { get; set; } Property Value string Uuid 角色 UUID（不含连字符）。 public string? Uuid { get; set; } Property Value string Methods CheckExpiration(TimeSpan) 根据指定的有效期检查令牌是否过期。 public bool CheckExpiration(TimeSpan tokenLifetime) Parameters tokenLifetime TimeSpan 令牌的预期有效期。 Returns bool 如果已过期则返回 true，否则返回 false。"
  },
  "api/Qomicex.Core.Modules.Helpers.Account.Tongyi.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Account.Tongyi.html",
    "title": "Class Tongyi | Qomicex.Core API文档",
    "summary": "Class Tongyi Namespace Qomicex.Core.Modules.Helpers.Account Assembly Qomicex.Core.dll public class Tongyi : IDisposable Inheritance object Tongyi Implements IDisposable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors Tongyi(string, string, string) Tongyi 的构造函数。 public Tongyi(string serverId, string email, string password) Parameters serverId string 用于身份验证的基础 URL。 email string 账户的电子邮件地址。 password string 账户的密码。 Methods AuthenticateAsync(CancellationToken) 使用提供的电子邮件和密码在 统一通行证 上验证用户身份。 public Task<List<Tongyi.TongyiAccount>> AuthenticateAsync(CancellationToken cancellationToken = default) Parameters cancellationToken CancellationToken 用于取消异步操作的令牌。 Returns Task<List<Tongyi.TongyiAccount>> 与已验证用户关联的 统一通行证 账户列表。 Exceptions TongyiException 当身份验证失败时抛出。 Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. public void Dispose() GetSkinTextureAsync(string, CancellationToken) public Task<string?> GetSkinTextureAsync(string uuid, CancellationToken cancellationToken = default) Parameters uuid string cancellationToken CancellationToken Returns Task<string> InvalidateTokenAsync(TongyiAccount, CancellationToken) 使 统一通行证 账户中的令牌失效。 public Task InvalidateTokenAsync(Tongyi.TongyiAccount account, CancellationToken cancellationToken = default) Parameters account Tongyi.TongyiAccount 要使令牌失效的 统一通行证 账户。 cancellationToken CancellationToken 用于取消异步操作的令牌。 Returns Task Exceptions TongyiException 当令牌失效操作失败时抛出。 OpenRegisterPage(string) public void OpenRegisterPage(string ServerID) Parameters ServerID string RefreshTokenAsync(TongyiAccount, CancellationToken) 为指定的 统一通行证 账户刷新访问令牌。 public Task<Tongyi.TongyiAccount> RefreshTokenAsync(Tongyi.TongyiAccount account, CancellationToken cancellationToken = default) Parameters account Tongyi.TongyiAccount 要刷新的 统一通行证 账户。 cancellationToken CancellationToken 用于取消异步操作的令牌。 Returns Task<Tongyi.TongyiAccount> 刷新后的 统一通行证 账户。 Exceptions TongyiException 当令牌刷新失败时抛出。 ValidateTokenAsync(TongyiAccount, CancellationToken) 验证 统一通行证 账户中的令牌是否仍然有效。 public Task<bool> ValidateTokenAsync(Tongyi.TongyiAccount account, CancellationToken cancellationToken = default) Parameters account Tongyi.TongyiAccount 要验证的 统一通行证 账户。 cancellationToken CancellationToken 用于取消异步操作的令牌。 Returns Task<bool> 如果令牌有效则返回 true；否则返回 false。 Exceptions TongyiException 在网络错误时抛出。"
  },
  "api/Qomicex.Core.Modules.Helpers.Account.TongyiException.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Account.TongyiException.html",
    "title": "Class TongyiException | Qomicex.Core API文档",
    "summary": "Class TongyiException Namespace Qomicex.Core.Modules.Helpers.Account Assembly Qomicex.Core.dll 与 统一通行证 身份验证相关的异常。 public class TongyiException : Exception, ISerializable Inheritance object Exception TongyiException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors TongyiException(string) 初始化 统一通行证Exception 类的新实例。 public TongyiException(string message) Parameters message string 异常消息。 TongyiException(string, Exception) 初始化 统一通行证Exception 类的新实例，并指定内部异常。 public TongyiException(string message, Exception innerException) Parameters message string 异常消息。 innerException Exception 内部异常。 Properties ErrorCode 错误代码。 public string ErrorCode { get; set; } Property Value string StatusCode HTTP 状态码。 public HttpStatusCode StatusCode { get; set; } Property Value HttpStatusCode"
  },
  "api/Qomicex.Core.Modules.Helpers.Account.Yggdrasil.YggdrasilAccount.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Account.Yggdrasil.YggdrasilAccount.html",
    "title": "Class Yggdrasil.YggdrasilAccount | Qomicex.Core API文档",
    "summary": "Class Yggdrasil.YggdrasilAccount Namespace Qomicex.Core.Modules.Helpers.Account Assembly Qomicex.Core.dll 表示一个 Yggdrasil 身份验证游戏账户。 public class Yggdrasil.YggdrasilAccount Inheritance object Yggdrasil.YggdrasilAccount Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties AccessToken 访问令牌。 public string? AccessToken { get; set; } Property Value string ClientToken 客户端令牌。 public string? ClientToken { get; set; } Property Value string IsExpired 令牌是否已过期。 public bool IsExpired { get; set; } Property Value bool IssuedAt 令牌签发时间。 public DateTimeOffset IssuedAt { get; set; } Property Value DateTimeOffset Name 角色名称。 public string? Name { get; set; } Property Value string UserId 用户 ID。 public string? UserId { get; set; } Property Value string UserType 用户类型。 public string? UserType { get; set; } Property Value string Uuid 角色 UUID（不含连字符）。 public string? Uuid { get; set; } Property Value string Methods CheckExpiration(TimeSpan) 根据指定的有效期检查令牌是否过期。 public bool CheckExpiration(TimeSpan tokenLifetime) Parameters tokenLifetime TimeSpan 令牌的预期有效期。 Returns bool 如果已过期则返回 true，否则返回 false。"
  },
  "api/Qomicex.Core.Modules.Helpers.Account.Yggdrasil.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Account.Yggdrasil.html",
    "title": "Class Yggdrasil | Qomicex.Core API文档",
    "summary": "Class Yggdrasil Namespace Qomicex.Core.Modules.Helpers.Account Assembly Qomicex.Core.dll public class Yggdrasil : IDisposable Inheritance object Yggdrasil Implements IDisposable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors Yggdrasil(string, string, string) Yggdrasil 的构造函数。 public Yggdrasil(string baseUrl, string email, string password) Parameters baseUrl string 用于身份验证的基础 URL。 email string 账户的电子邮件地址。 password string 账户的密码。 Methods AuthenticateAsync(CancellationToken) 使用提供的电子邮件和密码在 Yggdrasil 服务器上验证用户身份。 public Task<List<Yggdrasil.YggdrasilAccount>> AuthenticateAsync(CancellationToken cancellationToken = default) Parameters cancellationToken CancellationToken 用于取消异步操作的令牌。 Returns Task<List<Yggdrasil.YggdrasilAccount>> 与已验证用户关联的 Yggdrasil 账户列表。 Exceptions YggdrasilException 当身份验证失败时抛出。 Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. public void Dispose() GetSkinTextureAsync(string, CancellationToken) public Task<string?> GetSkinTextureAsync(string uuid, CancellationToken cancellationToken = default) Parameters uuid string cancellationToken CancellationToken Returns Task<string> InvalidateTokenAsync(YggdrasilAccount, CancellationToken) 使 Yggdrasil 账户中的令牌失效。 public Task InvalidateTokenAsync(Yggdrasil.YggdrasilAccount account, CancellationToken cancellationToken = default) Parameters account Yggdrasil.YggdrasilAccount 要使令牌失效的 Yggdrasil 账户。 cancellationToken CancellationToken 用于取消异步操作的令牌。 Returns Task Exceptions YggdrasilException 当令牌失效操作失败时抛出。 RefreshTokenAsync(YggdrasilAccount, CancellationToken) 为指定的 Yggdrasil 账户刷新访问令牌。 public Task<Yggdrasil.YggdrasilAccount> RefreshTokenAsync(Yggdrasil.YggdrasilAccount account, CancellationToken cancellationToken = default) Parameters account Yggdrasil.YggdrasilAccount 要刷新的 Yggdrasil 账户。 cancellationToken CancellationToken 用于取消异步操作的令牌。 Returns Task<Yggdrasil.YggdrasilAccount> 刷新后的 Yggdrasil 账户。 Exceptions YggdrasilException 当令牌刷新失败时抛出。 ValidateTokenAsync(YggdrasilAccount, CancellationToken) 验证 Yggdrasil 账户中的令牌是否仍然有效。 public Task<bool> ValidateTokenAsync(Yggdrasil.YggdrasilAccount account, CancellationToken cancellationToken = default) Parameters account Yggdrasil.YggdrasilAccount 要验证的 Yggdrasil 账户。 cancellationToken CancellationToken 用于取消异步操作的令牌。 Returns Task<bool> 如果令牌有效则返回 true；否则返回 false。 Exceptions YggdrasilException 在网络错误时抛出。"
  },
  "api/Qomicex.Core.Modules.Helpers.Account.YggdrasilException.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Account.YggdrasilException.html",
    "title": "Class YggdrasilException | Qomicex.Core API文档",
    "summary": "Class YggdrasilException Namespace Qomicex.Core.Modules.Helpers.Account Assembly Qomicex.Core.dll 与 Yggdrasil 身份验证相关的异常。 public class YggdrasilException : Exception, ISerializable Inheritance object Exception YggdrasilException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors YggdrasilException(string) 初始化 YggdrasilException 类的新实例。 public YggdrasilException(string message) Parameters message string 异常消息。 YggdrasilException(string, Exception) 初始化 YggdrasilException 类的新实例，并指定内部异常。 public YggdrasilException(string message, Exception innerException) Parameters message string 异常消息。 innerException Exception 内部异常。 Properties ErrorCode 错误代码。 public string? ErrorCode { get; set; } Property Value string StatusCode HTTP 状态码。 public HttpStatusCode StatusCode { get; set; } Property Value HttpStatusCode"
  },
  "api/Qomicex.Core.Modules.Helpers.Account.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Account.html",
    "title": "Namespace Qomicex.Core.Modules.Helpers.Account | Qomicex.Core API文档",
    "summary": "Namespace Qomicex.Core.Modules.Helpers.Account Classes Microsoft Microsoft.OAuthResponse Tongyi Tongyi.TongyiAccount 表示一个 统一通行证 身份验证游戏账户。 TongyiException 与 统一通行证 身份验证相关的异常。 Yggdrasil Yggdrasil.YggdrasilAccount 表示一个 Yggdrasil 身份验证游戏账户。 YggdrasilException 与 Yggdrasil 身份验证相关的异常。"
  },
  "api/Qomicex.Core.Modules.Helpers.AccountHelper.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.AccountHelper.html",
    "title": "Class AccountHelper | Qomicex.Core API文档",
    "summary": "Class AccountHelper Namespace Qomicex.Core.Modules.Helpers Assembly Qomicex.Core.dll public class AccountHelper Inheritance object AccountHelper Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods NameToUuid(string) public static string NameToUuid(string name) Parameters name string Returns string"
  },
  "api/Qomicex.Core.Modules.Helpers.GeneralHelper.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.GeneralHelper.html",
    "title": "Class GeneralHelper | Qomicex.Core API文档",
    "summary": "Class GeneralHelper Namespace Qomicex.Core.Modules.Helpers Assembly Qomicex.Core.dll public class GeneralHelper Inheritance object GeneralHelper Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods CheckVersionAvailablity(string, string) public DataModules.State CheckVersionAvailablity(string GameDir, string Version) Parameters GameDir string Version string Returns DataModules.State DeleteExcept(string, string) 删除指定目录中除特定后缀外的所有文件（注意：操作有风险，需确保路径正确） public static bool DeleteExcept(string folderPath, string keepSuffix) Parameters folderPath string keepSuffix string Returns bool ExtractFolderFromZip(string, string, string) public static List<string> ExtractFolderFromZip(string zipPath, string targetFolderInZip, string outputDirectory) Parameters zipPath string targetFolderInZip string outputDirectory string Returns List<string> GetJavaVersion(string) public static string GetJavaVersion(string javaPath) Parameters javaPath string Returns string GetMinecraftRequireJavaVersion(string, string) public static string GetMinecraftRequireJavaVersion(string version, string gameDir) Parameters version string gameDir string Returns string GetModLoaderType(string, string) public string[] GetModLoaderType(string Version, string GameDir) Parameters Version string GameDir string Returns string[] GetNormalizedMajorVersion(string) public static int GetNormalizedMajorVersion(string version) Parameters version string Returns int ReadSpecifyFileFromZip(string, string) public static byte[] ReadSpecifyFileFromZip(string path, string fileName) Parameters path string fileName string Returns byte[] SearchVersions(string) public List<DataModules.DataDetails.Version> SearchVersions(string GameDir) Parameters GameDir string Returns List<DataModules.DataDetails.Version> SearchVersionsFast(string) public List<string> SearchVersionsFast(string GameDir) Parameters GameDir string Returns List<string> Unzip(string, string) public static bool Unzip(string zipFilePath, string targetDir) Parameters zipFilePath string targetDir string Returns bool VerifyFileSha1(string, string) public static bool VerifyFileSha1(string filePath, string expectedHash) Parameters filePath string expectedHash string Returns bool"
  },
  "api/Qomicex.Core.Modules.Helpers.Installers.FabricInstaller.Library.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Installers.FabricInstaller.Library.html",
    "title": "Class FabricInstaller.Library | Qomicex.Core API文档",
    "summary": "Class FabricInstaller.Library Namespace Qomicex.Core.Modules.Helpers.Installers Assembly Qomicex.Core.dll public class FabricInstaller.Library Inheritance object FabricInstaller.Library Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Md5 public string? Md5 { get; set; } Property Value string Name public string? Name { get; set; } Property Value string Sha1 public string? Sha1 { get; set; } Property Value string Sha256 public string? Sha256 { get; set; } Property Value string Sha512 public string? Sha512 { get; set; } Property Value string Size public long? Size { get; set; } Property Value long? Url public string? Url { get; set; } Property Value string"
  },
  "api/Qomicex.Core.Modules.Helpers.Installers.FabricInstaller.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Installers.FabricInstaller.html",
    "title": "Class FabricInstaller | Qomicex.Core API文档",
    "summary": "Class FabricInstaller Namespace Qomicex.Core.Modules.Helpers.Installers Assembly Qomicex.Core.dll public class FabricInstaller : InstallerBase, IInstaller Inheritance object InstallerBase FabricInstaller Implements IInstaller Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors FabricInstaller(int, string) public FabricInstaller(int downloadSource, string gameDir) Parameters downloadSource int gameDir string Methods InstallAsync(string, string, string?, string?, string?, string?) 为指定的游戏版本和整合包标识符安装指定版本的 Fabric 模组加载器。 public void InstallAsync(string versionId, string inheritsFromJson, string? fabricVersion, string? gameVersion, string? para3, string? para4) Parameters versionId string 要安装 Fabric 的整合包或实例的唯一标识符。不能为空。 inheritsFromJson string 继承自版本的JSON内容。可为空，为空时尝试从游戏目录读取。 fabricVersion string 要安装的 Fabric 模组加载器版本。必须是有效的 Fabric 版本字符串。 gameVersion string Fabric 应安装的游戏版本。必须是受支持的游戏版本。 para3 string para4 string InstallFabricAsync(string, string, string, string?) 异步安装 Fabric Loader public Task<bool> InstallFabricAsync(string versionId, string fabricVersion, string gameVersion, string? inheritsFromJson = null) Parameters versionId string 生成的版本ID fabricVersion string 欲安装的Fabric版本 gameVersion string 原版游戏版本 inheritsFromJson string 继承自版本的JSON内容，可为空 Returns Task<bool> 是否成功"
  },
  "api/Qomicex.Core.Modules.Helpers.Installers.ForgeInstaller.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Installers.ForgeInstaller.html",
    "title": "Class ForgeInstaller | Qomicex.Core API文档",
    "summary": "Class ForgeInstaller Namespace Qomicex.Core.Modules.Helpers.Installers Assembly Qomicex.Core.dll public class ForgeInstaller : ForgeInstallerBase, IInstaller Inheritance object InstallerBase ForgeInstallerBase ForgeInstaller Implements IInstaller Inherited Members ForgeInstallerBase.SourceId ForgeInstallerBase.ResolveUrl(string) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ForgeInstaller(int, string, string) public ForgeInstaller(int sourceId, string gameDir, string gameVersion) Parameters sourceId int gameDir string gameVersion string Methods GetMissForgeLibraries(string, string) 获取缺失的 Forge 库文件列表 public List<LocalResourceHelper.MissFileData> GetMissForgeLibraries(string forgeInstallerPath, string versionId) Parameters forgeInstallerPath string Forge安装器路径 versionId string 版本ID Returns List<LocalResourceHelper.MissFileData> Exceptions Exception InstallAsync(string, string, string?, string?, string?, string?) public void InstallAsync(string versionId, string inheritsFromJson, string? javaPath, string? forgeInstallerPath, string? para3, string? para4) Parameters versionId string inheritsFromJson string javaPath string forgeInstallerPath string para3 string para4 string IsLegacyForgeInstaller(string) public bool IsLegacyForgeInstaller(string forgeInstallerPath) Parameters forgeInstallerPath string Returns bool"
  },
  "api/Qomicex.Core.Modules.Helpers.Installers.ForgeInstallerBase.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Installers.ForgeInstallerBase.html",
    "title": "Class ForgeInstallerBase | Qomicex.Core API文档",
    "summary": "Class ForgeInstallerBase Namespace Qomicex.Core.Modules.Helpers.Installers Assembly Qomicex.Core.dll public class ForgeInstallerBase : InstallerBase Inheritance object InstallerBase ForgeInstallerBase Derived ForgeInstaller NeoForgeInstaller Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields SourceId public int SourceId Field Value int Methods ResolveUrl(string) public string ResolveUrl(string originalUrl) Parameters originalUrl string Returns string"
  },
  "api/Qomicex.Core.Modules.Helpers.Installers.IInstaller.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Installers.IInstaller.html",
    "title": "Interface IInstaller | Qomicex.Core API文档",
    "summary": "Interface IInstaller Namespace Qomicex.Core.Modules.Helpers.Installers Assembly Qomicex.Core.dll public interface IInstaller Methods InstallAsync(string, string, string?, string?, string?, string?) void InstallAsync(string versionId, string inheritsFromJson, string? para1, string? para2, string? para3, string? para4) Parameters versionId string inheritsFromJson string para1 string para2 string para3 string para4 string"
  },
  "api/Qomicex.Core.Modules.Helpers.Installers.InstallerBase.DownloadSource.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Installers.InstallerBase.DownloadSource.html",
    "title": "Enum InstallerBase.DownloadSource | Qomicex.Core API文档",
    "summary": "Enum InstallerBase.DownloadSource Namespace Qomicex.Core.Modules.Helpers.Installers Assembly Qomicex.Core.dll public enum InstallerBase.DownloadSource Fields Bmclapi = 1 Official = 0"
  },
  "api/Qomicex.Core.Modules.Helpers.Installers.InstallerBase.InstallType.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Installers.InstallerBase.InstallType.html",
    "title": "Enum InstallerBase.InstallType | Qomicex.Core API文档",
    "summary": "Enum InstallerBase.InstallType Namespace Qomicex.Core.Modules.Helpers.Installers Assembly Qomicex.Core.dll public enum InstallerBase.InstallType Fields Fabric = 1 Forge = 0 LiteLoader = 4 NeoForge = 2 OptiFine = 5 Quilt = 3"
  },
  "api/Qomicex.Core.Modules.Helpers.Installers.InstallerBase.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Installers.InstallerBase.html",
    "title": "Class InstallerBase | Qomicex.Core API文档",
    "summary": "Class InstallerBase Namespace Qomicex.Core.Modules.Helpers.Installers Assembly Qomicex.Core.dll public class InstallerBase Inheritance object InstallerBase Derived FabricInstaller ForgeInstallerBase LiteloaderInstaller OptiFineInstaller QuiltInstaller Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString()"
  },
  "api/Qomicex.Core.Modules.Helpers.Installers.LiteloaderInstaller.Artifact.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Installers.LiteloaderInstaller.Artifact.html",
    "title": "Class LiteloaderInstaller.Artifact | Qomicex.Core API文档",
    "summary": "Class LiteloaderInstaller.Artifact Namespace Qomicex.Core.Modules.Helpers.Installers Assembly Qomicex.Core.dll public class LiteloaderInstaller.Artifact Inheritance object LiteloaderInstaller.Artifact Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors Artifact(string, string, string) public Artifact(string groupId, string artifactId, string version) Parameters groupId string artifactId string version string Properties ArtifactId public string ArtifactId { get; set; } Property Value string GroupId public string GroupId { get; set; } Property Value string Version public string Version { get; set; } Property Value string Methods ToString() Returns a string that represents the current object. public override string ToString() Returns string A string that represents the current object."
  },
  "api/Qomicex.Core.Modules.Helpers.Installers.LiteloaderInstaller.InstallProgress.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Installers.LiteloaderInstaller.InstallProgress.html",
    "title": "Class LiteloaderInstaller.InstallProgress | Qomicex.Core API文档",
    "summary": "Class LiteloaderInstaller.InstallProgress Namespace Qomicex.Core.Modules.Helpers.Installers Assembly Qomicex.Core.dll public class LiteloaderInstaller.InstallProgress Inheritance object LiteloaderInstaller.InstallProgress Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties IsCompleted public bool IsCompleted { get; set; } Property Value bool IsError public bool IsError { get; set; } Property Value bool Message public string Message { get; set; } Property Value string Percentage public int Percentage { get; set; } Property Value int"
  },
  "api/Qomicex.Core.Modules.Helpers.Installers.LiteloaderInstaller.Library.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Installers.LiteloaderInstaller.Library.html",
    "title": "Class LiteloaderInstaller.Library | Qomicex.Core API文档",
    "summary": "Class LiteloaderInstaller.Library Namespace Qomicex.Core.Modules.Helpers.Installers Assembly Qomicex.Core.dll public class LiteloaderInstaller.Library Inheritance object LiteloaderInstaller.Library Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Artifact public LiteloaderInstaller.Artifact? Artifact { get; set; } Property Value LiteloaderInstaller.Artifact DownloadInfo public LiteloaderInstaller.LibraryDownloadInfo? DownloadInfo { get; set; } Property Value LiteloaderInstaller.LibraryDownloadInfo Url public string? Url { get; set; } Property Value string"
  },
  "api/Qomicex.Core.Modules.Helpers.Installers.LiteloaderInstaller.LibraryDownloadInfo.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Installers.LiteloaderInstaller.LibraryDownloadInfo.html",
    "title": "Class LiteloaderInstaller.LibraryDownloadInfo | Qomicex.Core API文档",
    "summary": "Class LiteloaderInstaller.LibraryDownloadInfo Namespace Qomicex.Core.Modules.Helpers.Installers Assembly Qomicex.Core.dll public class LiteloaderInstaller.LibraryDownloadInfo Inheritance object LiteloaderInstaller.LibraryDownloadInfo Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Path public string? Path { get; set; } Property Value string Url public string? Url { get; set; } Property Value string"
  },
  "api/Qomicex.Core.Modules.Helpers.Installers.LiteloaderInstaller.LiteLoaderRemoteVersion.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Installers.LiteloaderInstaller.LiteLoaderRemoteVersion.html",
    "title": "Class LiteloaderInstaller.LiteLoaderRemoteVersion | Qomicex.Core API文档",
    "summary": "Class LiteloaderInstaller.LiteLoaderRemoteVersion Namespace Qomicex.Core.Modules.Helpers.Installers Assembly Qomicex.Core.dll public class LiteloaderInstaller.LiteLoaderRemoteVersion Inheritance object LiteloaderInstaller.LiteLoaderRemoteVersion Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors LiteLoaderRemoteVersion(string, string, List<string>, string, List<Library>) public LiteLoaderRemoteVersion(string gameVersion, string selfVersion, List<string> urls, string tweakClass, List<LiteloaderInstaller.Library> libraries) Parameters gameVersion string selfVersion string urls List<string> tweakClass string libraries List<LiteloaderInstaller.Library> Properties GameVersion public string GameVersion { get; set; } Property Value string Libraries public List<LiteloaderInstaller.Library> Libraries { get; set; } Property Value List<LiteloaderInstaller.Library> SelfVersion public string SelfVersion { get; set; } Property Value string TweakClass public string TweakClass { get; set; } Property Value string Urls public List<string> Urls { get; set; } Property Value List<string>"
  },
  "api/Qomicex.Core.Modules.Helpers.Installers.LiteloaderInstaller.Version.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Installers.LiteloaderInstaller.Version.html",
    "title": "Class LiteloaderInstaller.Version | Qomicex.Core API文档",
    "summary": "Class LiteloaderInstaller.Version Namespace Qomicex.Core.Modules.Helpers.Installers Assembly Qomicex.Core.dll public class LiteloaderInstaller.Version Inheritance object LiteloaderInstaller.Version Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Id public string? Id { get; set; } Property Value string Methods SetJson(string) public void SetJson(string json) Parameters json string ToJson() public string ToJson() Returns string"
  },
  "api/Qomicex.Core.Modules.Helpers.Installers.LiteloaderInstaller.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Installers.LiteloaderInstaller.html",
    "title": "Class LiteloaderInstaller | Qomicex.Core API文档",
    "summary": "Class LiteloaderInstaller Namespace Qomicex.Core.Modules.Helpers.Installers Assembly Qomicex.Core.dll public class LiteloaderInstaller : InstallerBase, IInstaller Inheritance object InstallerBase LiteloaderInstaller Implements IInstaller Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors LiteloaderInstaller(int, string, string) public LiteloaderInstaller(int sourceId, string gameDir, string gameVersion) Parameters sourceId int gameDir string gameVersion string Methods InstallAsync(string, string, string?, string?, string?, string?) public void InstallAsync(string versionId, string inheritsFromJson, string? modLoaderVersion, string? gameVersion, string? para3, string? para4) Parameters versionId string inheritsFromJson string modLoaderVersion string gameVersion string para3 string para4 string InstallLiteLoaderAsync(string, string, string, IProgress<InstallProgress>?, CancellationToken) public Task<bool> InstallLiteLoaderAsync(string versionId, string mcVersion, string liteVersion, IProgress<LiteloaderInstaller.InstallProgress>? progress = null, CancellationToken cancellationToken = default) Parameters versionId string mcVersion string liteVersion string progress IProgress<LiteloaderInstaller.InstallProgress> cancellationToken CancellationToken Returns Task<bool>"
  },
  "api/Qomicex.Core.Modules.Helpers.Installers.NeoForgeInstaller.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Installers.NeoForgeInstaller.html",
    "title": "Class NeoForgeInstaller | Qomicex.Core API文档",
    "summary": "Class NeoForgeInstaller Namespace Qomicex.Core.Modules.Helpers.Installers Assembly Qomicex.Core.dll public class NeoForgeInstaller : ForgeInstallerBase, IInstaller Inheritance object InstallerBase ForgeInstallerBase NeoForgeInstaller Implements IInstaller Inherited Members ForgeInstallerBase.SourceId ForgeInstallerBase.ResolveUrl(string) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors NeoForgeInstaller(int, string, string) public NeoForgeInstaller(int sourceId, string gameDir, string gameVersion) Parameters sourceId int gameDir string gameVersion string Methods GetMissNeoForgeLibraries(string, string) 获取缺失的 NeoForge 库文件列表 public List<LocalResourceHelper.MissFileData> GetMissNeoForgeLibraries(string neoForgeInstallerPath, string versionId) Parameters neoForgeInstallerPath string NeoForge 安装器路径 versionId string 版本ID Returns List<LocalResourceHelper.MissFileData> 缺失库文件列表 InstallAsync(string, string, string?, string?, string?, string?) public void InstallAsync(string versionId, string inheritsFromJson, string? javaPath, string? neoForgeInstallerPath, string? para3, string? para4) Parameters versionId string inheritsFromJson string javaPath string neoForgeInstallerPath string para3 string para4 string"
  },
  "api/Qomicex.Core.Modules.Helpers.Installers.OptiFineInstaller.OptiFineVersionInfo.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Installers.OptiFineInstaller.OptiFineVersionInfo.html",
    "title": "Class OptiFineInstaller.OptiFineVersionInfo | Qomicex.Core API文档",
    "summary": "Class OptiFineInstaller.OptiFineVersionInfo Namespace Qomicex.Core.Modules.Helpers.Installers Assembly Qomicex.Core.dll public class OptiFineInstaller.OptiFineVersionInfo Inheritance object OptiFineInstaller.OptiFineVersionInfo Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties FileName public string? FileName { get; set; } Property Value string McVersion public string? McVersion { get; set; } Property Value string Patch public string? Patch { get; set; } Property Value string Type public string? Type { get; set; } Property Value string"
  },
  "api/Qomicex.Core.Modules.Helpers.Installers.OptiFineInstaller.Version.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Installers.OptiFineInstaller.Version.html",
    "title": "Class OptiFineInstaller.Version | Qomicex.Core API文档",
    "summary": "Class OptiFineInstaller.Version Namespace Qomicex.Core.Modules.Helpers.Installers Assembly Qomicex.Core.dll public class OptiFineInstaller.Version Inheritance object OptiFineInstaller.Version Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Id public string? Id { get; set; } Property Value string Methods SetJson(string) public void SetJson(string json) Parameters json string ToJson() public string ToJson() Returns string"
  },
  "api/Qomicex.Core.Modules.Helpers.Installers.OptiFineInstaller.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Installers.OptiFineInstaller.html",
    "title": "Class OptiFineInstaller | Qomicex.Core API文档",
    "summary": "Class OptiFineInstaller Namespace Qomicex.Core.Modules.Helpers.Installers Assembly Qomicex.Core.dll OptiFine安装器，负责下载和安装OptiFine优化模组 public class OptiFineInstaller : InstallerBase, IInstaller Inheritance object InstallerBase OptiFineInstaller Implements IInstaller Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors OptiFineInstaller(int, string, string) public OptiFineInstaller(int sourceId, string gameDir, string gameVersion) Parameters sourceId int gameDir string gameVersion string Methods GetAvailableVersionsAsync() 获取指定Minecraft版本的可用OptiFine版本列表 public Task<List<OptiFineInstaller.OptiFineVersionInfo>> GetAvailableVersionsAsync() Returns Task<List<OptiFineInstaller.OptiFineVersionInfo>> InstallAsync(string, string, string?, string?, string?, string?) public void InstallAsync(string versionId, string inheritsFromJson, string? modLoaderVersion, string? installerFilePath, string? javaPath, string? para4) Parameters versionId string inheritsFromJson string modLoaderVersion string installerFilePath string javaPath string para4 string"
  },
  "api/Qomicex.Core.Modules.Helpers.Installers.QuiltInstaller.Library.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Installers.QuiltInstaller.Library.html",
    "title": "Class QuiltInstaller.Library | Qomicex.Core API文档",
    "summary": "Class QuiltInstaller.Library Namespace Qomicex.Core.Modules.Helpers.Installers Assembly Qomicex.Core.dll public class QuiltInstaller.Library Inheritance object QuiltInstaller.Library Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Md5 public string? Md5 { get; set; } Property Value string Name public string? Name { get; set; } Property Value string Sha1 public string? Sha1 { get; set; } Property Value string Sha256 public string? Sha256 { get; set; } Property Value string Sha512 public string? Sha512 { get; set; } Property Value string Size public long? Size { get; set; } Property Value long? Url public string? Url { get; set; } Property Value string"
  },
  "api/Qomicex.Core.Modules.Helpers.Installers.QuiltInstaller.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Installers.QuiltInstaller.html",
    "title": "Class QuiltInstaller | Qomicex.Core API文档",
    "summary": "Class QuiltInstaller Namespace Qomicex.Core.Modules.Helpers.Installers Assembly Qomicex.Core.dll public class QuiltInstaller : InstallerBase, IInstaller Inheritance object InstallerBase QuiltInstaller Implements IInstaller Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors QuiltInstaller(int, string) public QuiltInstaller(int downloadSource, string gameDir) Parameters downloadSource int gameDir string Methods InstallAsync(string, string, string?, string?, string?, string?) 为指定的游戏版本和整合包标识符安装指定版本的 Quilt 模组加载器。 public void InstallAsync(string versionId, string inheritsFromJson, string? quiltVersion, string? gameVersion, string? para3, string? para4) Parameters versionId string 要安装 Quilt 的整合包或实例的唯一标识符。不能为空。 inheritsFromJson string 继承自版本的JSON内容。可为空，为空时尝试从游戏目录读取。 quiltVersion string 要安装的 Quilt 模组加载器版本。必须是有效的 Quilt 版本字符串。 gameVersion string Quilt 应安装的游戏版本。必须是受支持的游戏版本。 para3 string para4 string InstallQuiltAsync(string, string, string, string?) 异步安装 Quilt Loader public Task<bool> InstallQuiltAsync(string versionId, string quiltVersion, string gameVersion, string? inheritsFromJson = null) Parameters versionId string 生成的版本ID quiltVersion string 欲安装的Quilt版本 gameVersion string 原版游戏版本 inheritsFromJson string 继承自版本的JSON内容，可为空 Returns Task<bool> 是否成功"
  },
  "api/Qomicex.Core.Modules.Helpers.Installers.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Installers.html",
    "title": "Namespace Qomicex.Core.Modules.Helpers.Installers | Qomicex.Core API文档",
    "summary": "Namespace Qomicex.Core.Modules.Helpers.Installers Classes FabricInstaller FabricInstaller.Library ForgeInstaller ForgeInstallerBase InstallerBase LiteloaderInstaller LiteloaderInstaller.Artifact LiteloaderInstaller.InstallProgress LiteloaderInstaller.Library LiteloaderInstaller.LibraryDownloadInfo LiteloaderInstaller.LiteLoaderRemoteVersion LiteloaderInstaller.Version NeoForgeInstaller OptiFineInstaller OptiFine安装器，负责下载和安装OptiFine优化模组 OptiFineInstaller.OptiFineVersionInfo OptiFineInstaller.Version QuiltInstaller QuiltInstaller.Library Interfaces IInstaller Enums InstallerBase.DownloadSource InstallerBase.InstallType"
  },
  "api/Qomicex.Core.Modules.Helpers.JavaHelper.JavaInfoExtended.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.JavaHelper.JavaInfoExtended.html",
    "title": "Class JavaHelper.JavaInfoExtended | Qomicex.Core API文档",
    "summary": "Class JavaHelper.JavaInfoExtended Namespace Qomicex.Core.Modules.Helpers Assembly Qomicex.Core.dll public class JavaHelper.JavaInfoExtended : DataModules.DataDetails.Java Inheritance object DataModules.DataDetails.Java JavaHelper.JavaInfoExtended Inherited Members DataModules.DataDetails.Java.Name DataModules.DataDetails.Java.Path DataModules.DataDetails.Java.Version DataModules.DataDetails.Java.VersionID DataModules.DataDetails.Java.Type DataModules.DataDetails.Java.Arch object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties DiscoveredBy public string DiscoveredBy { get; set; } Property Value string State public JavaHelper.JavaState State { get; set; } Property Value JavaHelper.JavaState StateMessage public string StateMessage { get; set; } Property Value string"
  },
  "api/Qomicex.Core.Modules.Helpers.JavaHelper.JavaSearchMode.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.JavaHelper.JavaSearchMode.html",
    "title": "Enum JavaHelper.JavaSearchMode | Qomicex.Core API文档",
    "summary": "Enum JavaHelper.JavaSearchMode Namespace Qomicex.Core.Modules.Helpers Assembly Qomicex.Core.dll public enum JavaHelper.JavaSearchMode Fields Custom = 2 Deep = 1 Quick = 0"
  },
  "api/Qomicex.Core.Modules.Helpers.JavaHelper.JavaSearchOptions.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.JavaHelper.JavaSearchOptions.html",
    "title": "Class JavaHelper.JavaSearchOptions | Qomicex.Core API文档",
    "summary": "Class JavaHelper.JavaSearchOptions Namespace Qomicex.Core.Modules.Helpers Assembly Qomicex.Core.dll public class JavaHelper.JavaSearchOptions Inheritance object JavaHelper.JavaSearchOptions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties CustomExcludePaths public List<string> CustomExcludePaths { get; set; } Property Value List<string> CustomRootPath public string? CustomRootPath { get; set; } Property Value string GameDir public string? GameDir { get; set; } Property Value string IncludeJDK public bool IncludeJDK { get; set; } Property Value bool IncludeJRE public bool IncludeJRE { get; set; } Property Value bool IncludeNetworkDrives public bool IncludeNetworkDrives { get; set; } Property Value bool MaxDepth public int MaxDepth { get; set; } Property Value int MaxResults public int MaxResults { get; set; } Property Value int Mode public JavaHelper.JavaSearchMode Mode { get; set; } Property Value JavaHelper.JavaSearchMode ScanHiddenFolders public bool ScanHiddenFolders { get; set; } Property Value bool"
  },
  "api/Qomicex.Core.Modules.Helpers.JavaHelper.JavaState.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.JavaHelper.JavaState.html",
    "title": "Enum JavaHelper.JavaState | Qomicex.Core API文档",
    "summary": "Enum JavaHelper.JavaState Namespace Qomicex.Core.Modules.Helpers Assembly Qomicex.Core.dll public enum JavaHelper.JavaState Fields CorruptedReleaseFile = 3 InvalidPath = 1 MissingReleaseFile = 2 UnknownError = 4 Valid = 0"
  },
  "api/Qomicex.Core.Modules.Helpers.JavaHelper.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.JavaHelper.html",
    "title": "Class JavaHelper | Qomicex.Core API文档",
    "summary": "Class JavaHelper Namespace Qomicex.Core.Modules.Helpers Assembly Qomicex.Core.dll public static class JavaHelper Inheritance object JavaHelper Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields DeepOptions public static readonly JavaHelper.JavaSearchOptions DeepOptions Field Value JavaHelper.JavaSearchOptions QuickOptions public static readonly JavaHelper.JavaSearchOptions QuickOptions Field Value JavaHelper.JavaSearchOptions Methods CheckJavaCompatibility(JavaInfoExtended, string, string) public static bool CheckJavaCompatibility(JavaHelper.JavaInfoExtended java, string minecraftVersion, string gameDir) Parameters java JavaHelper.JavaInfoExtended minecraftVersion string gameDir string Returns bool GetRecommendedJava(List<JavaInfoExtended>, string, string) public static List<JavaHelper.JavaInfoExtended> GetRecommendedJava(List<JavaHelper.JavaInfoExtended> javaList, string minecraftVersion, string gameDir) Parameters javaList List<JavaHelper.JavaInfoExtended> minecraftVersion string gameDir string Returns List<JavaHelper.JavaInfoExtended> SearchJava(JavaSearchOptions?) public static List<JavaHelper.JavaInfoExtended> SearchJava(JavaHelper.JavaSearchOptions? options = null) Parameters options JavaHelper.JavaSearchOptions Returns List<JavaHelper.JavaInfoExtended>"
  },
  "api/Qomicex.Core.Modules.Helpers.LogAnalysis.Analyzers.CrashReportAnalyzer.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.LogAnalysis.Analyzers.CrashReportAnalyzer.html",
    "title": "Class CrashReportAnalyzer | Qomicex.Core API文档",
    "summary": "Class CrashReportAnalyzer Namespace Qomicex.Core.Modules.Helpers.LogAnalysis.Analyzers Assembly Qomicex.Core.dll 崩溃报告分析器 解析 crash-reports/*.txt 文件格式 public class CrashReportAnalyzer Inheritance object CrashReportAnalyzer Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods AnalyzeAsync(string) 分析崩溃报告文件 public Task<CrashReportInfo> AnalyzeAsync(string filePath) Parameters filePath string Returns Task<CrashReportInfo> AnalyzeContent(string, string) 分析崩溃报告内容 public CrashReportInfo AnalyzeContent(string content, string fileName = \"\") Parameters content string fileName string Returns CrashReportInfo"
  },
  "api/Qomicex.Core.Modules.Helpers.LogAnalysis.Analyzers.CrashReportInfo.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.LogAnalysis.Analyzers.CrashReportInfo.html",
    "title": "Class CrashReportInfo | Qomicex.Core API文档",
    "summary": "Class CrashReportInfo Namespace Qomicex.Core.Modules.Helpers.LogAnalysis.Analyzers Assembly Qomicex.Core.dll 崩溃报告信息 public class CrashReportInfo Inheritance object CrashReportInfo Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties AnalysisTime public DateTime AnalysisTime { get; set; } Property Value DateTime CrashTime public DateTime CrashTime { get; set; } Property Value DateTime FilePath public string FilePath { get; set; } Property Value string LoadedMods public List<ModInfo> LoadedMods { get; set; } Property Value List<ModInfo> MinecraftVersion public string MinecraftVersion { get; set; } Property Value string ModLoader public string ModLoader { get; set; } Property Value string ModLoaderVersion public string ModLoaderVersion { get; set; } Property Value string RawLogExcerpt public string RawLogExcerpt { get; set; } Property Value string StackTrace public List<string> StackTrace { get; set; } Property Value List<string>"
  },
  "api/Qomicex.Core.Modules.Helpers.LogAnalysis.Analyzers.DetectedIssueExtensions.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.LogAnalysis.Analyzers.DetectedIssueExtensions.html",
    "title": "Class DetectedIssueExtensions | Qomicex.Core API文档",
    "summary": "Class DetectedIssueExtensions Namespace Qomicex.Core.Modules.Helpers.LogAnalysis.Analyzers Assembly Qomicex.Core.dll 扩展DetectedIssue，添加堆栈追踪上下文 public static class DetectedIssueExtensions Inheritance object DetectedIssueExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods GetStackTraceContext(DetectedIssue) public static List<string>? GetStackTraceContext(this DetectedIssue issue) Parameters issue DetectedIssue Returns List<string> SetStackTraceContext(DetectedIssue, List<string>) public static void SetStackTraceContext(this DetectedIssue issue, List<string> stackTrace) Parameters issue DetectedIssue stackTrace List<string>"
  },
  "api/Qomicex.Core.Modules.Helpers.LogAnalysis.Analyzers.JavaExceptionAnalyzer.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.LogAnalysis.Analyzers.JavaExceptionAnalyzer.html",
    "title": "Class JavaExceptionAnalyzer | Qomicex.Core API文档",
    "summary": "Class JavaExceptionAnalyzer Namespace Qomicex.Core.Modules.Helpers.LogAnalysis.Analyzers Assembly Qomicex.Core.dll Java异常分析器 分析Java异常类型、堆栈追踪 public class JavaExceptionAnalyzer Inheritance object JavaExceptionAnalyzer Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors JavaExceptionAnalyzer(LogPatternDatabase) public JavaExceptionAnalyzer(LogPatternDatabase patternDatabase) Parameters patternDatabase LogPatternDatabase Methods Analyze(string[]) 分析日志中的Java异常 public List<DetectedIssue> Analyze(string[] lines) Parameters lines string[] Returns List<DetectedIssue> AnalyzeLine(string, int) 分析单行 public List<DetectedIssue> AnalyzeLine(string line, int lineNumber) Parameters line string lineNumber int Returns List<DetectedIssue>"
  },
  "api/Qomicex.Core.Modules.Helpers.LogAnalysis.Analyzers.MemoryIssueAnalyzer.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.LogAnalysis.Analyzers.MemoryIssueAnalyzer.html",
    "title": "Class MemoryIssueAnalyzer | Qomicex.Core API文档",
    "summary": "Class MemoryIssueAnalyzer Namespace Qomicex.Core.Modules.Helpers.LogAnalysis.Analyzers Assembly Qomicex.Core.dll 内存问题分析器 检测OOM错误、GC问题、内存泄漏 public class MemoryIssueAnalyzer Inheritance object MemoryIssueAnalyzer Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors MemoryIssueAnalyzer(LogPatternDatabase) public MemoryIssueAnalyzer(LogPatternDatabase patternDatabase) Parameters patternDatabase LogPatternDatabase Methods Analyze(string[]) 分析内存相关问题 public List<DetectedIssue> Analyze(string[] lines) Parameters lines string[] Returns List<DetectedIssue> AnalyzeLine(string, int) 分析单行 public List<DetectedIssue> AnalyzeLine(string line, int lineNumber) Parameters line string lineNumber int Returns List<DetectedIssue> GenerateMemorySummary(List<DetectedIssue>) 生成内存使用摘要 public static string GenerateMemorySummary(List<DetectedIssue> memoryIssues) Parameters memoryIssues List<DetectedIssue> Returns string"
  },
  "api/Qomicex.Core.Modules.Helpers.LogAnalysis.Analyzers.ModConflictAnalyzer.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.LogAnalysis.Analyzers.ModConflictAnalyzer.html",
    "title": "Class ModConflictAnalyzer | Qomicex.Core API文档",
    "summary": "Class ModConflictAnalyzer Namespace Qomicex.Core.Modules.Helpers.LogAnalysis.Analyzers Assembly Qomicex.Core.dll Mod冲突分析器 检测重复Mod、版本冲突、缺失依赖 public class ModConflictAnalyzer Inheritance object ModConflictAnalyzer Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ModConflictAnalyzer(LogPatternDatabase) public ModConflictAnalyzer(LogPatternDatabase patternDatabase) Parameters patternDatabase LogPatternDatabase Methods Analyze(string[]) 分析Mod相关冲突 public List<DetectedIssue> Analyze(string[] lines) Parameters lines string[] Returns List<DetectedIssue> AnalyzeLine(string, int) 分析单行 public List<DetectedIssue> AnalyzeLine(string line, int lineNumber) Parameters line string lineNumber int Returns List<DetectedIssue> ExtractConflictSummary(List<DetectedIssue>) 提取Mod冲突摘要信息 public static string ExtractConflictSummary(List<DetectedIssue> issues) Parameters issues List<DetectedIssue> Returns string"
  },
  "api/Qomicex.Core.Modules.Helpers.LogAnalysis.Analyzers.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.LogAnalysis.Analyzers.html",
    "title": "Namespace Qomicex.Core.Modules.Helpers.LogAnalysis.Analyzers | Qomicex.Core API文档",
    "summary": "Namespace Qomicex.Core.Modules.Helpers.LogAnalysis.Analyzers Classes CrashReportAnalyzer 崩溃报告分析器 解析 crash-reports/*.txt 文件格式 CrashReportInfo 崩溃报告信息 DetectedIssueExtensions 扩展DetectedIssue，添加堆栈追踪上下文 JavaExceptionAnalyzer Java异常分析器 分析Java异常类型、堆栈追踪 MemoryIssueAnalyzer 内存问题分析器 检测OOM错误、GC问题、内存泄漏 ModConflictAnalyzer Mod冲突分析器 检测重复Mod、版本冲突、缺失依赖"
  },
  "api/Qomicex.Core.Modules.Helpers.LogAnalysis.ILogAnalyzer.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.LogAnalysis.ILogAnalyzer.html",
    "title": "Interface ILogAnalyzer | Qomicex.Core API文档",
    "summary": "Interface ILogAnalyzer Namespace Qomicex.Core.Modules.Helpers.LogAnalysis Assembly Qomicex.Core.dll 日志分析器接口 public interface ILogAnalyzer Methods AnalyzeAsync(string) 分析崩溃报告文件 Task<LogAnalysisResult> AnalyzeAsync(string filePath) Parameters filePath string 崩溃报告文件路径 Returns Task<LogAnalysisResult> 分析结果 AnalyzeContentAsync(string, string) 分析日志内容字符串 Task<LogAnalysisResult> AnalyzeContentAsync(string content, string fileName = \"\") Parameters content string 日志内容 fileName string 原始文件名（用于上下文） Returns Task<LogAnalysisResult> 分析结果"
  },
  "api/Qomicex.Core.Modules.Helpers.LogAnalysis.MinecraftLogAnalyzer.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.LogAnalysis.MinecraftLogAnalyzer.html",
    "title": "Class MinecraftLogAnalyzer | Qomicex.Core API文档",
    "summary": "Class MinecraftLogAnalyzer Namespace Qomicex.Core.Modules.Helpers.LogAnalysis Assembly Qomicex.Core.dll Minecraft 日志分析器主类 整合所有分析器，提供统一的分析接口 public class MinecraftLogAnalyzer : ILogAnalyzer Inheritance object MinecraftLogAnalyzer Implements ILogAnalyzer Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors MinecraftLogAnalyzer(string) 初始化日志分析器 public MinecraftLogAnalyzer(string externalConfigPath = \"\") Parameters externalConfigPath string 外部配置文件路径（可选） Methods AnalyzeAsync(string) 分析崩溃报告文件 public Task<LogAnalysisResult> AnalyzeAsync(string filePath) Parameters filePath string Returns Task<LogAnalysisResult> AnalyzeContentAsync(string, string) 分析日志内容字符串 public Task<LogAnalysisResult> AnalyzeContentAsync(string content, string fileName = \"\") Parameters content string fileName string Returns Task<LogAnalysisResult> GenerateSummary(LogAnalysisResult) 生成分析报告摘要 public static string GenerateSummary(LogAnalysisResult result) Parameters result LogAnalysisResult Returns string GetAllSolutions(LogAnalysisResult) 获取所有建议的解决方案（按优先级排序） public static List<SuggestedSolution> GetAllSolutions(LogAnalysisResult result) Parameters result LogAnalysisResult Returns List<SuggestedSolution> GetCrashReportFiles(string) 获取崩溃报告目录中的所有崩溃报告文件 public static List<string> GetCrashReportFiles(string gameDir) Parameters gameDir string Returns List<string> GetIssuesByCategory(LogAnalysisResult, IssueCategory) 获取指定类别的所有问题 public static List<DetectedIssue> GetIssuesByCategory(LogAnalysisResult result, IssueCategory category) Parameters result LogAnalysisResult category IssueCategory Returns List<DetectedIssue> GetIssuesBySeverity(LogAnalysisResult, IssueSeverity) 获取指定严重级别的所有问题 public static List<DetectedIssue> GetIssuesBySeverity(LogAnalysisResult result, IssueSeverity severity) Parameters result LogAnalysisResult severity IssueSeverity Returns List<DetectedIssue> GetLatestCrashReport(string) 获取最近的崩溃报告文件 public static string? GetLatestCrashReport(string gameDir) Parameters gameDir string Returns string GetMemorySummary(LogAnalysisResult) 获取内存使用摘要 public string GetMemorySummary(LogAnalysisResult result) Parameters result LogAnalysisResult Returns string GetModConflictSummary(LogAnalysisResult) 获取Mod冲突摘要 public string GetModConflictSummary(LogAnalysisResult result) Parameters result LogAnalysisResult Returns string GetPrimarySolution(LogAnalysisResult) 获取首要解决方案（优先级最高的第一个解决方案） public static SuggestedSolution? GetPrimarySolution(LogAnalysisResult result) Parameters result LogAnalysisResult Returns SuggestedSolution GetRecentCrashReports(string, int) 获取最近N天内的崩溃报告 public static List<string> GetRecentCrashReports(string gameDir, int days = 7) Parameters gameDir string days int Returns List<string>"
  },
  "api/Qomicex.Core.Modules.Helpers.LogAnalysis.Models.DetectedIssue.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.LogAnalysis.Models.DetectedIssue.html",
    "title": "Class DetectedIssue | Qomicex.Core API文档",
    "summary": "Class DetectedIssue Namespace Qomicex.Core.Modules.Helpers.LogAnalysis.Models Assembly Qomicex.Core.dll 检测到的问题 public class DetectedIssue Inheritance object DetectedIssue Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Extension Methods DetectedIssueExtensions.GetStackTraceContext(DetectedIssue) DetectedIssueExtensions.SetStackTraceContext(DetectedIssue, List<string>) Properties CapturedGroups 正则捕获组 public Dictionary<string, string> CapturedGroups { get; set; } Property Value Dictionary<string, string> Category 问题分类 public IssueCategory Category { get; set; } Property Value IssueCategory LineNumber 在日志中的行号 public int LineNumber { get; set; } Property Value int MatchedText 匹配的原始文本 public string MatchedText { get; set; } Property Value string Name 问题名称（本地化） public string Name { get; set; } Property Value string PatternId 错误模式ID public string PatternId { get; set; } Property Value string Severity 严重级别 public IssueSeverity Severity { get; set; } Property Value IssueSeverity Solutions 建议的解决方案 public List<SuggestedSolution> Solutions { get; set; } Property Value List<SuggestedSolution>"
  },
  "api/Qomicex.Core.Modules.Helpers.LogAnalysis.Models.IssueCategory.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.LogAnalysis.Models.IssueCategory.html",
    "title": "Enum IssueCategory | Qomicex.Core API文档",
    "summary": "Enum IssueCategory Namespace Qomicex.Core.Modules.Helpers.LogAnalysis.Models Assembly Qomicex.Core.dll 问题分类枚举 public enum IssueCategory Fields JavaRelated = 2 Java相关问题 Memory = 0 内存问题 ModConflict = 1 Mod冲突 Performance = 4 性能问题 Resource = 3 资源问题 Unknown = 5 未知问题"
  },
  "api/Qomicex.Core.Modules.Helpers.LogAnalysis.Models.IssueSeverity.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.LogAnalysis.Models.IssueSeverity.html",
    "title": "Enum IssueSeverity | Qomicex.Core API文档",
    "summary": "Enum IssueSeverity Namespace Qomicex.Core.Modules.Helpers.LogAnalysis.Models Assembly Qomicex.Core.dll 问题严重级别枚举 public enum IssueSeverity Fields Critical = 0 严重（无法启动/立即崩溃） Error = 1 错误（功能异常） Info = 3 信息 Warning = 2 警告（潜在问题）"
  },
  "api/Qomicex.Core.Modules.Helpers.LogAnalysis.Models.LogAnalysisResult.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.LogAnalysis.Models.LogAnalysisResult.html",
    "title": "Class LogAnalysisResult | Qomicex.Core API文档",
    "summary": "Class LogAnalysisResult Namespace Qomicex.Core.Modules.Helpers.LogAnalysis.Models Assembly Qomicex.Core.dll 日志分析结果 public class LogAnalysisResult Inheritance object LogAnalysisResult Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties AnalysisTime 分析执行时间 public DateTime AnalysisTime { get; set; } Property Value DateTime CrashTime 崩溃发生时间（从文件名或日志内容提取） public DateTime CrashTime { get; set; } Property Value DateTime ErrorMessage 分析过程中的错误信息 public string ErrorMessage { get; set; } Property Value string FilePath 分析的文件路径 public string FilePath { get; set; } Property Value string IsGameCrashed 是否检测到游戏崩溃 public bool IsGameCrashed { get; set; } Property Value bool IsSuccess 分析是否成功完成 public bool IsSuccess { get; set; } Property Value bool Issues 检测到的问题列表 public List<DetectedIssue> Issues { get; set; } Property Value List<DetectedIssue> LoadedMods 加载的Mod列表 public List<ModInfo> LoadedMods { get; set; } Property Value List<ModInfo> MinecraftVersion Minecraft版本 public string MinecraftVersion { get; set; } Property Value string ModLoader Mod加载器类型（Forge/Fabric/Quilt等） public string ModLoader { get; set; } Property Value string RawLogExcerpt 原始日志摘录（前100行关键内容） public string RawLogExcerpt { get; set; } Property Value string StackTrace 异常堆栈追踪 public List<string> StackTrace { get; set; } Property Value List<string>"
  },
  "api/Qomicex.Core.Modules.Helpers.LogAnalysis.Models.ModInfo.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.LogAnalysis.Models.ModInfo.html",
    "title": "Class ModInfo | Qomicex.Core API文档",
    "summary": "Class ModInfo Namespace Qomicex.Core.Modules.Helpers.LogAnalysis.Models Assembly Qomicex.Core.dll Mod信息 public class ModInfo Inheritance object ModInfo Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties FileName 文件名 public string FileName { get; set; } Property Value string Id Mod ID public string Id { get; set; } Property Value string Name Mod名称 public string Name { get; set; } Property Value string Version Mod版本 public string Version { get; set; } Property Value string"
  },
  "api/Qomicex.Core.Modules.Helpers.LogAnalysis.Models.SuggestedSolution.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.LogAnalysis.Models.SuggestedSolution.html",
    "title": "Class SuggestedSolution | Qomicex.Core API文档",
    "summary": "Class SuggestedSolution Namespace Qomicex.Core.Modules.Helpers.LogAnalysis.Models Assembly Qomicex.Core.dll 建议的解决方案 public class SuggestedSolution Inheritance object SuggestedSolution Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties ActionType 操作类型标识 public string ActionType { get; set; } Property Value string Description 解决方案描述（已填充变量） public string Description { get; set; } Property Value string Parameters 操作参数 public Dictionary<string, object> Parameters { get; set; } Property Value Dictionary<string, object> Priority 优先级（数字越小优先级越高） public int Priority { get; set; } Property Value int"
  },
  "api/Qomicex.Core.Modules.Helpers.LogAnalysis.Models.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.LogAnalysis.Models.html",
    "title": "Namespace Qomicex.Core.Modules.Helpers.LogAnalysis.Models | Qomicex.Core API文档",
    "summary": "Namespace Qomicex.Core.Modules.Helpers.LogAnalysis.Models Classes DetectedIssue 检测到的问题 LogAnalysisResult 日志分析结果 ModInfo Mod信息 SuggestedSolution 建议的解决方案 Enums IssueCategory 问题分类枚举 IssueSeverity 问题严重级别枚举"
  },
  "api/Qomicex.Core.Modules.Helpers.LogAnalysis.Patterns.ErrorPattern.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.LogAnalysis.Patterns.ErrorPattern.html",
    "title": "Class ErrorPattern | Qomicex.Core API文档",
    "summary": "Class ErrorPattern Namespace Qomicex.Core.Modules.Helpers.LogAnalysis.Patterns Assembly Qomicex.Core.dll 错误模式定义 public class ErrorPattern Inheritance object ErrorPattern Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Category public IssueCategory Category { get; set; } Property Value IssueCategory CompiledRegexes public List<Regex> CompiledRegexes { get; set; } Property Value List<Regex> I18nNames public Dictionary<string, I18nInfo> I18nNames { get; set; } Property Value Dictionary<string, I18nInfo> Id public string Id { get; set; } Property Value string IsUserPattern public bool IsUserPattern { get; set; } Property Value bool RegexPatterns public List<string> RegexPatterns { get; set; } Property Value List<string> Severity public IssueSeverity Severity { get; set; } Property Value IssueSeverity Solutions public List<PatternSolution> Solutions { get; set; } Property Value List<PatternSolution>"
  },
  "api/Qomicex.Core.Modules.Helpers.LogAnalysis.Patterns.I18nInfo.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.LogAnalysis.Patterns.I18nInfo.html",
    "title": "Class I18nInfo | Qomicex.Core API文档",
    "summary": "Class I18nInfo Namespace Qomicex.Core.Modules.Helpers.LogAnalysis.Patterns Assembly Qomicex.Core.dll 国际化信息 public class I18nInfo Inheritance object I18nInfo Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Description public string Description { get; set; } Property Value string Name public string Name { get; set; } Property Value string"
  },
  "api/Qomicex.Core.Modules.Helpers.LogAnalysis.Patterns.LogPatternDatabase.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.LogAnalysis.Patterns.LogPatternDatabase.html",
    "title": "Class LogPatternDatabase | Qomicex.Core API文档",
    "summary": "Class LogPatternDatabase Namespace Qomicex.Core.Modules.Helpers.LogAnalysis.Patterns Assembly Qomicex.Core.dll 日志错误模式数据库 public class LogPatternDatabase Inheritance object LogPatternDatabase Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors LogPatternDatabase(string) 初始化模式数据库 public LogPatternDatabase(string externalConfigPath = \"\") Parameters externalConfigPath string 外部配置文件路径（可选，用于用户自定义模式） Methods GetAllPatterns() 获取所有模式 public IReadOnlyList<ErrorPattern> GetAllPatterns() Returns IReadOnlyList<ErrorPattern> GetLocalizedDescription(ErrorPattern, string) 获取本地化描述 public string GetLocalizedDescription(ErrorPattern pattern, string language = \"zh\") Parameters pattern ErrorPattern language string Returns string GetLocalizedName(ErrorPattern, string) 获取本地化名称 public string GetLocalizedName(ErrorPattern pattern, string language = \"zh\") Parameters pattern ErrorPattern language string Returns string GetPatternById(string) 根据ID查找模式 public ErrorPattern? GetPatternById(string id) Parameters id string Returns ErrorPattern LoadPatterns() 加载所有错误模式 public void LoadPatterns() MatchPatterns(string, int) 匹配文本中的所有错误模式 public List<PatternMatchResult> MatchPatterns(string text, int lineNumber = 0) Parameters text string lineNumber int Returns List<PatternMatchResult>"
  },
  "api/Qomicex.Core.Modules.Helpers.LogAnalysis.Patterns.PatternMatchResult.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.LogAnalysis.Patterns.PatternMatchResult.html",
    "title": "Class PatternMatchResult | Qomicex.Core API文档",
    "summary": "Class PatternMatchResult Namespace Qomicex.Core.Modules.Helpers.LogAnalysis.Patterns Assembly Qomicex.Core.dll 模式匹配结果 public class PatternMatchResult Inheritance object PatternMatchResult Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties CapturedGroups public Dictionary<string, string> CapturedGroups { get; set; } Property Value Dictionary<string, string> LineNumber public int LineNumber { get; set; } Property Value int MatchedText public string MatchedText { get; set; } Property Value string Pattern public ErrorPattern Pattern { get; set; } Property Value ErrorPattern"
  },
  "api/Qomicex.Core.Modules.Helpers.LogAnalysis.Patterns.PatternSolution.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.LogAnalysis.Patterns.PatternSolution.html",
    "title": "Class PatternSolution | Qomicex.Core API文档",
    "summary": "Class PatternSolution Namespace Qomicex.Core.Modules.Helpers.LogAnalysis.Patterns Assembly Qomicex.Core.dll 模式解决方案 public class PatternSolution Inheritance object PatternSolution Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties ActionType public string ActionType { get; set; } Property Value string Description public string Description { get; set; } Property Value string Parameters public Dictionary<string, object> Parameters { get; set; } Property Value Dictionary<string, object> Priority public int Priority { get; set; } Property Value int"
  },
  "api/Qomicex.Core.Modules.Helpers.LogAnalysis.Patterns.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.LogAnalysis.Patterns.html",
    "title": "Namespace Qomicex.Core.Modules.Helpers.LogAnalysis.Patterns | Qomicex.Core API文档",
    "summary": "Namespace Qomicex.Core.Modules.Helpers.LogAnalysis.Patterns Classes ErrorPattern 错误模式定义 I18nInfo 国际化信息 LogPatternDatabase 日志错误模式数据库 PatternMatchResult 模式匹配结果 PatternSolution 模式解决方案"
  },
  "api/Qomicex.Core.Modules.Helpers.LogAnalysis.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.LogAnalysis.html",
    "title": "Namespace Qomicex.Core.Modules.Helpers.LogAnalysis | Qomicex.Core API文档",
    "summary": "Namespace Qomicex.Core.Modules.Helpers.LogAnalysis Classes MinecraftLogAnalyzer Minecraft 日志分析器主类 整合所有分析器，提供统一的分析接口 Interfaces ILogAnalyzer 日志分析器接口"
  },
  "api/Qomicex.Core.Modules.Helpers.MultiPlatforms.SystemMemoryHelper.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.MultiPlatforms.SystemMemoryHelper.html",
    "title": "Class SystemMemoryHelper | Qomicex.Core API文档",
    "summary": "Class SystemMemoryHelper Namespace Qomicex.Core.Modules.Helpers.MultiPlatforms Assembly Qomicex.Core.dll public class SystemMemoryHelper Inheritance object SystemMemoryHelper Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods GetAvailablePhysicalMemory() Retrieves the amount of available physical memory on the current system, in bytes. public static long GetAvailablePhysicalMemory() Returns long The number of bytes of available physical memory. Returns -1 if the operating system is not supported or the value cannot be determined. Remarks This method supports Windows, Linux, and macOS platforms. On unsupported platforms, the method returns -1. The returned value may fluctuate rapidly as system memory usage changes. GetOptimalMemory(double) 获取系统可用内存的指定百分比（单位：MB） public static long GetOptimalMemory(double percentage = 0.6) Parameters percentage double 使用比例，默认 0.6 Returns long MB，失败返回 -1 GetTotalPhysicalMemory() public static long GetTotalPhysicalMemory() Returns long"
  },
  "api/Qomicex.Core.Modules.Helpers.MultiPlatforms.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.MultiPlatforms.html",
    "title": "Namespace Qomicex.Core.Modules.Helpers.MultiPlatforms | Qomicex.Core API文档",
    "summary": "Namespace Qomicex.Core.Modules.Helpers.MultiPlatforms Classes SystemMemoryHelper"
  },
  "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge.CurseForgeBase.AuthorMeta.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge.CurseForgeBase.AuthorMeta.html",
    "title": "Class CurseForgeBase.AuthorMeta | Qomicex.Core API文档",
    "summary": "Class CurseForgeBase.AuthorMeta Namespace Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge Assembly Qomicex.Core.dll public class CurseForgeBase.AuthorMeta Inheritance object CurseForgeBase.AuthorMeta Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Id [JsonProperty(\"id\")] public string Id { get; set; } Property Value string Name [JsonProperty(\"name\")] public string Name { get; set; } Property Value string Url [JsonProperty(\"url\")] public string Url { get; set; } Property Value string"
  },
  "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge.CurseForgeBase.CategoryMeta.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge.CurseForgeBase.CategoryMeta.html",
    "title": "Class CurseForgeBase.CategoryMeta | Qomicex.Core API文档",
    "summary": "Class CurseForgeBase.CategoryMeta Namespace Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge Assembly Qomicex.Core.dll public class CurseForgeBase.CategoryMeta Inheritance object CurseForgeBase.CategoryMeta Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Id [JsonProperty(\"id\")] public int Id { get; set; } Property Value int Name [JsonProperty(\"name\")] public string Name { get; set; } Property Value string Slug [JsonProperty(\"slug\")] public string Slug { get; set; } Property Value string Url [JsonProperty(\"url\")] public string Url { get; set; } Property Value string"
  },
  "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge.CurseForgeBase.CurseForgeDependenciesMeta.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge.CurseForgeBase.CurseForgeDependenciesMeta.html",
    "title": "Class CurseForgeBase.CurseForgeDependenciesMeta | Qomicex.Core API文档",
    "summary": "Class CurseForgeBase.CurseForgeDependenciesMeta Namespace Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge Assembly Qomicex.Core.dll public class CurseForgeBase.CurseForgeDependenciesMeta Inheritance object CurseForgeBase.CurseForgeDependenciesMeta Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Id [JsonProperty(\"modId\")] public int Id { get; set; } Property Value int Type [JsonProperty(\"relationType\")] public int Type { get; set; } Property Value int"
  },
  "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge.CurseForgeBase.CurseForgeFilesMeta.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge.CurseForgeBase.CurseForgeFilesMeta.html",
    "title": "Class CurseForgeBase.CurseForgeFilesMeta | Qomicex.Core API文档",
    "summary": "Class CurseForgeBase.CurseForgeFilesMeta Namespace Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge Assembly Qomicex.Core.dll public class CurseForgeBase.CurseForgeFilesMeta Inheritance object CurseForgeBase.CurseForgeFilesMeta Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties FileId [JsonProperty(\"fileId\")] public string FileId { get; set; } Property Value string FileName [JsonProperty(\"fileName\")] public string FileName { get; set; } Property Value string GameVersion [JsonProperty(\"gameVersion\")] public string GameVersion { get; set; } Property Value string ModLoader [JsonProperty(\"modLoader\")] public int ModLoader { get; set; } Property Value int releaseType [JsonProperty(\"releaseType\")] public int releaseType { get; set; } Property Value int"
  },
  "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge.CurseForgeBase.CurseForgeInfo.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge.CurseForgeBase.CurseForgeInfo.html",
    "title": "Class CurseForgeBase.CurseForgeInfo | Qomicex.Core API文档",
    "summary": "Class CurseForgeBase.CurseForgeInfo Namespace Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge Assembly Qomicex.Core.dll public class CurseForgeBase.CurseForgeInfo Inheritance object CurseForgeBase.CurseForgeInfo Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Authors [JsonProperty(\"authors\")] public List<CurseForgeBase.AuthorMeta> Authors { get; set; } Property Value List<CurseForgeBase.AuthorMeta> Categories [JsonProperty(\"categories\")] public List<CurseForgeBase.CategoryMeta> Categories { get; set; } Property Value List<CurseForgeBase.CategoryMeta> Dependencies public List<CurseForgeBase.CurseForgeDependenciesMeta> Dependencies { get; set; } Property Value List<CurseForgeBase.CurseForgeDependenciesMeta> DownloadCount [JsonProperty(\"downloadCount\")] public int DownloadCount { get; set; } Property Value int Files [JsonProperty(\"latestFilesIndexes\")] public List<CurseForgeBase.CurseForgeFilesMeta> Files { get; set; } Property Value List<CurseForgeBase.CurseForgeFilesMeta> IconUrl [JsonProperty(\"iconUrl\")] public string IconUrl { get; set; } Property Value string Id [JsonProperty(\"id\")] public string Id { get; set; } Property Value string IsFeatured [JsonProperty(\"isFeatured\")] public bool IsFeatured { get; set; } Property Value bool Name [JsonProperty(\"name\")] public string Name { get; set; } Property Value string Screenshots [JsonProperty(\"screenshots\")] public List<CurseForgeBase.ScreenshotsMeta> Screenshots { get; set; } Property Value List<CurseForgeBase.ScreenshotsMeta> Slug [JsonProperty(\"slug\")] public string Slug { get; set; } Property Value string Status [JsonProperty(\"status\")] public int Status { get; set; } Property Value int Summary [JsonProperty(\"summary\")] public string Summary { get; set; } Property Value string"
  },
  "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge.CurseForgeBase.CurseForgeSearchResult.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge.CurseForgeBase.CurseForgeSearchResult.html",
    "title": "Class CurseForgeBase.CurseForgeSearchResult | Qomicex.Core API文档",
    "summary": "Class CurseForgeBase.CurseForgeSearchResult Namespace Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge Assembly Qomicex.Core.dll public class CurseForgeBase.CurseForgeSearchResult Inheritance object CurseForgeBase.CurseForgeSearchResult Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Authors public List<CurseForgeBase.AuthorMeta> Authors { get; set; } Property Value List<CurseForgeBase.AuthorMeta> Categories public List<CurseForgeBase.CategoryMeta> Categories { get; set; } Property Value List<CurseForgeBase.CategoryMeta> DownloadCount public string DownloadCount { get; set; } Property Value string GameVersion public string GameVersion { get; set; } Property Value string IconUrl public string IconUrl { get; set; } Property Value string Id public string Id { get; set; } Property Value string IsFeatured public bool IsFeatured { get; set; } Property Value bool Name public string Name { get; set; } Property Value string Screenshots public List<CurseForgeBase.ScreenshotsMeta> Screenshots { get; set; } Property Value List<CurseForgeBase.ScreenshotsMeta> Slug public string Slug { get; set; } Property Value string Status public string Status { get; set; } Property Value string Summary public string Summary { get; set; } Property Value string"
  },
  "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge.CurseForgeBase.ModLoaderType.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge.CurseForgeBase.ModLoaderType.html",
    "title": "Class CurseForgeBase.ModLoaderType | Qomicex.Core API文档",
    "summary": "Class CurseForgeBase.ModLoaderType Namespace Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge Assembly Qomicex.Core.dll public static class CurseForgeBase.ModLoaderType Inheritance object CurseForgeBase.ModLoaderType Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields All public static readonly List<string> All Field Value List<string> Any public const string Any = \"Any\" Field Value string Fabric public const string Fabric = \"Fabric\" Field Value string Forge public const string Forge = \"Forge\" Field Value string LiteLoader public const string LiteLoader = \"LiteLoader\" Field Value string NeoForge public const string NeoForge = \"NeoForge\" Field Value string Quilt public const string Quilt = \"Quilt\" Field Value string"
  },
  "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge.CurseForgeBase.ScreenshotsMeta.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge.CurseForgeBase.ScreenshotsMeta.html",
    "title": "Class CurseForgeBase.ScreenshotsMeta | Qomicex.Core API文档",
    "summary": "Class CurseForgeBase.ScreenshotsMeta Namespace Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge Assembly Qomicex.Core.dll public class CurseForgeBase.ScreenshotsMeta Inheritance object CurseForgeBase.ScreenshotsMeta Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Description [JsonProperty(\"description\")] public string Description { get; set; } Property Value string Id [JsonProperty(\"id\")] public int Id { get; set; } Property Value int ModId [JsonProperty(\"modId\")] public int ModId { get; set; } Property Value int ThumbnailUrl [JsonProperty(\"thumbnailUrl\")] public string ThumbnailUrl { get; set; } Property Value string Title [JsonProperty(\"title\")] public string Title { get; set; } Property Value string Url [JsonProperty(\"url\")] public string Url { get; set; } Property Value string"
  },
  "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge.CurseForgeBase.SortField.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge.CurseForgeBase.SortField.html",
    "title": "Enum CurseForgeBase.SortField | Qomicex.Core API文档",
    "summary": "Enum CurseForgeBase.SortField Namespace Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge Assembly Qomicex.Core.dll public enum CurseForgeBase.SortField Fields Author = 5 Category = 7 EarlyAccess = 9 Featured = 1 FeaturedReleased = 10 GameVersion = 8 LastUpdated = 3 Name = 4 Popularity = 2 Rating = 12 ReleasedDate = 11 TotalDownloads = 6"
  },
  "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge.CurseForgeBase.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge.CurseForgeBase.html",
    "title": "Class CurseForgeBase | Qomicex.Core API文档",
    "summary": "Class CurseForgeBase Namespace Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge Assembly Qomicex.Core.dll public class CurseForgeBase Inheritance object CurseForgeBase Derived DataPacks Modpacks Mods ResourcePacks Shaders Worlds Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors CurseForgeBase(string, string, string) public CurseForgeBase(string ApiKey, string SearchUrl, string ModURL) Parameters ApiKey string SearchUrl string ModURL string Methods GetDownloadUrl(string, string) 获取指定资源的下载链接 public string GetDownloadUrl(string Id, string FileId) Parameters Id string FileId string Returns string Exceptions ArgumentNullException Exception GetDownloadUrlAsync(string, string) 异步获取指定资源的下载链接 public Task<string> GetDownloadUrlAsync(string Id, string FileId) Parameters Id string FileId string Returns Task<string> Exceptions ArgumentNullException Exception"
  },
  "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge.DataPacks.Category.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge.DataPacks.Category.html",
    "title": "Enum DataPacks.Category | Qomicex.Core API文档",
    "summary": "Enum DataPacks.Category Namespace Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge Assembly Qomicex.Core.dll public enum DataPacks.Category Fields Adventure = 6948 Fantasy = 6949 Library = 6950 Magic = 6952 Miscellaneous = 6947 ModSupport = 6946 Tech = 6951 Utility = 6953"
  },
  "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge.DataPacks.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge.DataPacks.html",
    "title": "Class DataPacks | Qomicex.Core API文档",
    "summary": "Class DataPacks Namespace Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge Assembly Qomicex.Core.dll public class DataPacks : CurseForgeBase Inheritance object CurseForgeBase DataPacks Inherited Members CurseForgeBase.GetDownloadUrl(string, string) CurseForgeBase.GetDownloadUrlAsync(string, string) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors DataPacks(string) public DataPacks(string ApiKey) Parameters ApiKey string Methods GetModInfoAsync(string) 异步获取指定DataPack的详细信息 public Task<CurseForgeBase.CurseForgeInfo> GetModInfoAsync(string Id) Parameters Id string ModId Returns Task<CurseForgeBase.CurseForgeInfo> DataPack信息 Exceptions ArgumentNullException Exception GetRecommendDataPacks(string?[], int?[], int?, int?, int?) 获取推荐的DataPack列表 public Task<List<CurseForgeBase.CurseForgeSearchResult>> GetRecommendDataPacks(string?[] GameVersions, int?[] Categories, int? SortField = 0, int? Page = 1, int? PageSize = 25) Parameters GameVersions string[] 游戏版本 Categories int?[] 分类 SortField int? 排序方式 Page int? 页数 PageSize int? 页面大小 Returns Task<List<CurseForgeBase.CurseForgeSearchResult>> 结果 SearchAsync(string, string?[], int?[], int?, int?, int?) 异步搜索CurseForge上的DataPack public Task<List<CurseForgeBase.CurseForgeSearchResult>> SearchAsync(string SearchFilter, string?[] GameVersions, int?[] Categories, int? SortField = 0, int? Page = 1, int? PageSize = 25) Parameters SearchFilter string 搜索关键词 GameVersions string[] 游戏版本 Categories int?[] 分类标签 SortField int? 排序方式 Page int? 页数 PageSize int? 单页搜索结果条目数 Returns Task<List<CurseForgeBase.CurseForgeSearchResult>> Exceptions ArgumentOutOfRangeException Exception"
  },
  "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge.Modpacks.Category.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge.Modpacks.Category.html",
    "title": "Enum Modpacks.Category | Qomicex.Core API文档",
    "summary": "Enum Modpacks.Category Namespace Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge Assembly Qomicex.Core.dll public enum Modpacks.Category Fields AdventureAndRpg = 4475 CombatOrPvp = 4483 Exploration = 4476 ExtraLarge = 4482 FtbOfficialPack = 4487 Hardcore = 4479 Horror = 7418 Magic = 4473 MapBased = 4480 MiniGame = 4477 Multiplayer = 4484 Quests = 4478 Sci_fi = 4474 Skyblock = 4736 SmallOrLight = 4481 Tech = 4472 VanillaAdd = 5128"
  },
  "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge.Modpacks.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge.Modpacks.html",
    "title": "Class Modpacks | Qomicex.Core API文档",
    "summary": "Class Modpacks Namespace Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge Assembly Qomicex.Core.dll public class Modpacks : CurseForgeBase Inheritance object CurseForgeBase Modpacks Inherited Members CurseForgeBase.GetDownloadUrl(string, string) CurseForgeBase.GetDownloadUrlAsync(string, string) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors Modpacks(string) public Modpacks(string ApiKey) Parameters ApiKey string Methods GetModInfoAsync(string) 异步获取指定Modpack的详细信息 public Task<CurseForgeBase.CurseForgeInfo> GetModInfoAsync(string ModpackId) Parameters ModpackId string ModId Returns Task<CurseForgeBase.CurseForgeInfo> Mod信息 Exceptions ArgumentNullException Exception GetRecommendModpacks(string?[], int?[], string[]?, int?, int?, int?) 获取推荐的Modpack列表 public Task<List<CurseForgeBase.CurseForgeSearchResult>> GetRecommendModpacks(string?[] GameVersions, int?[] Categories, string[]? ModLoaderTypes, int? SortField = 0, int? Page = 1, int? PageSize = 25) Parameters GameVersions string[] 游戏版本 Categories int?[] 分类 ModLoaderTypes string[] 模组加载器 SortField int? 排序方式 Page int? 页数 PageSize int? 页面大小 Returns Task<List<CurseForgeBase.CurseForgeSearchResult>> 结果 SearchAsync(string, string?[], int?[], string[]?, int?, int?, int?) 异步搜索CurseForge上的Modpack public Task<List<CurseForgeBase.CurseForgeSearchResult>> SearchAsync(string SearchFilter, string?[] GameVersions, int?[] Categories, string[]? ModLoaderTypes, int? SortField = 0, int? Page = 1, int? PageSize = 25) Parameters SearchFilter string 搜索关键词 GameVersions string[] 游戏版本 Categories int?[] 分类标签 ModLoaderTypes string[] ModLoader类型 SortField int? 排序方式 Page int? 页数 PageSize int? 单页搜索结果条目数 Returns Task<List<CurseForgeBase.CurseForgeSearchResult>> Exceptions ArgumentOutOfRangeException Exception"
  },
  "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge.Mods.Category.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge.Mods.Category.html",
    "title": "Enum Mods.Category | Qomicex.Core API文档",
    "summary": "Enum Mods.Category Namespace Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge Assembly Qomicex.Core.dll public enum Mods.Category Fields Addons = 426 AdventureAndRpg = 422 ApiAndLibrary = 421 AppliedEnergistics2 = 4545 ArmorAndToolsAndAndWeapons = 434 Automation = 4843 Biomes = 407 BloodMagic = 4485 BugFixes = 6821 Buildcraft = 432 Cosmetic = 424 CraftTweaker = 4773 Create = 6484 Dimensions = 410 Education = 5299 Energy = 417 EnergyAndFluidAndAndItemTransport = 415 Farming = 416 Food = 436 Forestry = 433 Galacticraft = 5232 Genetics = 418 IndustrialCraft = 429 IntegratedDynamics = 6954 Kubejs = 5314 Magic = 419 MapAndInformation = 423 Mcreator = 4906 Miscellaneous = 425 Mobs = 411 OresAndResources = 408 Performance = 6814 PlayerTransport = 414 Processing = 413 Redstone = 4558 ServerUtility = 435 Skyblock = 6145 Storage = 420 Structures = 409 Technology = 412 ThaumCraft = 430 ThermalExpansion = 427 TinkersConstruct = 428 TwilightForest = 7669 TwitchIntegration = 4671 UtilityAndQol = 5191 WorldGen = 406"
  },
  "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge.Mods.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge.Mods.html",
    "title": "Class Mods | Qomicex.Core API文档",
    "summary": "Class Mods Namespace Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge Assembly Qomicex.Core.dll public class Mods : CurseForgeBase Inheritance object CurseForgeBase Mods Inherited Members CurseForgeBase.GetDownloadUrl(string, string) CurseForgeBase.GetDownloadUrlAsync(string, string) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors Mods(string) public Mods(string ApiKey) Parameters ApiKey string Methods GetModInfoAsync(string) 异步获取指定Mod的详细信息 public Task<CurseForgeBase.CurseForgeInfo> GetModInfoAsync(string ModId) Parameters ModId string ModId Returns Task<CurseForgeBase.CurseForgeInfo> Mod信息 Exceptions ArgumentNullException Exception GetRecommendMods(string?[], int?[], string[]?, int?, int?, int?) 获取推荐的Mod列表 public Task<List<CurseForgeBase.CurseForgeSearchResult>> GetRecommendMods(string?[] GameVersions, int?[] Categories, string[]? ModLoaderTypes, int? SortField = 0, int? Page = 1, int? PageSize = 25) Parameters GameVersions string[] 游戏版本 Categories int?[] 分类 ModLoaderTypes string[] 模组加载器 SortField int? 排序方式 Page int? 页数 PageSize int? 页面大小 Returns Task<List<CurseForgeBase.CurseForgeSearchResult>> 结果 SearchAsync(string, string?[], int?[], string[]?, int?, int?, int?) 异步搜索CurseForge上的Mod public Task<List<CurseForgeBase.CurseForgeSearchResult>> SearchAsync(string SearchFilter, string?[] GameVersions, int?[] Categories, string[]? ModLoaderTypes, int? SortField = 0, int? Page = 1, int? PageSize = 25) Parameters SearchFilter string 搜索关键词 GameVersions string[] 游戏版本 Categories int?[] 分类标签 ModLoaderTypes string[] ModLoader类型 SortField int? 排序方式 Page int? 页数 PageSize int? 单页搜索结果条目数 Returns Task<List<CurseForgeBase.CurseForgeSearchResult>> Exceptions ArgumentOutOfRangeException Exception"
  },
  "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge.ResourcePacks.Category.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge.ResourcePacks.Category.html",
    "title": "Enum ResourcePacks.Category | Qomicex.Core API文档",
    "summary": "Enum ResourcePacks.Category Namespace Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge Assembly Qomicex.Core.dll public enum ResourcePacks.Category Fields Animated = 404 DataPacks = 5193 FontPacks = 5244 Medieval = 402 Miscellaneous = 405 ModSupport = 4465 Modern = 401 PhotoRealistic = 400 Steampunk = 399 Traditional = 403 x128 = 396 x16 = 393 x256 = 397 x32 = 394 x512AndHigher = 398 x64 = 395"
  },
  "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge.ResourcePacks.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge.ResourcePacks.html",
    "title": "Class ResourcePacks | Qomicex.Core API文档",
    "summary": "Class ResourcePacks Namespace Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge Assembly Qomicex.Core.dll public class ResourcePacks : CurseForgeBase Inheritance object CurseForgeBase ResourcePacks Inherited Members CurseForgeBase.GetDownloadUrl(string, string) CurseForgeBase.GetDownloadUrlAsync(string, string) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ResourcePacks(string) public ResourcePacks(string ApiKey) Parameters ApiKey string Methods GetModInfoAsync(string) 异步获取指定ResourcePack的详细信息 public Task<CurseForgeBase.CurseForgeInfo> GetModInfoAsync(string Id) Parameters Id string ResourcePackId Returns Task<CurseForgeBase.CurseForgeInfo> ResourcePack信息 Exceptions ArgumentNullException Exception GetRecommendResourcePacks(string?[], int?[], int?, int?, int?) 获取推荐的ResourcePacks列表 public Task<List<CurseForgeBase.CurseForgeSearchResult>> GetRecommendResourcePacks(string?[] GameVersions, int?[] Categories, int? SortField = 0, int? Page = 1, int? PageSize = 25) Parameters GameVersions string[] 游戏版本 Categories int?[] 分类 SortField int? 排序方式 Page int? 页数 PageSize int? 页面大小 Returns Task<List<CurseForgeBase.CurseForgeSearchResult>> 结果 SearchAsync(string, string?[], int?[], int?, int?, int?) 异步搜索CurseForge上的ResourcePacks public Task<List<CurseForgeBase.CurseForgeSearchResult>> SearchAsync(string SearchFilter, string?[] GameVersions, int?[] Categories, int? SortField = 0, int? Page = 1, int? PageSize = 25) Parameters SearchFilter string 搜索关键词 GameVersions string[] 游戏版本 Categories int?[] 分类标签 SortField int? 排序方式 Page int? 页数 PageSize int? 单页搜索结果条目数 Returns Task<List<CurseForgeBase.CurseForgeSearchResult>> Exceptions ArgumentOutOfRangeException Exception"
  },
  "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge.Shaders.Category.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge.Shaders.Category.html",
    "title": "Enum Shaders.Category | Qomicex.Core API文档",
    "summary": "Enum Shaders.Category Namespace Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge Assembly Qomicex.Core.dll public enum Shaders.Category Fields Fantasy = 6554 Realistic = 6553 Vanilla = 6555"
  },
  "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge.Shaders.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge.Shaders.html",
    "title": "Class Shaders | Qomicex.Core API文档",
    "summary": "Class Shaders Namespace Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge Assembly Qomicex.Core.dll public class Shaders : CurseForgeBase Inheritance object CurseForgeBase Shaders Inherited Members CurseForgeBase.GetDownloadUrl(string, string) CurseForgeBase.GetDownloadUrlAsync(string, string) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors Shaders(string) public Shaders(string ApiKey) Parameters ApiKey string Methods GetModInfoAsync(string) 异步获取指定Shaders的详细信息 public Task<CurseForgeBase.CurseForgeInfo> GetModInfoAsync(string Id) Parameters Id string ModId Returns Task<CurseForgeBase.CurseForgeInfo> Shaders信息 Exceptions ArgumentNullException Exception GetRecommendShaders(string?[], int?[], int?, int?, int?) 获取推荐的Shaders列表 public Task<List<CurseForgeBase.CurseForgeSearchResult>> GetRecommendShaders(string?[] GameVersions, int?[] Categories, int? SortField = 0, int? Page = 1, int? PageSize = 25) Parameters GameVersions string[] 游戏版本 Categories int?[] 分类 SortField int? 排序方式 Page int? 页数 PageSize int? 页面大小 Returns Task<List<CurseForgeBase.CurseForgeSearchResult>> 结果 SearchAsync(string, string?[], int?[], int?, int?, int?) 异步搜索CurseForge上的Shaders public Task<List<CurseForgeBase.CurseForgeSearchResult>> SearchAsync(string SearchFilter, string?[] GameVersions, int?[] Categories, int? SortField = 0, int? Page = 1, int? PageSize = 25) Parameters SearchFilter string 搜索关键词 GameVersions string[] 游戏版本 Categories int?[] 分类标签 SortField int? 排序方式 Page int? 页数 PageSize int? 单页搜索结果条目数 Returns Task<List<CurseForgeBase.CurseForgeSearchResult>> Exceptions ArgumentOutOfRangeException Exception"
  },
  "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge.Worlds.Category.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge.Worlds.Category.html",
    "title": "Enum Worlds.Category | Qomicex.Core API文档",
    "summary": "Enum Worlds.Category Namespace Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge Assembly Qomicex.Core.dll public enum Worlds.Category Fields Adventure = 248 Creation = 249 GameMap = 250 ModdedWorld = 4464 Parkour = 251 Puzzle = 252 Survival = 253"
  },
  "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge.Worlds.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge.Worlds.html",
    "title": "Class Worlds | Qomicex.Core API文档",
    "summary": "Class Worlds Namespace Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge Assembly Qomicex.Core.dll public class Worlds : CurseForgeBase Inheritance object CurseForgeBase Worlds Inherited Members CurseForgeBase.GetDownloadUrl(string, string) CurseForgeBase.GetDownloadUrlAsync(string, string) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors Worlds(string) public Worlds(string ApiKey) Parameters ApiKey string Methods GetModInfoAsync(string) 异步获取指定World的详细信息 public Task<CurseForgeBase.CurseForgeInfo> GetModInfoAsync(string Id) Parameters Id string ModId Returns Task<CurseForgeBase.CurseForgeInfo> World信息 Exceptions ArgumentNullException Exception GetRecommendWorlds(string?[], int?[], int?, int?, int?) 获取推荐的World列表 public Task<List<CurseForgeBase.CurseForgeSearchResult>> GetRecommendWorlds(string?[] GameVersions, int?[] Categories, int? SortField = 0, int? Page = 1, int? PageSize = 25) Parameters GameVersions string[] 游戏版本 Categories int?[] 分类 SortField int? 排序方式 Page int? 页数 PageSize int? 页面大小 Returns Task<List<CurseForgeBase.CurseForgeSearchResult>> 结果 SearchAsync(string, string?[], int?[], int?, int?, int?) 异步搜索CurseForge上的World public Task<List<CurseForgeBase.CurseForgeSearchResult>> SearchAsync(string SearchFilter, string?[] GameVersions, int?[] Categories, int? SortField = 0, int? Page = 1, int? PageSize = 25) Parameters SearchFilter string 搜索关键词 GameVersions string[] 游戏版本 Categories int?[] 分类标签 SortField int? 排序方式 Page int? 页数 PageSize int? 单页搜索结果条目数 Returns Task<List<CurseForgeBase.CurseForgeSearchResult>> Exceptions ArgumentOutOfRangeException Exception"
  },
  "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge.html",
    "title": "Namespace Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge | Qomicex.Core API文档",
    "summary": "Namespace Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge Classes CurseForgeBase CurseForgeBase.AuthorMeta CurseForgeBase.CategoryMeta CurseForgeBase.CurseForgeDependenciesMeta CurseForgeBase.CurseForgeFilesMeta CurseForgeBase.CurseForgeInfo CurseForgeBase.CurseForgeSearchResult CurseForgeBase.ModLoaderType CurseForgeBase.ScreenshotsMeta DataPacks Modpacks Mods ResourcePacks Shaders Worlds Enums CurseForgeBase.SortField DataPacks.Category Modpacks.Category Mods.Category ResourcePacks.Category Shaders.Category Worlds.Category"
  },
  "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth.DataPacks.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth.DataPacks.html",
    "title": "Class DataPacks | Qomicex.Core API文档",
    "summary": "Class DataPacks Namespace Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth Assembly Qomicex.Core.dll public class DataPacks : ModrinthSourceBase, IModrinthSource Inheritance object ModrinthBase ModrinthSourceBase DataPacks Implements IModrinthSource Inherited Members ModrinthSourceBase.SearchAsync(string, string, string[], string[], string, int, int) ModrinthSourceBase.GetProjectInfoAsync(string) ModrinthSourceBase.GetProjectVersionInfoAsync(string) ModrinthSourceBase.GetVersionInfoAsync(string) ModrinthBase.GetCategoriesAsync() ModrinthBase.GetLoadersAsync() ModrinthBase.GetProjectTypesAsync() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties ProjectType protected override string ProjectType { get; } Property Value string"
  },
  "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth.IModrinthSource.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth.IModrinthSource.html",
    "title": "Interface IModrinthSource | Qomicex.Core API文档",
    "summary": "Interface IModrinthSource Namespace Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth Assembly Qomicex.Core.dll public interface IModrinthSource Methods GetProjectInfoAsync(string) Task<ModrinthBase.ProjectInfo> GetProjectInfoAsync(string projectId) Parameters projectId string Returns Task<ModrinthBase.ProjectInfo> GetProjectVersionInfoAsync(string) Task<List<ModrinthBase.ProjectVersionInfo>> GetProjectVersionInfoAsync(string projectId) Parameters projectId string Returns Task<List<ModrinthBase.ProjectVersionInfo>> GetVersionInfoAsync(string) Task<ModrinthBase.VersionInfo> GetVersionInfoAsync(string versionId) Parameters versionId string Returns Task<ModrinthBase.VersionInfo> SearchAsync(string, string, string[]?, string[]?, string, int, int) Task<ModrinthBase.SearchResult> SearchAsync(string searchFilter, string gameVersion, string[]? categories = null, string[]? loaders = null, string index = \"relevance\", int page = 0, int pageSize = 20) Parameters searchFilter string gameVersion string categories string[] loaders string[] index string page int pageSize int Returns Task<ModrinthBase.SearchResult>"
  },
  "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth.Modpacks.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth.Modpacks.html",
    "title": "Class Modpacks | Qomicex.Core API文档",
    "summary": "Class Modpacks Namespace Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth Assembly Qomicex.Core.dll public class Modpacks : ModrinthSourceBase, IModrinthSource Inheritance object ModrinthBase ModrinthSourceBase Modpacks Implements IModrinthSource Inherited Members ModrinthSourceBase.SearchAsync(string, string, string[], string[], string, int, int) ModrinthSourceBase.GetProjectInfoAsync(string) ModrinthSourceBase.GetProjectVersionInfoAsync(string) ModrinthSourceBase.GetVersionInfoAsync(string) ModrinthBase.GetCategoriesAsync() ModrinthBase.GetLoadersAsync() ModrinthBase.GetProjectTypesAsync() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties ProjectType protected override string ProjectType { get; } Property Value string"
  },
  "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth.ModrinthBase.DependenciesInfo.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth.ModrinthBase.DependenciesInfo.html",
    "title": "Class ModrinthBase.DependenciesInfo | Qomicex.Core API文档",
    "summary": "Class ModrinthBase.DependenciesInfo Namespace Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth Assembly Qomicex.Core.dll public class ModrinthBase.DependenciesInfo Inheritance object ModrinthBase.DependenciesInfo Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties DependencyType [JsonProperty(\"dependency_type\")] public string DependencyType { get; set; } Property Value string FileName [JsonProperty(\"file_name\")] public string FileName { get; set; } Property Value string ProjectId [JsonProperty(\"project_id\")] public string ProjectId { get; set; } Property Value string VersionId [JsonProperty(\"version_id\")] public string VersionId { get; set; } Property Value string"
  },
  "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth.ModrinthBase.FileHashes.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth.ModrinthBase.FileHashes.html",
    "title": "Class ModrinthBase.FileHashes | Qomicex.Core API文档",
    "summary": "Class ModrinthBase.FileHashes Namespace Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth Assembly Qomicex.Core.dll public class ModrinthBase.FileHashes Inheritance object ModrinthBase.FileHashes Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Sha1 [JsonProperty(\"sha1\")] public string Sha1 { get; set; } Property Value string Sha512 [JsonProperty(\"sha512\")] public string Sha512 { get; set; } Property Value string"
  },
  "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth.ModrinthBase.GalleryItem.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth.ModrinthBase.GalleryItem.html",
    "title": "Class ModrinthBase.GalleryItem | Qomicex.Core API文档",
    "summary": "Class ModrinthBase.GalleryItem Namespace Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth Assembly Qomicex.Core.dll 表示Modrinth项目画廊中的单个图片项 public class ModrinthBase.GalleryItem Inheritance object ModrinthBase.GalleryItem Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Created 画廊图片的创建日期和时间（必填，ISO-8601格式） [JsonProperty(\"created\", Required = Required.Always)] public DateTime Created { get; set; } Property Value DateTime Description 画廊图片的描述（可选，可为null） [JsonProperty(\"description\")] public string? Description { get; set; } Property Value string Featured 图片是否在画廊中被标记为精选（必填） [JsonProperty(\"featured\", Required = Required.Always)] public bool Featured { get; set; } Property Value bool Ordering 画廊图片的排序序号。画廊图片将按此字段排序，然后按标题字母顺序排序 [JsonProperty(\"ordering\")] public int? Ordering { get; set; } Property Value int? Title 画廊图片的标题（可选，可为null） [JsonProperty(\"title\")] public string? Title { get; set; } Property Value string Url 画廊图片的URL（必填） [JsonProperty(\"url\", Required = Required.Always)] public string? Url { get; set; } Property Value string"
  },
  "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth.ModrinthBase.Index.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth.ModrinthBase.Index.html",
    "title": "Class ModrinthBase.Index | Qomicex.Core API文档",
    "summary": "Class ModrinthBase.Index Namespace Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth Assembly Qomicex.Core.dll public class ModrinthBase.Index Inheritance object ModrinthBase.Index Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields Downloads public const string Downloads = \"downloads\" Field Value string Follows public const string Follows = \"follows\" Field Value string Newest public const string Newest = \"newest\" Field Value string Relevance public const string Relevance = \"relevance\" Field Value string Updated public const string Updated = \"updated\" Field Value string"
  },
  "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth.ModrinthBase.ModLoaderType.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth.ModrinthBase.ModLoaderType.html",
    "title": "Enum ModrinthBase.ModLoaderType | Qomicex.Core API文档",
    "summary": "Enum ModrinthBase.ModLoaderType Namespace Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth Assembly Qomicex.Core.dll [JsonConverter(typeof(StringEnumConverter))] public enum ModrinthBase.ModLoaderType Fields fabric = 2 forge = 1 liteLoader = 6 minecraft = 0 modLoader = 7 neoForge = 4 nilloader = 8 ornithe = 9 quilt = 3 rift = 5"
  },
  "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth.ModrinthBase.ModrinthTag.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth.ModrinthBase.ModrinthTag.html",
    "title": "Class ModrinthBase.ModrinthTag | Qomicex.Core API文档",
    "summary": "Class ModrinthBase.ModrinthTag Namespace Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth Assembly Qomicex.Core.dll public class ModrinthBase.ModrinthTag Inheritance object ModrinthBase.ModrinthTag Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Description [JsonProperty(\"description\")] public string Description { get; set; } Property Value string Icon [JsonProperty(\"icon\")] public string Icon { get; set; } Property Value string IsChecked [JsonProperty(\"checked\")] public bool IsChecked { get; set; } Property Value bool Name [JsonProperty(\"name\")] public string Name { get; set; } Property Value string StringValue public string StringValue { get; set; } Property Value string"
  },
  "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth.ModrinthBase.ProjectInfo.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth.ModrinthBase.ProjectInfo.html",
    "title": "Class ModrinthBase.ProjectInfo | Qomicex.Core API文档",
    "summary": "Class ModrinthBase.ProjectInfo Namespace Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth Assembly Qomicex.Core.dll public class ModrinthBase.ProjectInfo Inheritance object ModrinthBase.ProjectInfo Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties AdditionalCategories [JsonProperty(\"additional_categories\")] public List<string> AdditionalCategories { get; set; } Property Value List<string> ApprovedAt [JsonProperty(\"approved\")] public DateTime ApprovedAt { get; set; } Property Value DateTime Categories [JsonProperty(\"categories\")] public List<string> Categories { get; set; } Property Value List<string> ClientSide [JsonProperty(\"client_side\")] public string ClientSide { get; set; } Property Value string Description [JsonProperty(\"description\")] public string Description { get; set; } Property Value string DiscordUrl [JsonProperty(\"discord_url\")] public string DiscordUrl { get; set; } Property Value string DownloadCount [JsonProperty(\"downloads\")] public int DownloadCount { get; set; } Property Value int FollowCount [JsonProperty(\"followers\")] public int FollowCount { get; set; } Property Value int FullDescription [JsonProperty(\"body\")] public string FullDescription { get; set; } Property Value string Gallery [JsonProperty(\"gallery\")] public List<ModrinthBase.GalleryItem> Gallery { get; set; } Property Value List<ModrinthBase.GalleryItem> GameVersionIds [JsonProperty(\"game_versions\")] public List<string> GameVersionIds { get; set; } Property Value List<string> IconUrl [JsonProperty(\"icon_url\")] public string IconUrl { get; set; } Property Value string Id [JsonProperty(\"id\")] public string Id { get; set; } Property Value string IssuesUrl [JsonProperty(\"issues_url\")] public string IssuesUrl { get; set; } Property Value string Loaders [JsonProperty(\"loaders\")] public List<string> Loaders { get; set; } Property Value List<string> Name [JsonProperty(\"title\")] public string Name { get; set; } Property Value string Organization [JsonProperty(\"organization\")] public string Organization { get; set; } Property Value string PublishAt [JsonProperty(\"published\")] public DateTime PublishAt { get; set; } Property Value DateTime ServerSide [JsonProperty(\"server_side\")] public string ServerSide { get; set; } Property Value string Slug [JsonProperty(\"slug\")] public string Slug { get; set; } Property Value string SourceUrl [JsonProperty(\"source_url\")] public string SourceUrl { get; set; } Property Value string Team [JsonProperty(\"team\")] public string Team { get; set; } Property Value string Type [JsonProperty(\"project_type\")] public string Type { get; set; } Property Value string UpdatedAt [JsonProperty(\"updated\")] public DateTime UpdatedAt { get; set; } Property Value DateTime Versions [JsonProperty(\"versions\")] public List<string> Versions { get; set; } Property Value List<string> WikiUrl [JsonProperty(\"wiki_url\")] public string WikiUrl { get; set; } Property Value string"
  },
  "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth.ModrinthBase.ProjectType.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth.ModrinthBase.ProjectType.html",
    "title": "Class ModrinthBase.ProjectType | Qomicex.Core API文档",
    "summary": "Class ModrinthBase.ProjectType Namespace Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth Assembly Qomicex.Core.dll public static class ModrinthBase.ProjectType Inheritance object ModrinthBase.ProjectType Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields Datapack public const string Datapack = \"datapack\" Field Value string Mod public const string Mod = \"mod\" Field Value string Modpack public const string Modpack = \"modpack\" Field Value string ResourcePack public const string ResourcePack = \"resourcepack\" Field Value string Shader public const string Shader = \"shader\" Field Value string"
  },
  "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth.ModrinthBase.ProjectVersionInfo.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth.ModrinthBase.ProjectVersionInfo.html",
    "title": "Class ModrinthBase.ProjectVersionInfo | Qomicex.Core API文档",
    "summary": "Class ModrinthBase.ProjectVersionInfo Namespace Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth Assembly Qomicex.Core.dll public class ModrinthBase.ProjectVersionInfo Inheritance object ModrinthBase.ProjectVersionInfo Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Changelog [JsonProperty(\"changelog\")] public string Changelog { get; set; } Property Value string DependenciesInfos [JsonProperty(\"dependencies\")] public List<ModrinthBase.DependenciesInfo> DependenciesInfos { get; set; } Property Value List<ModrinthBase.DependenciesInfo> DownloadCount [JsonProperty(\"downloads\")] public int DownloadCount { get; set; } Property Value int Files [JsonProperty(\"files\")] public List<ModrinthBase.VersionFileInfo> Files { get; set; } Property Value List<ModrinthBase.VersionFileInfo> GameVersionIds [JsonProperty(\"game_versions\")] public List<string> GameVersionIds { get; set; } Property Value List<string> Id [JsonProperty(\"id\")] public string Id { get; set; } Property Value string Loaders [JsonProperty(\"loaders\")] public List<string> Loaders { get; set; } Property Value List<string> Name [JsonProperty(\"name\")] public string Name { get; set; } Property Value string ProjectId [JsonProperty(\"project_id\")] public string ProjectId { get; set; } Property Value string PublishedAt [JsonProperty(\"date_published\")] public DateTime PublishedAt { get; set; } Property Value DateTime VersionNumber [JsonProperty(\"version_number\")] public string VersionNumber { get; set; } Property Value string VersionType [JsonProperty(\"version_type\")] public string VersionType { get; set; } Property Value string"
  },
  "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth.ModrinthBase.SearchResult.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth.ModrinthBase.SearchResult.html",
    "title": "Class ModrinthBase.SearchResult | Qomicex.Core API文档",
    "summary": "Class ModrinthBase.SearchResult Namespace Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth Assembly Qomicex.Core.dll public class ModrinthBase.SearchResult Inheritance object ModrinthBase.SearchResult Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Results [JsonProperty(\"hits\")] public List<ModrinthBase.SearchResultInfo> Results { get; set; } Property Value List<ModrinthBase.SearchResultInfo> TotalResults [JsonProperty(\"total_hits\")] public int TotalResults { get; set; } Property Value int"
  },
  "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth.ModrinthBase.SearchResultInfo.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth.ModrinthBase.SearchResultInfo.html",
    "title": "Class ModrinthBase.SearchResultInfo | Qomicex.Core API文档",
    "summary": "Class ModrinthBase.SearchResultInfo Namespace Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth Assembly Qomicex.Core.dll public class ModrinthBase.SearchResultInfo Inheritance object ModrinthBase.SearchResultInfo Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Author [JsonProperty(\"author\")] public string Author { get; set; } Property Value string Categories [JsonProperty(\"categories\")] public List<string> Categories { get; set; } Property Value List<string> ClientSide [JsonProperty(\"client_side\")] public string ClientSide { get; set; } Property Value string CreatedAt [JsonProperty(\"date_created\")] public DateTime CreatedAt { get; set; } Property Value DateTime Description [JsonProperty(\"description\")] public string Description { get; set; } Property Value string DownloadCount [JsonProperty(\"downloads\")] public int DownloadCount { get; set; } Property Value int FollowCount [JsonProperty(\"follows\")] public int FollowCount { get; set; } Property Value int FullDescription [JsonProperty(\"body\")] public string FullDescription { get; set; } Property Value string GalleryUrls [JsonProperty(\"gallery\")] public List<string> GalleryUrls { get; set; } Property Value List<string> IconUrl [JsonProperty(\"icon_url\")] public string IconUrl { get; set; } Property Value string Id [JsonProperty(\"project_id\")] public string Id { get; set; } Property Value string License [JsonProperty(\"license\")] public string License { get; set; } Property Value string Name [JsonProperty(\"title\")] public string Name { get; set; } Property Value string ServerSide [JsonProperty(\"server_side\")] public string ServerSide { get; set; } Property Value string Slug [JsonProperty(\"slug\")] public string Slug { get; set; } Property Value string Tags [JsonProperty(\"tags\")] public List<string> Tags { get; set; } Property Value List<string> Type [JsonProperty(\"project_type\")] public string Type { get; set; } Property Value string UpdatedAt [JsonProperty(\"date_modified\")] public DateTime UpdatedAt { get; set; } Property Value DateTime VersionIds [JsonProperty(\"versions\")] public List<string> VersionIds { get; set; } Property Value List<string>"
  },
  "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth.ModrinthBase.SupportType.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth.ModrinthBase.SupportType.html",
    "title": "Class ModrinthBase.SupportType | Qomicex.Core API文档",
    "summary": "Class ModrinthBase.SupportType Namespace Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth Assembly Qomicex.Core.dll public static class ModrinthBase.SupportType Inheritance object ModrinthBase.SupportType Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields Optional public const string Optional = \"optional\" Field Value string Required public const string Required = \"required\" Field Value string Unsupported public const string Unsupported = \"unsupported\" Field Value string"
  },
  "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth.ModrinthBase.VersionFileInfo.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth.ModrinthBase.VersionFileInfo.html",
    "title": "Class ModrinthBase.VersionFileInfo | Qomicex.Core API文档",
    "summary": "Class ModrinthBase.VersionFileInfo Namespace Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth Assembly Qomicex.Core.dll public class ModrinthBase.VersionFileInfo Inheritance object ModrinthBase.VersionFileInfo Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties DownloadUrl [JsonProperty(\"url\")] public string DownloadUrl { get; set; } Property Value string FileType [JsonProperty(\"file_type\")] public string FileType { get; set; } Property Value string Filename [JsonProperty(\"filename\")] public string Filename { get; set; } Property Value string Hashes [JsonProperty(\"hashes\")] public ModrinthBase.FileHashes Hashes { get; set; } Property Value ModrinthBase.FileHashes IsPrimary [JsonProperty(\"primary\")] public bool IsPrimary { get; set; } Property Value bool Size [JsonProperty(\"size\")] public long Size { get; set; } Property Value long"
  },
  "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth.ModrinthBase.VersionInfo.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth.ModrinthBase.VersionInfo.html",
    "title": "Class ModrinthBase.VersionInfo | Qomicex.Core API文档",
    "summary": "Class ModrinthBase.VersionInfo Namespace Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth Assembly Qomicex.Core.dll public class ModrinthBase.VersionInfo Inheritance object ModrinthBase.VersionInfo Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties ApprovedAt [JsonProperty(\"approved\")] public DateTime ApprovedAt { get; set; } Property Value DateTime Changelog [JsonProperty(\"changelog\")] public string Changelog { get; set; } Property Value string DependenciesInfos [JsonProperty(\"dependencies\")] public List<ModrinthBase.DependenciesInfo> DependenciesInfos { get; set; } Property Value List<ModrinthBase.DependenciesInfo> DownloadCount [JsonProperty(\"downloads\")] public int DownloadCount { get; set; } Property Value int Files [JsonProperty(\"files\")] public List<ModrinthBase.VersionFileInfo> Files { get; set; } Property Value List<ModrinthBase.VersionFileInfo> GameVersionIds [JsonProperty(\"game_versions\")] public List<string> GameVersionIds { get; set; } Property Value List<string> IconUrl [JsonProperty(\"icon_url\")] public string IconUrl { get; set; } Property Value string Id [JsonProperty(\"id\")] public string Id { get; set; } Property Value string Loaders [JsonProperty(\"loaders\")] public List<string> Loaders { get; set; } Property Value List<string> Name [JsonProperty(\"title\")] public string Name { get; set; } Property Value string ProjectId [JsonProperty(\"project_id\")] public string ProjectId { get; set; } Property Value string PublishedAt [JsonProperty(\"published\")] public DateTime PublishedAt { get; set; } Property Value DateTime Slug [JsonProperty(\"slug\")] public string Slug { get; set; } Property Value string UpdatedAt [JsonProperty(\"updated\")] public DateTime UpdatedAt { get; set; } Property Value DateTime Versions [JsonProperty(\"versions\")] public List<string> Versions { get; set; } Property Value List<string>"
  },
  "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth.ModrinthBase.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth.ModrinthBase.html",
    "title": "Class ModrinthBase | Qomicex.Core API文档",
    "summary": "Class ModrinthBase Namespace Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth Assembly Qomicex.Core.dll public class ModrinthBase Inheritance object ModrinthBase Derived ModrinthSourceBase Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ModrinthBase() public ModrinthBase() Methods GetCategoriesAsync() public Task<List<ModrinthBase.ModrinthTag>> GetCategoriesAsync() Returns Task<List<ModrinthBase.ModrinthTag>> GetLoadersAsync() public Task<List<ModrinthBase.ModrinthTag>> GetLoadersAsync() Returns Task<List<ModrinthBase.ModrinthTag>> GetProjectTypesAsync() public Task<List<ModrinthBase.ModrinthTag>> GetProjectTypesAsync() Returns Task<List<ModrinthBase.ModrinthTag>>"
  },
  "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth.ModrinthSourceBase.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth.ModrinthSourceBase.html",
    "title": "Class ModrinthSourceBase | Qomicex.Core API文档",
    "summary": "Class ModrinthSourceBase Namespace Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth Assembly Qomicex.Core.dll public abstract class ModrinthSourceBase : ModrinthBase, IModrinthSource Inheritance object ModrinthBase ModrinthSourceBase Implements IModrinthSource Derived DataPacks Modpacks Mods ResourcePacks Shaders Worlds Inherited Members ModrinthBase.GetCategoriesAsync() ModrinthBase.GetLoadersAsync() ModrinthBase.GetProjectTypesAsync() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties ProjectType protected abstract string ProjectType { get; } Property Value string Methods GetProjectInfoAsync(string) public Task<ModrinthBase.ProjectInfo> GetProjectInfoAsync(string projectId) Parameters projectId string Returns Task<ModrinthBase.ProjectInfo> GetProjectVersionInfoAsync(string) public Task<List<ModrinthBase.ProjectVersionInfo>> GetProjectVersionInfoAsync(string projectId) Parameters projectId string Returns Task<List<ModrinthBase.ProjectVersionInfo>> GetVersionInfoAsync(string) public Task<ModrinthBase.VersionInfo> GetVersionInfoAsync(string versionId) Parameters versionId string Returns Task<ModrinthBase.VersionInfo> SearchAsync(string, string, string[]?, string[]?, string, int, int) public Task<ModrinthBase.SearchResult> SearchAsync(string searchFilter, string gameVersion, string[]? categories = null, string[]? loaders = null, string index = \"relevance\", int page = 0, int pageSize = 20) Parameters searchFilter string gameVersion string categories string[] loaders string[] index string page int pageSize int Returns Task<ModrinthBase.SearchResult>"
  },
  "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth.Mods.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth.Mods.html",
    "title": "Class Mods | Qomicex.Core API文档",
    "summary": "Class Mods Namespace Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth Assembly Qomicex.Core.dll public class Mods : ModrinthSourceBase, IModrinthSource Inheritance object ModrinthBase ModrinthSourceBase Mods Implements IModrinthSource Inherited Members ModrinthSourceBase.SearchAsync(string, string, string[], string[], string, int, int) ModrinthSourceBase.GetProjectInfoAsync(string) ModrinthSourceBase.GetProjectVersionInfoAsync(string) ModrinthSourceBase.GetVersionInfoAsync(string) ModrinthBase.GetCategoriesAsync() ModrinthBase.GetLoadersAsync() ModrinthBase.GetProjectTypesAsync() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties ProjectType protected override string ProjectType { get; } Property Value string"
  },
  "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth.ResourcePacks.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth.ResourcePacks.html",
    "title": "Class ResourcePacks | Qomicex.Core API文档",
    "summary": "Class ResourcePacks Namespace Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth Assembly Qomicex.Core.dll public class ResourcePacks : ModrinthSourceBase, IModrinthSource Inheritance object ModrinthBase ModrinthSourceBase ResourcePacks Implements IModrinthSource Inherited Members ModrinthSourceBase.SearchAsync(string, string, string[], string[], string, int, int) ModrinthSourceBase.GetProjectInfoAsync(string) ModrinthSourceBase.GetProjectVersionInfoAsync(string) ModrinthSourceBase.GetVersionInfoAsync(string) ModrinthBase.GetCategoriesAsync() ModrinthBase.GetLoadersAsync() ModrinthBase.GetProjectTypesAsync() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties ProjectType protected override string ProjectType { get; } Property Value string"
  },
  "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth.Shaders.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth.Shaders.html",
    "title": "Class Shaders | Qomicex.Core API文档",
    "summary": "Class Shaders Namespace Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth Assembly Qomicex.Core.dll public class Shaders : ModrinthSourceBase, IModrinthSource Inheritance object ModrinthBase ModrinthSourceBase Shaders Implements IModrinthSource Inherited Members ModrinthSourceBase.SearchAsync(string, string, string[], string[], string, int, int) ModrinthSourceBase.GetProjectInfoAsync(string) ModrinthSourceBase.GetProjectVersionInfoAsync(string) ModrinthSourceBase.GetVersionInfoAsync(string) ModrinthBase.GetCategoriesAsync() ModrinthBase.GetLoadersAsync() ModrinthBase.GetProjectTypesAsync() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties ProjectType protected override string ProjectType { get; } Property Value string"
  },
  "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth.Worlds.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth.Worlds.html",
    "title": "Class Worlds | Qomicex.Core API文档",
    "summary": "Class Worlds Namespace Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth Assembly Qomicex.Core.dll public class Worlds : ModrinthSourceBase, IModrinthSource Inheritance object ModrinthBase ModrinthSourceBase Worlds Implements IModrinthSource Inherited Members ModrinthSourceBase.SearchAsync(string, string, string[], string[], string, int, int) ModrinthSourceBase.GetProjectInfoAsync(string) ModrinthSourceBase.GetProjectVersionInfoAsync(string) ModrinthSourceBase.GetVersionInfoAsync(string) ModrinthBase.GetCategoriesAsync() ModrinthBase.GetLoadersAsync() ModrinthBase.GetProjectTypesAsync() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties ProjectType protected override string ProjectType { get; } Property Value string"
  },
  "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth.html",
    "title": "Namespace Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth | Qomicex.Core API文档",
    "summary": "Namespace Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth Classes DataPacks Modpacks ModrinthBase ModrinthBase.DependenciesInfo ModrinthBase.FileHashes ModrinthBase.GalleryItem 表示Modrinth项目画廊中的单个图片项 ModrinthBase.Index ModrinthBase.ModrinthTag ModrinthBase.ProjectInfo ModrinthBase.ProjectType ModrinthBase.ProjectVersionInfo ModrinthBase.SearchResult ModrinthBase.SearchResultInfo ModrinthBase.SupportType ModrinthBase.VersionFileInfo ModrinthBase.VersionInfo ModrinthSourceBase Mods ResourcePacks Shaders Worlds Interfaces IModrinthSource Enums ModrinthBase.ModLoaderType"
  },
  "api/Qomicex.Core.Modules.Helpers.Resources.GameResourceHelper.VersionInfo.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Resources.GameResourceHelper.VersionInfo.html",
    "title": "Class GameResourceHelper.VersionInfo | Qomicex.Core API文档",
    "summary": "Class GameResourceHelper.VersionInfo Namespace Qomicex.Core.Modules.Helpers.Resources Assembly Qomicex.Core.dll public class GameResourceHelper.VersionInfo Inheritance object GameResourceHelper.VersionInfo Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Id public string? Id { get; set; } Property Value string ReleaseTime public DateTime ReleaseTime { get; set; } Property Value DateTime Type public string? Type { get; set; } Property Value string Url public string? Url { get; set; } Property Value string"
  },
  "api/Qomicex.Core.Modules.Helpers.Resources.GameResourceHelper.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Resources.GameResourceHelper.html",
    "title": "Class GameResourceHelper | Qomicex.Core API文档",
    "summary": "Class GameResourceHelper Namespace Qomicex.Core.Modules.Helpers.Resources Assembly Qomicex.Core.dll public class GameResourceHelper Inheritance object GameResourceHelper Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors GameResourceHelper() public GameResourceHelper() Methods GetMinecraftListAsync(int) public Task<List<GameResourceHelper.VersionInfo>> GetMinecraftListAsync(int source = 1) Parameters source int Returns Task<List<GameResourceHelper.VersionInfo>> GetMinecraftVersionManifest(int) public Task<dynamic?> GetMinecraftVersionManifest(int DownloadScore = 1) Parameters DownloadScore int Returns Task<dynamic> ParseVersionList(dynamic) public List<GameResourceHelper.VersionInfo> ParseVersionList(dynamic versionManifest) Parameters versionManifest dynamic Returns List<GameResourceHelper.VersionInfo>"
  },
  "api/Qomicex.Core.Modules.Helpers.Resources.LocalResourceHelper.DownloadSource.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Resources.LocalResourceHelper.DownloadSource.html",
    "title": "Class LocalResourceHelper.DownloadSource | Qomicex.Core API文档",
    "summary": "Class LocalResourceHelper.DownloadSource Namespace Qomicex.Core.Modules.Helpers.Resources Assembly Qomicex.Core.dll public class LocalResourceHelper.DownloadSource Inheritance object LocalResourceHelper.DownloadSource Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields assetsIndexSource public string assetsIndexSource Field Value string assetsSource public string assetsSource Field Value string librariesSource public string librariesSource Field Value string mainJarSource public string mainJarSource Field Value string"
  },
  "api/Qomicex.Core.Modules.Helpers.Resources.LocalResourceHelper.DownloadSources.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Resources.LocalResourceHelper.DownloadSources.html",
    "title": "Enum LocalResourceHelper.DownloadSources | Qomicex.Core API文档",
    "summary": "Enum LocalResourceHelper.DownloadSources Namespace Qomicex.Core.Modules.Helpers.Resources Assembly Qomicex.Core.dll public enum LocalResourceHelper.DownloadSources Fields BMCLAPI = 1 Mojang = 0"
  },
  "api/Qomicex.Core.Modules.Helpers.Resources.LocalResourceHelper.LibInfo.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Resources.LocalResourceHelper.LibInfo.html",
    "title": "Class LocalResourceHelper.LibInfo | Qomicex.Core API文档",
    "summary": "Class LocalResourceHelper.LibInfo Namespace Qomicex.Core.Modules.Helpers.Resources Assembly Qomicex.Core.dll public class LocalResourceHelper.LibInfo Inheritance object LocalResourceHelper.LibInfo Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields Hash public string Hash Field Value string IsCpLib public bool IsCpLib Field Value bool IsNativesLib public bool IsNativesLib Field Value bool Url public string Url Field Value string Properties FullName public string FullName { get; set; } Property Value string Name public string Name { get; set; } Property Value string Path public string Path { get; set; } Property Value string Version public string Version { get; } Property Value string Methods NameExists(string) public bool NameExists(string Name) Parameters Name string Returns bool PathExists(string) public bool PathExists(string Path) Parameters Path string Returns bool"
  },
  "api/Qomicex.Core.Modules.Helpers.Resources.LocalResourceHelper.MissFileData.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Resources.LocalResourceHelper.MissFileData.html",
    "title": "Class LocalResourceHelper.MissFileData | Qomicex.Core API文档",
    "summary": "Class LocalResourceHelper.MissFileData Namespace Qomicex.Core.Modules.Helpers.Resources Assembly Qomicex.Core.dll public class LocalResourceHelper.MissFileData Inheritance object LocalResourceHelper.MissFileData Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields Name public string Name Field Value string Path public string Path Field Value string Sha1 public string Sha1 Field Value string Url public string Url Field Value string"
  },
  "api/Qomicex.Core.Modules.Helpers.Resources.LocalResourceHelper.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Resources.LocalResourceHelper.html",
    "title": "Class LocalResourceHelper | Qomicex.Core API文档",
    "summary": "Class LocalResourceHelper Namespace Qomicex.Core.Modules.Helpers.Resources Assembly Qomicex.Core.dll public class LocalResourceHelper Inheritance object LocalResourceHelper Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods GetAllMissFilesAsync(string, string) public Task<List<LocalResourceHelper.MissFileData>> GetAllMissFilesAsync(string version, string gameDir) Parameters version string gameDir string Returns Task<List<LocalResourceHelper.MissFileData>> GetLibraries(string) public static List<LocalResourceHelper.LibInfo> GetLibraries(string jsonData) Parameters jsonData string Returns List<LocalResourceHelper.LibInfo> GetMissAssetsAsync(string, string) public Task<List<LocalResourceHelper.MissFileData>> GetMissAssetsAsync(string version, string gameDir) Parameters version string gameDir string Returns Task<List<LocalResourceHelper.MissFileData>> GetMissLibrariesAsync(string, string) public Task<List<LocalResourceHelper.MissFileData>> GetMissLibrariesAsync(string version, string gameDir) Parameters version string gameDir string Returns Task<List<LocalResourceHelper.MissFileData>> GetMissMainJarAsync(string, string) public Task<LocalResourceHelper.MissFileData?> GetMissMainJarAsync(string version, string gameDir) Parameters version string gameDir string Returns Task<LocalResourceHelper.MissFileData> MavenToPath(string) public static string MavenToPath(string maven) Parameters maven string Returns string SetDownloadSource(int) public void SetDownloadSource(int source) Parameters source int"
  },
  "api/Qomicex.Core.Modules.Helpers.Resources.ModLoaderResourceHelper.DownloadSource.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Resources.ModLoaderResourceHelper.DownloadSource.html",
    "title": "Class ModLoaderResourceHelper.DownloadSource | Qomicex.Core API文档",
    "summary": "Class ModLoaderResourceHelper.DownloadSource Namespace Qomicex.Core.Modules.Helpers.Resources Assembly Qomicex.Core.dll public class ModLoaderResourceHelper.DownloadSource Inheritance object ModLoaderResourceHelper.DownloadSource Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields assetsIndexSource public string assetsIndexSource Field Value string assetsSource public string assetsSource Field Value string librariesSource public string librariesSource Field Value string mainJarSource public string mainJarSource Field Value string"
  },
  "api/Qomicex.Core.Modules.Helpers.Resources.ModLoaderResourceHelper.DownloadSources.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Resources.ModLoaderResourceHelper.DownloadSources.html",
    "title": "Enum ModLoaderResourceHelper.DownloadSources | Qomicex.Core API文档",
    "summary": "Enum ModLoaderResourceHelper.DownloadSources Namespace Qomicex.Core.Modules.Helpers.Resources Assembly Qomicex.Core.dll public enum ModLoaderResourceHelper.DownloadSources Fields BMCLAPI = 1 Official = 0"
  },
  "api/Qomicex.Core.Modules.Helpers.Resources.ModLoaderResourceHelper.LiteloaderVersionInfo.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Resources.ModLoaderResourceHelper.LiteloaderVersionInfo.html",
    "title": "Class ModLoaderResourceHelper.LiteloaderVersionInfo | Qomicex.Core API文档",
    "summary": "Class ModLoaderResourceHelper.LiteloaderVersionInfo Namespace Qomicex.Core.Modules.Helpers.Resources Assembly Qomicex.Core.dll public class ModLoaderResourceHelper.LiteloaderVersionInfo Inheritance object ModLoaderResourceHelper.LiteloaderVersionInfo Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Hash [JsonProperty(\"hash\")] public string Hash { get; set; } Property Value string MinecraftVersion [JsonProperty(\"mcversion\")] public string MinecraftVersion { get; set; } Property Value string Type [JsonProperty(\"type\")] public string Type { get; set; } Property Value string Version [JsonProperty(\"version\")] public string Version { get; set; } Property Value string"
  },
  "api/Qomicex.Core.Modules.Helpers.Resources.ModLoaderResourceHelper.ModLoaderInfo.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Resources.ModLoaderResourceHelper.ModLoaderInfo.html",
    "title": "Class ModLoaderResourceHelper.ModLoaderInfo | Qomicex.Core API文档",
    "summary": "Class ModLoaderResourceHelper.ModLoaderInfo Namespace Qomicex.Core.Modules.Helpers.Resources Assembly Qomicex.Core.dll public class ModLoaderResourceHelper.ModLoaderInfo Inheritance object ModLoaderResourceHelper.ModLoaderInfo Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties DownloadUrl public string DownloadUrl { get; set; } Property Value string InstallerFileName public string InstallerFileName { get; } Property Value string IsRecommended public bool IsRecommended { get; set; } Property Value bool MinecraftVersion public string MinecraftVersion { get; set; } Property Value string Sha1 public string Sha1 { get; set; } Property Value string Type public ModLoaderResourceHelper.ModLoaderType Type { get; set; } Property Value ModLoaderResourceHelper.ModLoaderType Version public string Version { get; set; } Property Value string VersionJsonPath public string VersionJsonPath { get; } Property Value string"
  },
  "api/Qomicex.Core.Modules.Helpers.Resources.ModLoaderResourceHelper.ModLoaderType.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Resources.ModLoaderResourceHelper.ModLoaderType.html",
    "title": "Enum ModLoaderResourceHelper.ModLoaderType | Qomicex.Core API文档",
    "summary": "Enum ModLoaderResourceHelper.ModLoaderType Namespace Qomicex.Core.Modules.Helpers.Resources Assembly Qomicex.Core.dll public enum ModLoaderResourceHelper.ModLoaderType Fields All = 0 Fabric = 2 Forge = 1 LiteLoader = 5 NeoForge = 3 Optifine = 6 Quilt = 4"
  },
  "api/Qomicex.Core.Modules.Helpers.Resources.ModLoaderResourceHelper.NeoForgeVersionInfo.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Resources.ModLoaderResourceHelper.NeoForgeVersionInfo.html",
    "title": "Class ModLoaderResourceHelper.NeoForgeVersionInfo | Qomicex.Core API文档",
    "summary": "Class ModLoaderResourceHelper.NeoForgeVersionInfo Namespace Qomicex.Core.Modules.Helpers.Resources Assembly Qomicex.Core.dll NeoForge版本信息模型 public class ModLoaderResourceHelper.NeoForgeVersionInfo Inheritance object ModLoaderResourceHelper.NeoForgeVersionInfo Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties InstallerPath [JsonProperty(\"installerPath\")] public string InstallerPath { get; set; } Property Value string MinecraftVersion [JsonProperty(\"mcversion\")] public string MinecraftVersion { get; set; } Property Value string RawVersion [JsonProperty(\"rawVersion\")] public string RawVersion { get; set; } Property Value string Version [JsonProperty(\"version\")] public string Version { get; set; } Property Value string"
  },
  "api/Qomicex.Core.Modules.Helpers.Resources.ModLoaderResourceHelper.OptifineVersionInfo.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Resources.ModLoaderResourceHelper.OptifineVersionInfo.html",
    "title": "Class ModLoaderResourceHelper.OptifineVersionInfo | Qomicex.Core API文档",
    "summary": "Class ModLoaderResourceHelper.OptifineVersionInfo Namespace Qomicex.Core.Modules.Helpers.Resources Assembly Qomicex.Core.dll public class ModLoaderResourceHelper.OptifineVersionInfo Inheritance object ModLoaderResourceHelper.OptifineVersionInfo Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Filename [JsonProperty(\"filename\")] public string Filename { get; set; } Property Value string Forge [JsonProperty(\"forge\")] public string Forge { get; set; } Property Value string MinecraftVersion [JsonProperty(\"mcversion\")] public string MinecraftVersion { get; set; } Property Value string Patch [JsonProperty(\"patch\")] public string Patch { get; set; } Property Value string Type [JsonProperty(\"type\")] public string Type { get; set; } Property Value string"
  },
  "api/Qomicex.Core.Modules.Helpers.Resources.ModLoaderResourceHelper.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Resources.ModLoaderResourceHelper.html",
    "title": "Class ModLoaderResourceHelper | Qomicex.Core API文档",
    "summary": "Class ModLoaderResourceHelper Namespace Qomicex.Core.Modules.Helpers.Resources Assembly Qomicex.Core.dll public class ModLoaderResourceHelper Inheritance object ModLoaderResourceHelper Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ModLoaderResourceHelper(int) public ModLoaderResourceHelper(int downloadSourceId = 0) Parameters downloadSourceId int Methods GetAvailableModLoaders(string, ModLoaderType) public Task<List<ModLoaderResourceHelper.ModLoaderInfo>> GetAvailableModLoaders(string minecraftVersion, ModLoaderResourceHelper.ModLoaderType modLoaderType = ModLoaderType.All) Parameters minecraftVersion string modLoaderType ModLoaderResourceHelper.ModLoaderType Returns Task<List<ModLoaderResourceHelper.ModLoaderInfo>> SetDownloadSource(int) public ModLoaderResourceHelper.DownloadSource SetDownloadSource(int sourceId) Parameters sourceId int Returns ModLoaderResourceHelper.DownloadSource"
  },
  "api/Qomicex.Core.Modules.Helpers.Resources.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.Resources.html",
    "title": "Namespace Qomicex.Core.Modules.Helpers.Resources | Qomicex.Core API文档",
    "summary": "Namespace Qomicex.Core.Modules.Helpers.Resources Classes GameResourceHelper GameResourceHelper.VersionInfo LocalResourceHelper LocalResourceHelper.DownloadSource LocalResourceHelper.LibInfo LocalResourceHelper.MissFileData ModLoaderResourceHelper ModLoaderResourceHelper.DownloadSource ModLoaderResourceHelper.LiteloaderVersionInfo ModLoaderResourceHelper.ModLoaderInfo ModLoaderResourceHelper.NeoForgeVersionInfo NeoForge版本信息模型 ModLoaderResourceHelper.OptifineVersionInfo Enums LocalResourceHelper.DownloadSources ModLoaderResourceHelper.DownloadSources ModLoaderResourceHelper.ModLoaderType"
  },
  "api/Qomicex.Core.Modules.Helpers.SystemInfoHelper.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.SystemInfoHelper.html",
    "title": "Class SystemInfoHelper | Qomicex.Core API文档",
    "summary": "Class SystemInfoHelper Namespace Qomicex.Core.Modules.Helpers Assembly Qomicex.Core.dll public class SystemInfoHelper Inheritance object SystemInfoHelper Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties OsArch public static string OsArch { get; } Property Value string OsName public static string OsName { get; } Property Value string Separator public static string Separator { get; } Property Value string Methods GetSystemInfo() public static DataModules.SystemInfo GetSystemInfo() Returns DataModules.SystemInfo"
  },
  "api/Qomicex.Core.Modules.Helpers.html": {
    "href": "api/Qomicex.Core.Modules.Helpers.html",
    "title": "Namespace Qomicex.Core.Modules.Helpers | Qomicex.Core API文档",
    "summary": "Namespace Qomicex.Core.Modules.Helpers Classes AccountHelper GeneralHelper JavaHelper JavaHelper.JavaInfoExtended JavaHelper.JavaSearchOptions SystemInfoHelper Enums JavaHelper.JavaSearchMode JavaHelper.JavaState"
  },
  "api/Qomicex.Core.Modules.Launcher.Launcher.LauncherParam.html": {
    "href": "api/Qomicex.Core.Modules.Launcher.Launcher.LauncherParam.html",
    "title": "Class Launcher.LauncherParam | Qomicex.Core API文档",
    "summary": "Class Launcher.LauncherParam Namespace Qomicex.Core.Modules.Launcher Assembly Qomicex.Core.dll public class Launcher.LauncherParam : DataModules.DataDetails.Launcher Inheritance object DataModules.DataDetails.Launcher Launcher.LauncherParam Inherited Members DataModules.DataDetails.Launcher.Account DataModules.DataDetails.Launcher.DevideVersion DataModules.DataDetails.Launcher.AdditionalParam DataModules.DataDetails.Launcher.Version DataModules.DataDetails.Launcher.MaxMemory object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields FullScreen public bool FullScreen Field Value bool GameDir public string GameDir Field Value string Height public string Height Field Value string Java public DataModules.DataDetails.Java Java Field Value DataModules.DataDetails.Java LauncherName public string LauncherName Field Value string Width public string Width Field Value string"
  },
  "api/Qomicex.Core.Modules.Launcher.Launcher.LogLevels.html": {
    "href": "api/Qomicex.Core.Modules.Launcher.Launcher.LogLevels.html",
    "title": "Struct Launcher.LogLevels | Qomicex.Core API文档",
    "summary": "Struct Launcher.LogLevels Namespace Qomicex.Core.Modules.Launcher Assembly Qomicex.Core.dll public struct Launcher.LogLevels Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields DEBUG public const string DEBUG = \"DEBUG\" Field Value string ERROR public const string ERROR = \"ERROR\" Field Value string FATAL public const string FATAL = \"FATAL\" Field Value string INFO public const string INFO = \"INFO\" Field Value string WARN public const string WARN = \"WARN\" Field Value string"
  },
  "api/Qomicex.Core.Modules.Launcher.Launcher.html": {
    "href": "api/Qomicex.Core.Modules.Launcher.Launcher.html",
    "title": "Class Launcher | Qomicex.Core API文档",
    "summary": "Class Launcher Namespace Qomicex.Core.Modules.Launcher Assembly Qomicex.Core.dll public class Launcher Inheritance object Launcher Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods KillGame() public void KillGame() Launch(LauncherParam) public bool Launch(Launcher.LauncherParam param) Parameters param Launcher.LauncherParam Returns bool SelectParam(LauncherParam) public string SelectParam(Launcher.LauncherParam param) Parameters param Launcher.LauncherParam Returns string UnzipNatives(string, string, string) public bool UnzipNatives(string jsonPath, string minecraftPath, string versionPath) Parameters jsonPath string minecraftPath string versionPath string Returns bool Events OnCrashDetected public event Action<string>? OnCrashDetected Event Type Action<string> OnError public event Action<string>? OnError Event Type Action<string> OnExited public event Action<int>? OnExited Event Type Action<int> OnOutput public event Action<string>? OnOutput Event Type Action<string>"
  },
  "api/Qomicex.Core.Modules.Launcher.html": {
    "href": "api/Qomicex.Core.Modules.Launcher.html",
    "title": "Namespace Qomicex.Core.Modules.Launcher | Qomicex.Core API文档",
    "summary": "Namespace Qomicex.Core.Modules.Launcher Classes Launcher Launcher.LauncherParam Structs Launcher.LogLevels"
  },
  "api/Qomicex.Core.Tests.DebugLogAnalysisTest.html": {
    "href": "api/Qomicex.Core.Tests.DebugLogAnalysisTest.html",
    "title": "Class DebugLogAnalysisTest | Qomicex.Core API文档",
    "summary": "Class DebugLogAnalysisTest Namespace Qomicex.Core.Tests Assembly Qomicex.Core.dll 调试日志分析重复问题的测试 public class DebugLogAnalysisTest Inheritance object DebugLogAnalysisTest Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods AnalyzeWithDetails() public static Task AnalyzeWithDetails() Returns Task Truncate(string, int) public static string Truncate(string value, int maxLength) Parameters value string maxLength int Returns string"
  },
  "api/Qomicex.Core.Tests.html": {
    "href": "api/Qomicex.Core.Tests.html",
    "title": "Namespace Qomicex.Core.Tests | Qomicex.Core API文档",
    "summary": "Namespace Qomicex.Core.Tests Classes DebugLogAnalysisTest 调试日志分析重复问题的测试"
  },
  "api/Qomicex.Core.html": {
    "href": "api/Qomicex.Core.html",
    "title": "Namespace Qomicex.Core | Qomicex.Core API文档",
    "summary": "Namespace Qomicex.Core Classes Class1 DataModules DataModules.DataDetails DataModules.DataDetails.Account DataModules.DataDetails.Java DataModules.DataDetails.Launcher DataModules.DataDetails.Launcher.WindowSize DataModules.DataDetails.Version Structs DataModules.State DataModules.SystemInfo Enums DataModules.State.StateCode"
  },
  "docs/Account/README.html": {
    "href": "docs/Account/README.html",
    "title": "账户管理 | Qomicex.Core API文档",
    "summary": "账户管理 功能概述 Account 模块提供了 Minecraft 账户管理功能，包括 Microsoft 账户登录、Yggdrasil 认证和 Tongyi 账户支持。 使用示例 Microsoft 账户登录 using Qomicex.Core.Modules.Helpers.Account.Microsoft; // 创建 Microsoft 账户实例 var microsoftAccount = new Microsoft(); // 获取授权 URL string authUrl = microsoftAccount.GetAuthorizationUrl(); Console.WriteLine(\"请在浏览器中打开以下 URL 进行授权:\"); Console.WriteLine(authUrl); Console.WriteLine(\"授权完成后，请输入返回的代码:\"); string code = Console.ReadLine(); // 完成授权 try { var oauthResponse = await microsoftAccount.AuthorizeAsync(code); Console.WriteLine($\"访问令牌: {oauthResponse.AccessToken}\"); Console.WriteLine($\"刷新令牌: {oauthResponse.RefreshToken}\"); Console.WriteLine($\"过期时间: {oauthResponse.ExpiresIn} 秒\"); // 获取用户信息 var userInfo = await microsoftAccount.GetUserInfoAsync(oauthResponse.AccessToken); Console.WriteLine($\"用户 ID: {userInfo.Id}\"); Console.WriteLine($\"用户名: {userInfo.Gamertag}\"); } catch (Exception ex) { Console.WriteLine($\"授权失败: {ex.Message}\"); } Yggdrasil 认证 using Qomicex.Core.Modules.Helpers.Account.Yggdrasil; // 创建 Yggdrasil 账户实例 var yggdrasilAccount = new Yggdrasil(); // 登录账户 string username = \"your-username\"; string password = \"your-password\"; try { var loginResponse = await yggdrasilAccount.LoginAsync(username, password); Console.WriteLine($\"访问令牌: {loginResponse.AccessToken}\"); Console.WriteLine($\"客户端令牌: {loginResponse.ClientToken}\"); Console.WriteLine($\"用户 ID: {loginResponse.User.Id}\"); // 验证访问令牌 bool isValid = await yggdrasilAccount.ValidateAsync(loginResponse.AccessToken); Console.WriteLine($\"访问令牌有效: {isValid}\"); } catch (Exception ex) { Console.WriteLine($\"登录失败: {ex.Message}\"); }"
  },
  "docs/DataModules/README.html": {
    "href": "docs/DataModules/README.html",
    "title": "数据模块 | Qomicex.Core API文档",
    "summary": "数据模块 功能概述 DataModules 提供了 Qomicex 项目的数据结构定义，包括游戏配置、系统信息、版本信息等。 使用示例 using Qomicex.Core.DataModules; // 游戏配置 var launcherConfig = new DataModules.DataDetails.Launcher { MemoryLimit = 4096, // MB WindowSize = new DataModules.DataDetails.Launcher.WindowSize { Width = 854, Height = 480 }, JavaPath = @\"C:\\Program Files\\Java\\jre1.8.0_311\\bin\\javaw.exe\", GameDir = @\"C:\\Game\\.minecraft\" }; // 系统信息 var systemInfo = new DataModules.SystemInfo { OsName = SystemInfoHelper.OsName, OsArch = SystemInfoHelper.OsArch, TotalMemory = SystemInfoHelper.GetTotalMemory(), AvailableMemory = SystemInfoHelper.GetAvailableMemory() }; // 账户信息 var account = new DataModules.DataDetails.Account { Username = \"PlayerName\", AccessToken = \"your-access-token\", ClientToken = \"your-client-token\", Selected = true };"
  },
  "docs/Development/Authenticators/README.html": {
    "href": "docs/Development/Authenticators/README.html",
    "title": "验证模型 | Qomicex.Core API文档",
    "summary": "验证模型 在 Qomicex.Core 中，我们已经为开发者实现了您在 Minecraft 开发过程中可能遇到的所有的验证情形。 支持列表 模型名称 适用情形 OfflineAuthenticator 离线验证模型 YggdrasilAuthenticator 适用于旧版本的登录模型 MicrosoftAuthenticator 新版的微软验证模型 [[toc]] OfflineAuthenticator（离线验证模型） 概述 离线验证模型是 Qomicex.Core 提供的最简单的验证方式，它不需要任何网络连接或用户凭证。使用该模型可以快速启动游戏，但只能进行单人游戏或局域网游戏。 使用方法 using Qomicex.Core.Modules.Helpers.Account; using Qomicex.Core.Modules.Helpers.Account.Offline; // 创建离线验证器实例 var authenticator = new OfflineAuthenticator { Username = \"Player\" // 自定义玩家名称 }; try { // 执行验证 var result = await authenticator.AuthenticateAsync(); if (result.IsSuccess) { Console.WriteLine(\"离线验证成功！\"); Console.WriteLine($\"玩家名称: {result.PlayerName}\"); Console.WriteLine($\"UUID: {result.UUID}\"); } else { Console.WriteLine($\"验证失败: {result.ErrorMessage}\"); } } catch (Exception ex) { Console.WriteLine($\"验证过程中发生错误: {ex.Message}\"); } 特点 不需要网络连接 不需要用户凭证 验证过程非常快速 支持自定义玩家名称 可以快速启动游戏 适用于开发和测试环境 YggdrasilAuthenticator（旧版登录模型） 概述 Yggdrasil 验证模型是 Mojang 官方提供的验证方式，适用于使用 Mojang 账号登录的用户。该验证模型需要网络连接，并使用用户名和密码进行验证。 使用方法 using Qomicex.Core.Modules.Helpers.Account.Yggdrasil; // 创建 Yggdrasil 验证器实例 var authenticator = new YggdrasilAuthenticator { Username = \"your-email@example.com\", // 您的 Mojang 账号 Password = \"your-password\" // 您的密码 }; try { // 执行验证 var result = await authenticator.AuthenticateAsync(); if (result.IsSuccess) { Console.WriteLine(\"Yggdrasil 验证成功！\"); Console.WriteLine($\"玩家名称: {result.PlayerName}\"); Console.WriteLine($\"UUID: {result.UUID}\"); Console.WriteLine($\"访问令牌: {result.AccessToken}\"); Console.WriteLine($\"客户端令牌: {result.ClientToken}\"); } else { Console.WriteLine($\"验证失败: {result.ErrorMessage}\"); } } catch (Exception ex) { Console.WriteLine($\"验证过程中发生错误: {ex.Message}\"); } 特点 支持 Mojang 账号登录 需要网络连接 支持离线模式（通过访问令牌） 支持刷新访问令牌 支持验证访问令牌有效性 高级功能 using Qomicex.Core.Modules.Helpers.Account.Yggdrasil; // 创建验证器实例 var authenticator = new YggdrasilAuthenticator { Username = \"your-email@example.com\", Password = \"your-password\" }; // 验证 var result = await authenticator.AuthenticateAsync(); if (result.IsSuccess) { // 验证访问令牌 var validateResult = await authenticator.ValidateTokenAsync(result.AccessToken, result.ClientToken); Console.WriteLine($\"访问令牌有效: {validateResult.IsSuccess}\"); // 刷新访问令牌 var refreshResult = await authenticator.RefreshTokenAsync(result.AccessToken, result.ClientToken); if (refreshResult.IsSuccess) { Console.WriteLine($\"刷新访问令牌成功！\"); Console.WriteLine($\"新访问令牌: {refreshResult.AccessToken}\"); } // 失效访问令牌 var invalidateResult = await authenticator.InvalidateTokenAsync(result.AccessToken, result.ClientToken); Console.WriteLine($\"失效访问令牌成功: {invalidateResult.IsSuccess}\"); } MicrosoftAuthenticator（新版微软验证模型） 概述 Microsoft 验证模型是 Mojang 官方推荐的验证方式，适用于使用 Microsoft 账号登录的用户。该验证模型需要网络连接，并使用 Microsoft 账号进行验证。 配置 在使用 Microsoft 验证模型之前，您需要先配置您的应用程序： using Qomicex.Core.Modules.Helpers.Account.Microsoft; // 配置微软验证器 MicrosoftAuthenticator.Configure(new MicrosoftAuthenticatorAPISettings { ClientId = \"your-client-id\", TenentId = \"consumers\", Scopes = new[] { \"XboxLive.signin\", \"offline_access\", \"openid\", \"profile\", \"email\" } }); 使用方法 using Qomicex.Core.Modules.Helpers.Account.Microsoft; // 创建微软验证器实例 var authenticator = new MicrosoftAuthenticator(); try { // 获取授权 URL var authUrl = authenticator.GetAuthorizationUrl(); Console.WriteLine($\"请访问以下 URL 进行授权: {authUrl}\"); // 获取用户输入的授权码 Console.Write(\"请输入授权码: \"); var code = Console.ReadLine(); // 执行验证 var result = await authenticator.AuthorizeAsync(code); if (result.IsSuccess) { Console.WriteLine(\"Microsoft 验证成功！\"); Console.WriteLine($\"玩家名称: {result.PlayerName}\"); Console.WriteLine($\"UUID: {result.UUID}\"); Console.WriteLine($\"访问令牌: {result.AccessToken}\"); Console.WriteLine($\"刷新令牌: {result.RefreshToken}\"); Console.WriteLine($\"过期时间: {result.ExpiresIn} 秒\"); } else { Console.WriteLine($\"验证失败: {result.ErrorMessage}\"); } } catch (Exception ex) { Console.WriteLine($\"验证过程中发生错误: {ex.Message}\"); } 特点 支持 Microsoft 账号登录 需要网络连接 支持多因素认证 支持刷新访问令牌 支持设备代码流（Device Code Flow） 设备代码流（Device Code Flow） using Qomicex.Core.Modules.Helpers.Account.Microsoft; var authenticator = new MicrosoftAuthenticator(); try { // 启动设备代码流 var deviceCode = await authenticator.StartDeviceCodeFlowAsync(); Console.WriteLine($\"请访问: {deviceCode.VerificationUri}\"); Console.WriteLine($\"输入代码: {deviceCode.UserCode}\"); Console.WriteLine($\"过期时间: {deviceCode.ExpiresIn} 秒\"); Console.WriteLine($\"轮询间隔: {deviceCode.Interval} 秒\"); // 等待用户授权 var result = await authenticator.WaitForDeviceCodeFlowCompletionAsync(deviceCode); if (result.IsSuccess) { Console.WriteLine(\"Microsoft 验证成功！\"); Console.WriteLine($\"玩家名称: {result.PlayerName}\"); Console.WriteLine($\"UUID: {result.UUID}\"); Console.WriteLine($\"访问令牌: {result.AccessToken}\"); Console.WriteLine($\"刷新令牌: {result.RefreshToken}\"); } else { Console.WriteLine($\"验证失败: {result.ErrorMessage}\"); } } catch (Exception ex) { Console.WriteLine($\"验证过程中发生错误: {ex.Message}\"); } 验证结果处理 通用验证结果 所有验证器都会返回一个通用的验证结果对象： public class AuthenticationResult { public bool IsSuccess { get; set; } public string PlayerName { get; set; } public string UUID { get; set; } public string AccessToken { get; set; } public string ClientToken { get; set; } public string RefreshToken { get; set; } public int ExpiresIn { get; set; } public string ErrorMessage { get; set; } } 错误处理 在使用验证器时，您需要处理可能的错误： using Qomicex.Core.Modules.Helpers.Account; try { var result = await authenticator.AuthenticateAsync(); if (result.IsSuccess) { // 验证成功，处理结果 } else { // 验证失败，显示错误信息 Console.WriteLine($\"验证失败: {result.ErrorMessage}\"); } } catch (AuthenticationException ex) { // 处理认证相关异常 Console.WriteLine($\"认证异常: {ex.Message}\"); } catch (NetworkException ex) { // 处理网络异常 Console.WriteLine($\"网络异常: {ex.Message}\"); } catch (Exception ex) { // 处理其他异常 Console.WriteLine($\"其他异常: {ex.Message}\"); } 最佳实践 安全存储凭证 在实际应用中，您应该妥善存储用户的凭证信息： using Qomicex.Core.Modules.Helpers.Account; using System.Security.Cryptography; using System.Text; // 加密凭证信息 public static string Encrypt(string text, string key) { // 使用 AES 加密算法 using var aes = Aes.Create(); aes.Key = Encoding.UTF8.GetBytes(key.PadRight(32).Substring(0, 32)); aes.IV = Encoding.UTF8.GetBytes(key.PadRight(16).Substring(0, 16)); using var encryptor = aes.CreateEncryptor(); var bytes = Encoding.UTF8.GetBytes(text); var encrypted = encryptor.TransformFinalBlock(bytes, 0, bytes.Length); return Convert.ToBase64String(encrypted); } // 解密凭证信息 public static string Decrypt(string encryptedText, string key) { using var aes = Aes.Create(); aes.Key = Encoding.UTF8.GetBytes(key.PadRight(32).Substring(0, 32)); aes.IV = Encoding.UTF8.GetBytes(key.PadRight(16).Substring(0, 16)); using var decryptor = aes.CreateDecryptor(); var bytes = Convert.FromBase64String(encryptedText); var decrypted = decryptor.TransformFinalBlock(bytes, 0, bytes.Length); return Encoding.UTF8.GetString(decrypted); } // 使用示例 var encryptedPassword = Encrypt(\"your-password\", \"your-secret-key\"); // 存储 encryptedPassword var decryptedPassword = Decrypt(encryptedPassword, \"your-secret-key\"); // 使用 decryptedPassword 进行验证 会话管理 您应该正确管理用户的会话： using Qomicex.Core.Modules.Helpers.Account; // 保存会话信息 public static void SaveSession(AuthenticationResult result) { var session = new { PlayerName = result.PlayerName, UUID = result.UUID, AccessToken = result.AccessToken, ClientToken = result.ClientToken, RefreshToken = result.RefreshToken, ExpiresAt = DateTime.Now.AddSeconds(result.ExpiresIn) }; var json = JsonConvert.SerializeObject(session); File.WriteAllText(\"session.json\", json); } // 加载会话信息 public static AuthenticationResult LoadSession() { if (!File.Exists(\"session.json\")) return null; var json = File.ReadAllText(\"session.json\"); var session = JsonConvert.DeserializeObject<dynamic>(json); // 检查会话是否过期 var expiresAt = DateTime.Parse(session.ExpiresAt.ToString()); if (expiresAt < DateTime.Now) { File.Delete(\"session.json\"); return null; } return new AuthenticationResult { IsSuccess = true, PlayerName = session.PlayerName, UUID = session.UUID, AccessToken = session.AccessToken, ClientToken = session.ClientToken, RefreshToken = session.RefreshToken, ExpiresIn = (int)(expiresAt - DateTime.Now).TotalSeconds }; } // 使用示例 var existingSession = LoadSession(); if (existingSession != null) { Console.WriteLine($\"已登录用户: {existingSession.PlayerName}\"); } else { // 显示登录界面 var result = await authenticator.AuthenticateAsync(); SaveSession(result); }"
  },
  "docs/Development/BeforeWeStart/README.html": {
    "href": "docs/Development/BeforeWeStart/README.html",
    "title": "在我们开始之前 | Qomicex.Core API文档",
    "summary": "在我们开始之前 在我们正式开始使用 Qomicex.Core，您需要对您的项目属性做一下必要的检查和调整以满足 Qomicex.Core 的运行需要。 [[toc]] 运行时要求 您需要保证您项目的 .NET 框架至少运行在 .NET 6.0 及更高的版本当中。 目前受支持的 .NET 版本： .NET 6.0 .NET 7.0 .NET 8.0 .NET 10.0（推荐） ::: warning Qomicex.Core 已不再支持 .NET 5.0 及更早版本。 ::: 项目属性 由于 Windows 系统机制，您需要在项目属性中关闭 首选 32 位 的生成选项。否则您在使用 Qomicex.Core 部分组件时会出现预料之外的结果。 您需要在 Visual Studio 中切换到项目的属性页面，并找到 首选 32 位 的勾选框，并将其取消勾选。 32 位系统支持 ::: warning Qomicex.Core 从项目立项开始就决定放弃对 32 位系统的全部支持，因为它已经过时了。 ::: 开发环境要求 Visual Studio 推荐使用 Visual Studio 2022 或更高版本 确保已安装 .NET 桌面开发工作负载 安装 .NET 8.0 或更高版本的 SDK Rider 推荐使用 Rider 2023 或更高版本 确保已安装 .NET 8.0 或更高版本的 SDK 其他开发工具 .NET SDK 8.0 或更高版本 Git 版本控制工具 NuGet 包管理器 开发前准备 项目结构 建议您的项目结构如下： MyMinecraftLauncher/ ├── MyMinecraftLauncher.csproj ├── Program.cs ├── App.xaml ├── App.xaml.cs ├── Views/ │ ├── MainWindow.xaml │ └── MainWindow.xaml.cs └── ViewModels/ └── MainWindowViewModel.cs 依赖项 在开始使用 Qomicex.Core 之前，您需要确保项目已经安装了以下 NuGet 包： Qomicex.Core - 主核心库 Newtonsoft.Json - JSON 解析库（Qomicex.Core 依赖） System.Net.Http - HTTP 请求库（Qomicex.Core 依赖） 快速测试 在开始正式开发之前，您可以创建一个简单的测试项目来验证 Qomicex.Core 是否正常工作： using System; using System.Threading.Tasks; using Qomicex.Core.Modules.Helpers.Resources; class Program { static async Task Main(string[] args) { try { Console.WriteLine(\"正在测试 Qomicex.Core...\"); // 测试游戏资源助手 var resourceHelper = new GameResourceHelper(); Console.WriteLine(\"正在获取 Minecraft 版本列表...\"); var versions = await resourceHelper.GetMinecraftListAsync(1); // 使用官方源 Console.WriteLine($\"成功获取到 {versions.Count} 个 Minecraft 版本\"); if (versions.Count > 0) { var latestVersion = versions[0]; Console.WriteLine($\"最新版本: {latestVersion.Id}\"); Console.WriteLine($\"类型: {latestVersion.Type}\"); Console.WriteLine($\"发布时间: {latestVersion.ReleaseTime}\"); } Console.WriteLine(\"\\nQomicex.Core 测试成功！\"); } catch (Exception ex) { Console.WriteLine($\"测试失败: {ex.Message}\"); if (ex.InnerException != null) Console.WriteLine($\"内部错误: {ex.InnerException.Message}\"); } Console.WriteLine(\"\\n按任意键退出...\"); Console.ReadKey(); } } 如果您能看到输出的 Minecraft 版本信息，说明 Qomicex.Core 已经正常工作了。 下一步 现在您已经准备好了开发环境，可以继续学习如何使用 Qomicex.Core 的其他功能： 安装并配置 Qomicex.Core 验证模型 安装器 资源补全器"
  },
  "docs/Development/InstallationAndConfig/README.html": {
    "href": "docs/Development/InstallationAndConfig/README.html",
    "title": "安装并配置 Qomicex.Core | Qomicex.Core API文档",
    "summary": "安装并配置 Qomicex.Core [[toc]] 从 NuGet 安装 您可以方便地从 NuGet 上搜索并下载 Qomicex.Core 的软件包。 Visual Studio 包管理器 在 Visual Studio 的包管理器中搜索 Qomicex.Core 并将其添加到您的项目中。 .NET CLI 要通过 .NET CLI 来安装 Qomicex.Core，您只需要将终端切换到包含 .csproj 文件的项目目录，并在终端中执行： dotnet add package Qomicex.Core --version 1.0.0 PackageReference 您只需在项目的 [项目名].csproj 文件中添加： <PackageReference Include=\"Qomicex.Core\" Version=\"1.0.0\" /> ::: tip 其中，1.0.0 为 Qomicex.Core 的版本号，您可以将其替换为其他的版本号， 所有的发行版本都可以在 Qomicex.Core - Nuget 中查看。 ::: 从源码引用 另外一种使用 Qomicex.Core 的方法是直接添加代码仓库到您的项目引用。 ::: info 在执行下面的命令前，您可能需要先安装 Git CLI ::: 克隆 Qomicex.Avalonia 仓库 使用命令行切换到项目解决方案的根目录，并在命令行中执行下面的代码来完成仓库的克隆： git clone https://github.com/TheMyceliumOfAntan/Qomicex.Avalonia.git 使用 Git Submodule（子模块）的方式拉取 Qomicex.Core ::: tip Git Submodule 是一个非常实用的功能，在这里我们只展示了其最基本的用例。 在 Git 官方文档 中您可以查看到更多的使用案例。 ::: 使用命令行切换到项目解决方案的根目录，并在命令行中执行下面的代码来完成仓库的克隆： git submodule add https://github.com/TheMyceliumOfAntan/Qomicex.Avalonia.git 添加对 Qomicex.Core 的引用 接下来，在 Visual Studio 的 解决方案资源管理器 视图中，右键点击位于树状图顶层的解决方案名称。 并选择 “添加”-“现有项目”，并在文件浏览窗口中找到刚刚克隆的 Qomicex.Avalonia 项目文件夹中的 Qomicex.Core.csproj。 接着，在 解决方案资源管理器 找到您需要引用 Qomicex.Core 的项目，并右键单击，选择 “添加”-“项目引用”。 最后在弹出窗口中勾选 Qomicex.Core 即可完成对其的引用。 使用前配置 修改默认连接数 在使用 Qomicex.Core 之前，您需要在程序的入口点（通常是 App.xaml.cs 或 Program.cs） 中添加一些代码来初始化 Qomicex.Core 的相关服务。 由于 .NET 运行时默认的最大连接数限制，在使用 Qomicex.Core 下载模块时可能会遭遇性能瓶颈。 因此，您需要在入口处添加下面的代码来修改默认的最大连接数： using System.Net; ServicePointManager.DefaultConnectionLimit = 512; 初始化下载服务 在初始化下载服务时您可以选择自定义请求时所使用的 User Agent（默认为 \"QomicexCore\"）。 // 可选：配置下载服务 HttpClientHelper.Ua = \"MyCustomUserAgent\"; 配置微软登录验证器 关于 Azure Active Directory 应用具体的注册方法请参考 Microsoft 官方文档。 ::: tip 在配置微软验证器前，您需要在 Azure 注册您的应用，并对其进行正确的配置。 在您完成配置之后，您会获得一串 Client ID。 相关资料： Azure 官网 设备代码流 ::: ::: warning CLIENT ID 为敏感的个人凭据，请妥善保存 CLIENT ID 并不要将其泄露给其他人。 ::: using Qomicex.Core.Modules.Helpers.Account.Microsoft; MicrosoftAuthenticator.Configure(new MicrosoftAuthenticatorAPISettings { ClientId = \"[YOUR CLIENT ID]\", TenentId = \"consumers\", Scopes = new[] { \"XboxLive.signin\", \"offline_access\", \"openid\", \"profile\", \"email\" } }); 在取得 Client ID 后，将 [YOUR CLIENT ID] 替换为您的 Client ID。 配置 CurseForge API 服务（可选） 该服务为可选项目，如果您没有使用任何 CurseForge 相关服务，您可以忽略这个步骤。 ::: tip 在使用 CurseForge 相关服务前，您需要准备 CurseForge 官方下发的 API KEY。 如果您还没有，请前往 申请页面 - CurseForge 来获得您的 API KEY。 ::: ::: warning API KEY 为敏感的个人凭据，请妥善保存 API KEY 并不要将其泄露给其他人。 ::: using Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge; CurseForgeAPIHelper.SetApiKey(\"[YOUR API KEY]\"); 将 [YOUR API KEY] 替换为您从 CurseForge 官方获取的 API KEY。 项目配置 应用程序清单文件 为了确保 Qomicex.Core 能够正常运行，您需要确保应用程序清单文件（app.manifest）包含以下配置： <?xml version=\"1.0\" encoding=\"utf-8\"?> <assembly manifestVersion=\"1.0\" xmlns=\"urn:schemas-microsoft-com:asm.v1\"> <assemblyIdentity version=\"1.0.0.0\" name=\"MyMinecraftLauncher\"/> <trustInfo xmlns=\"urn:schemas-microsoft-com:asm.v2\"> <security> <requestedPrivileges xmlns=\"urn:schemas-microsoft-com:asm.v3\"> <requestedExecutionLevel level=\"requireAdministrator\" uiAccess=\"false\" /> </requestedPrivileges> </security> </trustInfo> <compatibility xmlns=\"urn:schemas-microsoft-com:compatibility.v1\"> <application> <supportedOS Id=\"{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}\"/> </application> </compatibility> </assembly> 构建配置 建议您在项目属性中进行以下配置： 目标平台：选择 \"Any CPU\" 并取消勾选 \"Prefer 32-bit\" 目标框架：选择 \".NET 8.0\" 或更高版本 输出类型：选择 \"Windows 应用程序\"（如果是 GUI 应用）或 \"控制台应用程序\"（如果是命令行工具） 测试配置 为了确保您的应用程序能够正常工作，建议您在开发过程中进行以下测试： 测试网络连接 测试资源下载功能 测试游戏启动功能 测试不同版本的 Minecraft 兼容性 测试不同操作系统的兼容性 常见问题 无法找到 Qomicex.Core 命名空间 确保您已经正确安装了 Qomicex.Core NuGet 包，并且项目引用已正确添加。 程序崩溃或无法启动 检查以下几个方面： 确保您的应用程序具有足够的权限 确保您的网络连接正常 检查应用程序日志文件以获取详细错误信息 尝试以管理员身份运行应用程序 资源下载失败 检查以下几个方面： 确保您的网络连接正常 尝试使用不同的资源源 检查防火墙或安全软件是否阻止了下载请求 尝试调整下载超时时间 游戏启动失败 检查以下几个方面： 确保您已经正确安装了 Java 检查 Java 路径是否正确 检查游戏资源是否完整 尝试调整内存分配"
  },
  "docs/Development/Installers/README.html": {
    "href": "docs/Development/Installers/README.html",
    "title": "安装器 | Qomicex.Core API文档",
    "summary": "安装器 在 Qomicex.Core 中，我们已经为开发者实现了您在 Minecraft 开发过程中可能遇到的大部分模组基础设施。 支持列表 项目名称 支持状态 Forge （旧版） 受支持 ✅ Forge （新版） 受支持 ✅ LiteLoader 受支持 ✅ Fabric 受支持 ✅ Optifine 受支持 ✅ Quilt 受支持 ✅ CurseForge 整合包 受支持 ✅ [[toc]] 通用安装接口 所有的安装器都实现了相同的接口，这使得在代码中切换不同的安装器变得非常简单。 using Qomicex.Core.Modules.Helpers.Installers; public interface IInstaller { // 获取安装器信息 InstallerInfo GetInstallerInfo(); // 安装 Mod 加载器 Task<InstallResult> InstallAsync(string versionId, string inheritsFromJson, string para1, string para2, string para3, string para4); // 验证安装 Task<ValidationResult> ValidateAsync(string versionId, string gameDirectory); // 获取支持的版本 Task<IEnumerable<VersionInfo>> GetSupportedVersionsAsync(string gameVersion); } 安装器基类 所有的安装器都继承自 InstallerBase 类，它提供了通用的安装功能。 using Qomicex.Core.Modules.Helpers.Installers; public abstract class InstallerBase : IInstaller { // 通用下载方法 protected async Task<string> DownloadFileAsync(string url, string destinationPath); // 通用文件操作方法 protected void ExtractArchive(string archivePath, string destinationPath); // 通用配置文件处理方法 protected string MergeVersionJson(string mainVersionJson, string mergedVersionJson, string? defaultVersionId); // 通用依赖检查方法 protected async Task<bool> CheckDependenciesAsync(string versionId); } Forge 安装器 使用方法 using Qomicex.Core.Modules.Helpers.Installers; // 创建 Forge 安装器实例 var forgeInstaller = new ForgeInstaller((int)DownloadSource.Official, @\"C:\\Games\\.minecraft\"); try { // 安装 Forge var result = await forgeInstaller.InstallAsync( \"1.20.1-forge-47.1.3\", // 版本 ID null, // 继承版本 JSON（可选） \"1.20.1\", // 游戏版本 \"47.1.3\", // Forge 版本 null, // 额外参数 1 null // 额外参数 2 ); if (result.IsSuccess) { Console.WriteLine(\"Forge 安装成功！\"); Console.WriteLine($\"安装路径: {result.InstallPath}\"); } else { Console.WriteLine($\"安装失败: {result.ErrorMessage}\"); } } catch (Exception ex) { Console.WriteLine($\"安装过程中发生错误: {ex.Message}\"); } 高级用法 using Qomicex.Core.Modules.Helpers.Installers; var forgeInstaller = new ForgeInstaller((int)DownloadSource.Official, @\"C:\\Games\\.minecraft\"); // 检查 Forge 版本是否与游戏版本兼容 var compatible = await forgeInstaller.CheckCompatibilityAsync(\"1.20.1\", \"47.1.3\"); if (compatible) Console.WriteLine(\"版本兼容\"); // 获取支持的 Forge 版本 var supportedVersions = await forgeInstaller.GetSupportedVersionsAsync(\"1.20.1\"); foreach (var version in supportedVersions) { Console.WriteLine($\"版本: {version.Version}\"); Console.WriteLine($\"类型: {version.Type}\"); Console.WriteLine($\"下载链接: {version.DownloadUrl}\"); } Fabric 安装器 使用方法 using Qomicex.Core.Modules.Helpers.Installers; // 创建 Fabric 安装器实例 var fabricInstaller = new FabricInstaller((int)DownloadSource.Official, @\"C:\\Games\\.minecraft\"); try { // 安装 Fabric var result = await fabricInstaller.InstallAsync( \"1.20.1-fabric-0.14.24\", // 版本 ID null, // 继承版本 JSON（可选） \"1.20.1\", // 游戏版本 \"0.14.24\", // Fabric 版本 null, // 额外参数 1 null // 额外参数 2 ); if (result.IsSuccess) { Console.WriteLine(\"Fabric 安装成功！\"); Console.WriteLine($\"安装路径: {result.InstallPath}\"); } else { Console.WriteLine($\"安装失败: {result.ErrorMessage}\"); } } catch (Exception ex) { Console.WriteLine($\"安装过程中发生错误: {ex.Message}\"); } 高级用法 using Qomicex.Core.Modules.Helpers.Installers; var fabricInstaller = new FabricInstaller((int)DownloadSource.Official, @\"C:\\Games\\.minecraft\"); // 获取支持的 Fabric 版本 var supportedVersions = await fabricInstaller.GetSupportedVersionsAsync(\"1.20.1\"); foreach (var version in supportedVersions) { Console.WriteLine($\"版本: {version.Version}\"); Console.WriteLine($\"类型: {version.Type}\"); Console.WriteLine($\"下载链接: {version.DownloadUrl}\"); } // 验证 Fabric 安装 var validationResult = await fabricInstaller.ValidateAsync(\"1.20.1-fabric-0.14.24\", @\"C:\\Games\\.minecraft\"); if (validationResult.IsValid) Console.WriteLine(\"Fabric 安装验证成功！\"); else Console.WriteLine($\"验证失败: {validationResult.ErrorMessage}\"); Quilt 安装器 使用方法 using Qomicex.Core.Modules.Helpers.Installers; // 创建 Quilt 安装器实例 var quiltInstaller = new QuiltInstaller((int)DownloadSource.Official, @\"C:\\Games\\.minecraft\"); try { // 安装 Quilt var result = await quiltInstaller.InstallAsync( \"1.20.1-quilt-0.18.10\", // 版本 ID null, // 继承版本 JSON（可选） \"1.20.1\", // 游戏版本 \"0.18.10\", // Quilt 版本 null, // 额外参数 1 null // 额外参数 2 ); if (result.IsSuccess) { Console.WriteLine(\"Quilt 安装成功！\"); Console.WriteLine($\"安装路径: {result.InstallPath}\"); } else { Console.WriteLine($\"安装失败: {result.ErrorMessage}\"); } } catch (Exception ex) { Console.WriteLine($\"安装过程中发生错误: {ex.Message}\"); } LiteLoader 安装器 使用方法 using Qomicex.Core.Modules.Helpers.Installers; // 创建 LiteLoader 安装器实例 var liteLoaderInstaller = new LiteloaderInstaller((int)DownloadSource.Official, @\"C:\\Games\\.minecraft\"); try { // 安装 LiteLoader var result = await liteLoaderInstaller.InstallAsync( \"1.12.2-liteloader-1.12.2-SNAPSHOT\", // 版本 ID null, // 继承版本 JSON（可选） \"1.12.2\", // 游戏版本 null, // LiteLoader 版本（自动获取） null, // 额外参数 1 null // 额外参数 2 ); if (result.IsSuccess) { Console.WriteLine(\"LiteLoader 安装成功！\"); Console.WriteLine($\"安装路径: {result.InstallPath}\"); } else { Console.WriteLine($\"安装失败: {result.ErrorMessage}\"); } } catch (Exception ex) { Console.WriteLine($\"安装过程中发生错误: {ex.Message}\"); } OptiFine 安装器 使用方法 using Qomicex.Core.Modules.Helpers.Installers; // 创建 OptiFine 安装器实例 var optifineInstaller = new OptiFineInstaller((int)DownloadSource.Official, @\"C:\\Games\\.minecraft\"); try { // 安装 OptiFine var result = await optifineInstaller.InstallAsync( \"1.20.1-optifine-HD_U_I5\", // 版本 ID null, // 继承版本 JSON（可选） \"1.20.1\", // 游戏版本 \"HD_U_I5\", // OptiFine 版本 null, // 额外参数 1 null // 额外参数 2 ); if (result.IsSuccess) { Console.WriteLine(\"OptiFine 安装成功！\"); Console.WriteLine($\"安装路径: {result.InstallPath}\"); } else { Console.WriteLine($\"安装失败: {result.ErrorMessage}\"); } } catch (Exception ex) { Console.WriteLine($\"安装过程中发生错误: {ex.Message}\"); } CurseForge 整合包安装器 使用方法 using Qomicex.Core.Modules.Helpers.Installers; // 创建 CurseForge 整合包安装器实例 var modpackInstaller = new CurseForgeModPackInstaller((int)DownloadSource.Official, @\"C:\\Games\\.minecraft\"); try { // 安装 CurseForge 整合包 var result = await modpackInstaller.InstallAsync( \"my-modpack\", // 版本 ID null, // 继承版本 JSON（可选） \"curseforge-modpack-id\", // CurseForge 整合包 ID \"1.0.0\", // 整合包版本 null, // 额外参数 1 null // 额外参数 2 ); if (result.IsSuccess) { Console.WriteLine(\"CurseForge 整合包安装成功！\"); Console.WriteLine($\"安装路径: {result.InstallPath}\"); } else { Console.WriteLine($\"安装失败: {result.ErrorMessage}\"); } } catch (Exception ex) { Console.WriteLine($\"安装过程中发生错误: {ex.Message}\"); } 安装结果 所有的安装器都会返回一个统一的安装结果对象： public class InstallResult { public bool IsSuccess { get; set; } public string InstallPath { get; set; } public string ErrorMessage { get; set; } public string Log { get; set; } } 验证安装 在安装完成后，您可以使用 ValidateAsync 方法来验证安装是否成功： using Qomicex.Core.Modules.Helpers.Installers; var installer = new FabricInstaller((int)DownloadSource.Official, @\"C:\\Games\\.minecraft\"); var validationResult = await installer.ValidateAsync(\"1.20.1-fabric-0.14.24\", @\"C:\\Games\\.minecraft\"); if (validationResult.IsValid) { Console.WriteLine(\"安装验证成功！\"); } else { Console.WriteLine($\"验证失败: {validationResult.ErrorMessage}\"); // 列出所有验证问题 foreach (var issue in validationResult.Issues) { Console.WriteLine($\"问题: {issue.Description} ({issue.Severity})\"); } } 安装过程监控 您可以通过安装事件来监控安装过程： using Qomicex.Core.Modules.Helpers.Installers; var installer = new ForgeInstaller((int)DownloadSource.Official, @\"C:\\Games\\.minecraft\"); // 安装进度事件 installer.ProgressChanged += (sender, args) => { Console.WriteLine($\"安装进度: {args.ProgressPercentage}%\"); Console.WriteLine($\"当前任务: {args.CurrentTask}\"); Console.WriteLine($\"已下载: {args.DownloadedSize} / {args.TotalSize}\"); }; // 下载完成事件 installer.DownloadCompleted += (sender, args) => { Console.WriteLine(\"下载完成！\"); }; // 提取完成事件 installer.ExtractionCompleted += (sender, args) => { Console.WriteLine(\"文件提取完成！\"); }; // 配置完成事件 installer.ConfigurationCompleted += (sender, args) => { Console.WriteLine(\"配置完成！\"); }; try { var result = await installer.InstallAsync(...); } catch (Exception ex) { Console.WriteLine($\"安装过程中发生错误: {ex.Message}\"); } 安装优化 多线程下载 using Qomicex.Core.Modules.Helpers.Installers; // 配置下载选项 var downloadOptions = new DownloadOptions { MaxConcurrentDownloads = 8, // 最大并发下载数 ChunkSize = 4 * 1024 * 1024, // 分块大小 RetryCount = 3, // 重试次数 Timeout = TimeSpan.FromSeconds(30) // 超时时间 }; var installer = new ForgeInstaller((int)DownloadSource.Official, @\"C:\\Games\\.minecraft\", downloadOptions); 缓存配置 using Qomicex.Core.Modules.Helpers.Installers; // 配置缓存选项 var cacheOptions = new CacheOptions { EnableCache = true, // 启用缓存 CacheLocation = @\"C:\\Games\\.minecraft\\cache\", // 缓存位置 CacheDuration = TimeSpan.FromDays(7), // 缓存有效期 MaxCacheSize = 10 * 1024 * 1024 * 1024 // 最大缓存大小（10GB） }; var installer = new FabricInstaller((int)DownloadSource.Official, @\"C:\\Games\\.minecraft\", cacheOptions); 常见问题 安装失败 如果安装失败，可以检查以下几个方面： 网络连接是否正常 游戏目录是否有写入权限 下载源是否可用 磁盘空间是否充足 安装文件是否完整 依赖检查失败 如果依赖检查失败，可以检查： 是否缺少必要的依赖库 依赖库的版本是否匹配 依赖库是否已正确安装 配置文件错误 如果配置文件错误，可以检查： 配置文件是否已正确生成 配置文件中的路径是否正确 配置文件是否有语法错误"
  },
  "docs/Development/README.html": {
    "href": "docs/Development/README.html",
    "title": "Qomicex.Core 开发教程 | Qomicex.Core API文档",
    "summary": "Qomicex.Core 开发教程 概述 欢迎来到 Qomicex.Core 开发教程！本教程将帮助您了解 Qomicex.Core 的架构设计、核心功能和开发流程，为您快速上手开发基于 Qomicex.Core 的 Minecraft 启动器或相关工具提供指导。 项目简介 Qomicex.Core 是一个功能强大的 Minecraft 启动器核心库，提供了完整的启动流程管理、游戏资源管理、账户认证、Mod 管理等功能。它采用模块化设计，具有高度的可扩展性和可定制性，适用于各种规模的 Minecraft 相关应用开发。 主要特性 完整的启动流程管理：从游戏安装到启动的完整流程 灵活的账户认证系统：支持多种认证方式，包括 Microsoft、Yggdrasil 等 全面的资源管理：游戏版本下载、Mod 管理、资源包管理等 强大的 Mod 支持：支持 Forge、Fabric、Quilt 等多种 Mod 加载器 跨平台兼容：支持 Windows、Linux 和 macOS 系统 模块化设计：高度模块化的架构，易于扩展和定制 异步编程：大量使用异步 API，提供良好的用户体验 目录 [[toc]] 在我们开始之前 在开始使用 Qomicex.Core 之前，您需要对开发环境和项目配置有一定的了解。请先阅读 在我们开始之前 章节，确保您的开发环境已正确配置。 安装并配置 Qomicex.Core 在配置好开发环境后，您需要安装并配置 Qomicex.Core 库。请阅读 安装并配置 Qomicex.Core 章节，了解如何安装和配置 Qomicex.Core。 验证模型 Qomicex.Core 提供了多种 Minecraft 验证模型，包括离线验证、Yggdrasil 验证和 Microsoft 验证。请阅读 验证模型 章节，了解如何使用这些验证模型。 安装器 Qomicex.Core 提供了多种 Mod 加载器的安装器，包括 Forge、Fabric、Quilt、LiteLoader 和 OptiFine。请阅读 安装器 章节，了解如何使用这些安装器。 资源补全器 资源补全器负责下载和管理 Minecraft 游戏所需的各种资源文件。请阅读 资源补全器 章节，了解如何使用资源补全器。 快速开始 环境要求 .NET 8.0 或更高版本 Visual Studio 2022 或其他兼容的 IDE Git 版本控制工具 创建第一个项目 # 创建项目 dotnet new console -n QomicexDemo cd QomicexDemo # 添加 NuGet 源（如果需要） dotnet nuget add source https://api.nuget.org/v3/index.json --name nuget.org # 添加 Qomicex.Core 依赖 dotnet add package Qomicex.Core 编写简单的启动器 using Qomicex.Core; using Qomicex.Core.Modules.Helpers.Account.Microsoft; using Qomicex.Core.Modules.Helpers.Resources; using Qomicex.Core.Modules.Launcher; using System; using System.Threading.Tasks; namespace QomicexDemo { class Program { static async Task Main(string[] args) { Console.WriteLine(\"Qomicex.Core 启动器示例\"); try { // 1. 初始化核心组件 var gameResourceHelper = new GameResourceHelper(); var microsoftAuth = new Microsoft(); // 2. 获取游戏版本列表 Console.WriteLine(\"获取游戏版本列表...\"); var versions = await gameResourceHelper.GetMinecraftListAsync(1); Console.WriteLine($\"可用版本数: {versions.Count}\"); // 3. 打印最新版本 var latestVersion = versions.Find(v => v.Type == \"release\"); Console.WriteLine($\"最新正式版: {latestVersion?.Id}\"); // 4. 启动游戏（简化示例） var launcher = new Qomicex.Core.Modules.Launcher.Launcher(); var launchParams = new LauncherParam { GameDir = @\"C:\\Users\\YourName\\.minecraft\", Version = latestVersion?.Id, JavaPath = \"java\", MaxMemory = 4096, Username = \"Player\" }; Console.WriteLine(\"正在启动游戏...\"); var result = await launcher.StartGameAsync(launchParams); Console.WriteLine(\"游戏启动状态: \" + result); } catch (Exception ex) { Console.WriteLine($\"发生错误: {ex.Message}\"); } Console.WriteLine(\"按任意键继续...\"); Console.ReadKey(); } } } 架构设计 核心架构 Qomicex.Core 采用三层架构设计： 基础层：包含通用工具、数据模块、日志分析等基础功能 核心服务层：提供游戏资源管理、账户认证、启动器核心功能 业务逻辑层：处理游戏启动流程、Mod 管理等复杂业务逻辑 模块架构 Qomicex.Core 采用模块化设计，每个功能模块独立实现，提供清晰的接口： 数据模块：定义核心数据结构和配置 工具模块：提供通用的工具方法和功能 账户模块：处理用户认证和账户管理 资源模块：管理游戏资源、Mod、资源包等 启动器模块：负责游戏启动流程管理 核心功能开发 1. 游戏版本管理 using Qomicex.Core.Modules.Helpers.Resources; var resourceHelper = new GameResourceHelper(); // 获取版本列表 var versions = await resourceHelper.GetMinecraftListAsync(1); // 根据版本ID获取详细信息 var versionInfo = await resourceHelper.GetMinecraftVersionManifest(1); // 下载游戏资源 var downloader = new ResourceDownloader(); await downloader.DownloadGameResourcesAsync(\"1.20.1\", @\"C:\\Game\\.minecraft\"); 2. 账户认证 Microsoft 账户认证 using Qomicex.Core.Modules.Helpers.Account.Microsoft; var microsoftAuth = new Microsoft(); // 获取授权 URL var authUrl = microsoftAuth.GetAuthorizationUrl(); Console.WriteLine($\"请访问以下 URL 进行授权: {authUrl}\"); // 获取用户输入的授权码 Console.Write(\"请输入授权码: \"); var code = Console.ReadLine(); try { var authResult = await microsoftAuth.AuthorizeAsync(code); Console.WriteLine($\"访问令牌: {authResult.AccessToken}\"); Console.WriteLine($\"刷新令牌: {authResult.RefreshToken}\"); Console.WriteLine($\"过期时间: {authResult.ExpiresIn} 秒\"); } catch (Exception ex) { Console.WriteLine($\"授权失败: {ex.Message}\"); } Yggdrasil 认证 using Qomicex.Core.Modules.Helpers.Account.Yggdrasil; var yggdrasilAuth = new Yggdrasil(); // 登录 var loginResult = await yggdrasilAuth.LoginAsync(\"username\", \"password\"); // 验证访问令牌 var isValid = await yggdrasilAuth.ValidateAsync(loginResult.AccessToken); // 刷新访问令牌 var refreshResult = await yggdrasilAuth.RefreshAsync( loginResult.AccessToken, loginResult.ClientToken ); 3. Mod 管理 using Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge; var curseForgeMods = new Mods(\"your-api-key\"); // 搜索 Mod var searchResults = await curseForgeMods.SearchAsync(\"sodium\", \"1.20.1\"); // 获取 Mod 详情 var modDetails = await curseForgeMods.GetModDetailsAsync(\"sodium\"); // 下载 Mod await curseForgeMods.DownloadModAsync(\"sodium\", \"0.4.14\", @\"C:\\Game\\.minecraft\\mods\\sodium.jar\"); 4. 游戏启动 using Qomicex.Core.Modules.Launcher; var launcher = new Launcher(); var launchParams = new LauncherParam { GameDir = @\"C:\\Game\\.minecraft\", Version = \"1.20.1\", JavaPath = @\"C:\\Program Files\\Java\\jre-17\\bin\\javaw.exe\", MaxMemory = 4096, MinMemory = 1024, WindowWidth = 1280, WindowHeight = 720, Fullscreen = false, Server = null, Username = \"Player\", AuthenticationToken = \"your-auth-token\" }; // 启动游戏 var result = await launcher.StartGameAsync(launchParams); if (result) { Console.WriteLine(\"游戏启动成功！\"); } else { Console.WriteLine(\"游戏启动失败！\"); } 高级主题 自定义资源源 using Qomicex.Core.Modules.Helpers.Resources; // 创建自定义资源源 var customSource = new ResourceSource { Name = \"My Custom Source\", BaseUrl = \"https://my-custom-mirror.com/\", GameManifestUrl = \"https://my-custom-mirror.com/game_manifest.json\", LibraryUrl = \"https://my-custom-mirror.com/libraries/\", AssetUrl = \"https://my-custom-mirror.com/assets/\", VersionUrl = \"https://my-custom-mirror.com/versions/\" }; // 使用自定义资源源获取版本列表 var resourceHelper = new GameResourceHelper(customSource); var versions = await resourceHelper.GetMinecraftListAsync(); 扩展 Mod 支持 using Qomicex.Core.Modules.Helpers.Installers; public class MyCustomModLoaderInstaller : InstallerBase { public override Task<bool> InstallAsync( string versionId, string inheritsFromJson, string? para1, string? para2, string? para3, string? para4 ) { // 实现自定义 Mod 加载器的安装逻辑 return Task.FromResult(true); } } // 使用自定义安装器 var customInstaller = new MyCustomModLoaderInstaller(); await customInstaller.InstallAsync( \"1.20.1-mycustomloader-1.0\", null, \"1.0\", \"1.20.1\", null, null ); 自定义启动参数 using Qomicex.Core.Modules.Launcher; var launchParams = new LauncherParam { GameDir = @\"C:\\Game\\.minecraft\", Version = \"1.20.1\", JavaPath = @\"C:\\Program Files\\Java\\jre-17\\bin\\javaw.exe\", MaxMemory = 4096, MinMemory = 1024, // 自定义 JVM 参数 JvmArgs = new List<string> { \"-XX:+UseG1GC\", \"-XX:G1HeapRegionSize=4M\", \"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompressedOops\" }, // 自定义游戏参数 GameArgs = new List<string> { \"--fullscreen\", \"--server\", \"mc.hypixel.net\", \"--port\", \"25565\" } }; 常见问题 1. 游戏启动失败 问题：游戏无法正常启动，提示找不到 Java 路径。 解决方案： using Qomicex.Core.Modules.Helpers; var javaHelper = new JavaHelper(); // 搜索系统中的 Java var javaLocations = await javaHelper.SearchForJavaAsync(); if (javaLocations.Any()) { var firstJava = javaLocations.First(); var launchParams = new LauncherParam { JavaPath = firstJava.Path, // 其他参数... }; } else { Console.WriteLine(\"未找到 Java 运行时，请确保已安装 Java。\"); } 2. 资源下载失败 问题：游戏资源或 Mod 无法下载，网络连接失败。 解决方案： using Qomicex.Core.Modules.Helpers.Resources; var downloader = new ResourceDownloader(); downloader.MaxRetries = 3; // 增加重试次数 downloader.Timeout = TimeSpan.FromMinutes(5); // 增加超时时间 try { await downloader.DownloadGameResourcesAsync(\"1.20.1\", @\"C:\\Game\\.minecraft\"); } catch (Exception ex) { Console.WriteLine($\"下载失败: {ex.Message}\"); Console.WriteLine(\"请检查网络连接或尝试使用其他资源源。\"); } 性能优化 1. 资源缓存策略 using Qomicex.Core.Modules.Helpers.Resources; // 配置资源缓存 var cacheOptions = new ResourceCacheOptions { MaxCacheSize = 10 * 1024 * 1024 * 1024, // 10GB CacheExpiration = TimeSpan.FromDays(7), // 缓存过期时间 UseDiskCache = true, // 启用磁盘缓存 CacheLocation = @\"C:\\Game\\.minecraft\\cache\" // 缓存位置 }; var resourceHelper = new GameResourceHelper(cacheOptions); // 使用缓存获取版本信息 var versions = await resourceHelper.GetMinecraftListAsync(1); 2. 并发下载优化 using Qomicex.Core.Modules.Helpers.Downloader; var downloader = new Downloader { MaxConcurrentDownloads = 8, // 并发下载数 ChunkSize = 4 * 1024 * 1024, // 分块大小 RetryCount = 3 // 重试次数 }; var downloadTasks = new List<Task> { downloader.DownloadAsync(\"http://example.com/file1.jar\", \"file1.jar\"), downloader.DownloadAsync(\"http://example.com/file2.jar\", \"file2.jar\"), downloader.DownloadAsync(\"http://example.com/file3.jar\", \"file3.jar\") }; await Task.WhenAll(downloadTasks); 贡献指南 我们欢迎开发者为 Qomicex.Core 项目做出贡献！以下是贡献步骤： Fork 项目：在 GitHub 上 Fork 项目到自己的仓库 克隆项目：克隆自己的仓库到本地 创建分支：创建一个新的分支用于开发 开发功能：实现新功能或修复 bug 编写测试：为新功能编写测试代码 提交修改：提交修改到本地仓库 创建 PR：在 GitHub 上创建 Pull Request 等待审核：等待项目维护者审核您的 PR 许可证 Qomicex.Core 项目采用 MIT 许可证，允许您自由地使用、修改和分发项目代码。详细信息请查看项目根目录下的 LICENSE 文件。 联系方式 项目仓库：https://github.com/TheMyceliumOfAntan/Qomicex.Avalonia 问题反馈：https://github.com/TheMyceliumOfAntan/Qomicex.Avalonia/issues 讨论交流：https://github.com/TheMyceliumOfAntan/Qomicex.Avalonia/discussions 其他资源 API 文档：http://localhost:8083/api/ 示例代码：https://github.com/TheMyceliumOfAntan/Qomicex.Avalonia/tree/main/Examples 变更日志：https://github.com/TheMyceliumOfAntan/Qomicex.Avalonia/blob/main/CHANGELOG.md"
  },
  "docs/Development/ResourceCompleter/README.html": {
    "href": "docs/Development/ResourceCompleter/README.html",
    "title": "资源补全器 | Qomicex.Core API文档",
    "summary": "资源补全器 在 Qomicex.Core 中，我们为开发者提供了用于补全 Minecraft 核心资源文件的补全器。这些资源包括：游戏音频、材质、贴图、语言文件、启动所必须的库文件等。 [[toc]] 资源补全器概述 资源补全器是 Qomicex.Core 提供的一个核心功能，它负责下载和管理 Minecraft 游戏所需的各种资源文件。资源补全器会根据游戏版本和 Mod 加载器类型自动判断需要下载哪些资源文件。 使用方法 基本用法 using Qomicex.Core.Modules.Helpers.Resources; // 创建资源补全器实例 var completer = new ResourceCompleter(@\"C:\\Games\\.minecraft\"); try { // 补全资源 var result = await completer.CompleteResourcesAsync(\"1.20.1\"); if (result.IsSuccess) { Console.WriteLine(\"资源补全成功！\"); Console.WriteLine($\"下载资源数: {result.DownloadedResources.Count}\"); Console.WriteLine($\"总大小: {result.TotalSize}\"); } else { Console.WriteLine($\"资源补全失败: {result.ErrorMessage}\"); } } catch (Exception ex) { Console.WriteLine($\"资源补全过程中发生错误: {ex.Message}\"); } 高级用法 using Qomicex.Core.Modules.Helpers.Resources; // 创建资源补全器实例 var completer = new ResourceCompleter(@\"C:\\Games\\.minecraft\"); // 配置补全选项 var options = new ResourceCompleteOptions { SourceType = DownloadSource.Official, // 下载源类型 DownloadProgressChanged = (sender, args) => { Console.WriteLine($\"下载进度: {args.ProgressPercentage}%\"); Console.WriteLine($\"已下载: {args.DownloadedSize} / {args.TotalSize}\"); }, ExtractionProgressChanged = (sender, args) => { Console.WriteLine($\"提取进度: {args.ProgressPercentage}%\"); Console.WriteLine($\"当前文件: {args.CurrentFile}\"); } }; try { // 补全资源 var result = await completer.CompleteResourcesAsync(\"1.20.1\", options); if (result.IsSuccess) { Console.WriteLine(\"资源补全成功！\"); Console.WriteLine($\"下载资源数: {result.DownloadedResources.Count}\"); Console.WriteLine($\"总大小: {result.TotalSize}\"); } else { Console.WriteLine($\"资源补全失败: {result.ErrorMessage}\"); } } catch (Exception ex) { Console.WriteLine($\"资源补全过程中发生错误: {ex.Message}\"); } 资源补全结果 资源补全器会返回一个详细的补全结果对象： public class ResourceCompleteResult { public bool IsSuccess { get; set; } public List<string> DownloadedResources { get; set; } public List<string> ExtractedFiles { get; set; } public long TotalSize { get; set; } public string ErrorMessage { get; set; } } 资源类型 游戏核心资源 using Qomicex.Core.Modules.Helpers.Resources; var completer = new ResourceCompleter(@\"C:\\Games\\.minecraft\"); // 补全游戏核心资源 var result = await completer.CompleteCoreResourcesAsync(\"1.20.1\"); 材质资源 using Qomicex.Core.Modules.Helpers.Resources; var completer = new ResourceCompleter(@\"C:\\Games\\.minecraft\"); // 补全材质资源 var result = await completer.CompleteAssetResourcesAsync(\"1.20.1\"); 库文件资源 using Qomicex.Core.Modules.Helpers.Resources; var completer = new ResourceCompleter(@\"C:\\Games\\.minecraft\"); // 补全库文件资源 var result = await completer.CompleteLibraryResourcesAsync(\"1.20.1\"); 语言文件资源 using Qomicex.Core.Modules.Helpers.Resources; var completer = new ResourceCompleter(@\"C:\\Games\\.minecraft\"); // 补全语言文件资源 var result = await completer.CompleteLanguageResourcesAsync(\"1.20.1\", \"zh_cn\"); 资源验证 您可以使用资源验证功能来检查已下载的资源是否完整： using Qomicex.Core.Modules.Helpers.Resources; var completer = new ResourceCompleter(@\"C:\\Games\\.minecraft\"); // 验证资源 var validationResult = await completer.ValidateResourcesAsync(\"1.20.1\"); if (validationResult.IsValid) { Console.WriteLine(\"资源验证成功！\"); } else { Console.WriteLine($\"资源验证失败: {validationResult.ErrorMessage}\"); // 列出所有验证问题 foreach (var issue in validationResult.Issues) { Console.WriteLine($\"问题: {issue.Description} ({issue.Severity})\"); } } 资源下载选项 下载源配置 using Qomicex.Core.Modules.Helpers.Resources; // 使用 BMCLAPI 下载源 var options = new ResourceCompleteOptions { SourceType = DownloadSource.Bmclapi }; var completer = new ResourceCompleter(@\"C:\\Games\\.minecraft\"); var result = await completer.CompleteResourcesAsync(\"1.20.1\", options); 下载进度监控 using Qomicex.Core.Modules.Helpers.Resources; var options = new ResourceCompleteOptions { DownloadProgressChanged = (sender, args) => { Console.WriteLine($\"文件: {args.FileName}\"); Console.WriteLine($\"进度: {args.ProgressPercentage}%\"); Console.WriteLine($\"速度: {args.DownloadSpeed} KB/s\"); Console.WriteLine($\"已下载: {args.DownloadedSize} / {args.TotalSize}\"); } }; var completer = new ResourceCompleter(@\"C:\\Games\\.minecraft\"); var result = await completer.CompleteResourcesAsync(\"1.20.1\", options); 文件提取进度监控 using Qomicex.Core.Modules.Helpers.Resources; var options = new ResourceCompleteOptions { ExtractionProgressChanged = (sender, args) => { Console.WriteLine($\"文件: {args.CurrentFile}\"); Console.WriteLine($\"进度: {args.ProgressPercentage}%\"); Console.WriteLine($\"提取文件数: {args.ExtractedFiles} / {args.TotalFiles}\"); } }; var completer = new ResourceCompleter(@\"C:\\Games\\.minecraft\"); var result = await completer.CompleteResourcesAsync(\"1.20.1\", options); 资源缓存 启用资源缓存 using Qomicex.Core.Modules.Helpers.Resources; var options = new ResourceCompleteOptions { EnableCache = true, CacheLocation = @\"C:\\Games\\.minecraft\\cache\", CacheDuration = TimeSpan.FromDays(7) }; var completer = new ResourceCompleter(@\"C:\\Games\\.minecraft\"); var result = await completer.CompleteResourcesAsync(\"1.20.1\", options); 清除资源缓存 using Qomicex.Core.Modules.Helpers.Resources; var completer = new ResourceCompleter(@\"C:\\Games\\.minecraft\"); // 清除所有缓存 await completer.ClearCacheAsync(); // 清除特定版本的缓存 await completer.ClearCacheAsync(\"1.20.1\"); 资源修复 如果资源文件损坏或缺失，您可以使用资源修复功能： using Qomicex.Core.Modules.Helpers.Resources; var completer = new ResourceCompleter(@\"C:\\Games\\.minecraft\"); // 修复资源 var repairResult = await completer.RepairResourcesAsync(\"1.20.1\"); if (repairResult.IsSuccess) { Console.WriteLine(\"资源修复成功！\"); Console.WriteLine($\"修复资源数: {repairResult.RepairedResources.Count}\"); } else { Console.WriteLine($\"资源修复失败: {repairResult.ErrorMessage}\"); } 资源检查 检查资源完整性 using Qomicex.Core.Modules.Helpers.Resources; var completer = new ResourceCompleter(@\"C:\\Games\\.minecraft\"); // 检查资源完整性 var checkResult = await completer.CheckResourceIntegrityAsync(\"1.20.1\"); if (checkResult.IsComplete) { Console.WriteLine(\"所有资源文件完整！\"); } else { Console.WriteLine($\"缺少以下资源文件: {string.Join(\", \", checkResult.MissingResources)}\"); } 检查资源更新 using Qomicex.Core.Modules.Helpers.Resources; var completer = new ResourceCompleter(@\"C:\\Games\\.minecraft\"); // 检查资源更新 var updateResult = await completer.CheckResourceUpdatesAsync(\"1.20.1\"); if (updateResult.HasUpdates) { Console.WriteLine($\"有 {updateResult.UpdateCount} 个资源文件需要更新\"); // 更新资源 var result = await completer.UpdateResourcesAsync(\"1.20.1\"); if (result.IsSuccess) Console.WriteLine(\"资源更新成功！\"); } else { Console.WriteLine(\"资源已经是最新版本！\"); } 资源管理 获取资源信息 using Qomicex.Core.Modules.Helpers.Resources; var completer = new ResourceCompleter(@\"C:\\Games\\.minecraft\"); // 获取资源信息 var resourceInfo = await completer.GetResourceInfoAsync(\"1.20.1\"); Console.WriteLine($\"资源版本: {resourceInfo.Version}\"); Console.WriteLine($\"资源类型: {resourceInfo.Type}\"); Console.WriteLine($\"资源大小: {resourceInfo.Size}\"); Console.WriteLine($\"资源数量: {resourceInfo.Count}\"); 导出资源 using Qomicex.Core.Modules.Helpers.Resources; var completer = new ResourceCompleter(@\"C:\\Games\\.minecraft\"); // 导出资源 var exportResult = await completer.ExportResourcesAsync(\"1.20.1\", @\"C:\\Temp\\MinecraftResources\"); if (exportResult.IsSuccess) { Console.WriteLine($\"资源导出成功！导出路径: {exportResult.ExportPath}\"); } else { Console.WriteLine($\"资源导出失败: {exportResult.ErrorMessage}\"); } 导入资源 using Qomicex.Core.Modules.Helpers.Resources; var completer = new ResourceCompleter(@\"C:\\Games\\.minecraft\"); // 导入资源 var importResult = await completer.ImportResourcesAsync(\"1.20.1\", @\"C:\\Temp\\MinecraftResources\"); if (importResult.IsSuccess) { Console.WriteLine($\"资源导入成功！导入资源数: {importResult.ImportedResources.Count}\"); } else { Console.WriteLine($\"资源导入失败: {importResult.ErrorMessage}\"); } 常见问题 资源下载失败 如果资源下载失败，可以检查以下几个方面： 网络连接是否正常 下载源是否可用 磁盘空间是否充足 游戏目录是否有写入权限 防火墙是否阻止了下载请求 资源验证失败 如果资源验证失败，可以检查： 资源文件是否被病毒扫描程序损坏 磁盘是否有坏道 文件权限是否正确 是否有其他程序正在使用该文件 资源提取失败 如果资源提取失败，可以检查： 归档文件是否完整 归档文件是否被加密 磁盘空间是否充足 磁盘是否有坏道 资源不完整 如果资源不完整，可以尝试： 重新补全资源 使用修复功能 检查网络连接 检查磁盘空间"
  },
  "docs/Expansion/CurseForge/README.html": {
    "href": "docs/Expansion/CurseForge/README.html",
    "title": "CurseForge 资源管理 | Qomicex.Core API文档",
    "summary": "CurseForge 资源管理 功能概述 CurseForge 模块提供了对 CurseForge 资源平台的完整访问支持，包括资源搜索、获取详情、下载等功能。 支持的资源类型 Mods Mods 是最常见的资源类型，增强或修改 Minecraft 的功能。 using Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge; var curseForgeMods = new Mods(\"your-api-key\"); Modpacks Modpacks 是预配置的模组组合，提供完整的游戏体验。 using Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge; var curseForgeModpacks = new Modpacks(\"your-api-key\"); ResourcePacks ResourcePacks 改变游戏的视觉效果，包括材质、纹理等。 using Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge; var curseForgeResourcePacks = new ResourcePacks(\"your-api-key\"); DataPacks DataPacks 改变游戏规则和行为，包括合成配方、进度系统等。 using Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge; var curseForgeDataPacks = new DataPacks(\"your-api-key\"); Shaders Shaders 增强游戏的图形效果，包括光照、阴影等。 using Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge; var curseForgeShaders = new Shaders(\"your-api-key\"); Worlds Worlds 提供自定义游戏世界，包括生存地图、冒险地图等。 using Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge; var curseForgeWorlds = new Worlds(\"your-api-key\"); 资源搜索 基础搜索 using Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge; var curseForgeMods = new Mods(\"your-api-key\"); var searchResults = await curseForgeMods.SearchAsync(\"sodium\"); foreach (var result in searchResults) { Console.WriteLine($\"Mod 名称: {result.Name}\"); Console.WriteLine($\"作者: {string.Join(\", \", result.Authors.Select(a => a.Name))}\"); Console.WriteLine($\"下载次数: {result.DownloadCount}\"); Console.WriteLine($\"简介: {result.Summary}\"); Console.WriteLine(); } 高级搜索 using Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge; var curseForgeMods = new Mods(\"your-api-key\"); var searchResults = await curseForgeMods.SearchAsync( \"sodium\", gameVersion: \"1.20.1\", modLoaderType: ModLoaderType.Fabric, sortField: SortField.Popularity, page: 0, pageSize: 20 ); 资源详情获取 获取资源详细信息 using Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge; var curseForgeMods = new Mods(\"your-api-key\"); var modDetails = await curseForgeMods.GetModDetailsAsync(\"sodium\"); Console.WriteLine($\"Mod 名称: {modDetails.Name}\"); Console.WriteLine($\"作者: {string.Join(\", \", modDetails.Authors.Select(a => a.Name))}\"); Console.WriteLine($\"描述: {modDetails.Description}\"); Console.WriteLine($\"下载次数: {modDetails.DownloadCount}\"); Console.WriteLine($\"最新版本: {modDetails.LatestVersion}\"); // 获取所有版本 var versions = await curseForgeMods.GetModVersionsAsync(\"sodium\"); Console.WriteLine($\"可用版本数量: {versions.Count}\"); foreach (var version in versions.Take(5)) { Console.WriteLine($\" - 版本: {version.Version} ({version.GameVersion})\"); Console.WriteLine($\" 文件大小: {version.FileSize} KB\"); Console.WriteLine($\" 下载链接: {version.DownloadUrl}\"); } 资源下载 下载最新版本 using Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge; var curseForgeMods = new Mods(\"your-api-key\"); string modId = \"sodium\"; // 获取最新版本信息 var modDetails = await curseForgeMods.GetModDetailsAsync(modId); var latestVersion = modDetails.LatestVersion; // 下载资源 string savePath = @\"C:\\Downloads\\Sodium-\" + latestVersion + \".jar\"; bool downloadSuccess = await curseForgeMods.DownloadModAsync(modId, latestVersion, savePath); if (downloadSuccess) { Console.WriteLine($\"Mod 下载成功: {savePath}\"); } else { Console.WriteLine(\"Mod 下载失败\"); } 下载特定版本 using Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge; var curseForgeMods = new Mods(\"your-api-key\"); string modId = \"sodium\"; string version = \"0.4.14\"; string savePath = @\"C:\\Downloads\\Sodium-\" + version + \".jar\"; bool downloadSuccess = await curseForgeMods.DownloadModAsync(modId, version, savePath); if (downloadSuccess) { Console.WriteLine($\"Mod 下载成功: {savePath}\"); } else { Console.WriteLine(\"Mod 下载失败\"); } 依赖处理 解析和下载依赖 using Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge; var curseForgeMods = new Mods(\"your-api-key\"); string modId = \"sodium\"; // 获取 Mod 详情 var modDetails = await curseForgeMods.GetModDetailsAsync(modId); // 获取依赖列表 var dependencies = await curseForgeMods.GetModDependenciesAsync(modId); Console.WriteLine($\"{modId} 的依赖项:\"); foreach (var dependency in dependencies) { Console.WriteLine($\" - {dependency.Name} (版本: {dependency.Version})\"); // 下载依赖项 string savePath = $@\"C:\\Downloads\\{dependency.Name}-{dependency.Version}.jar\"; bool downloadSuccess = await curseForgeMods.DownloadModAsync(dependency.Id, dependency.Version, savePath); if (downloadSuccess) { Console.WriteLine($\" 下载成功: {savePath}\"); } else { Console.WriteLine($\" 下载失败: {dependency.Name}\"); } } 配置选项 设置自定义下载源 using Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge; var curseForgeMods = new Mods(\"your-api-key\"); // 设置自定义下载源（可选） curseForgeMods.SetDownloadSource(\"https://your-custom-mirror.com/\"); // 下载资源 await curseForgeMods.DownloadModAsync(\"sodium\", \"0.4.14\", @\"C:\\Downloads\\Sodium.jar\"); 调整请求超时 using Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge; var curseForgeMods = new Mods(\"your-api-key\"); // 调整请求超时（默认10秒） curseForgeMods.SetRequestTimeout(TimeSpan.FromSeconds(30)); // 搜索资源 var results = await curseForgeMods.SearchAsync(\"sodium\"); 错误处理 using Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge; var curseForgeMods = new Mods(\"your-api-key\"); try { var searchResults = await curseForgeMods.SearchAsync(\"sodium\"); Console.WriteLine($\"找到 {searchResults.Count} 个结果\"); } catch (ApiException ex) { Console.WriteLine($\"API 错误: {ex.Message}\"); Console.WriteLine($\"状态码: {ex.StatusCode}\"); } catch (RateLimitException ex) { Console.WriteLine($\"请求限流: {ex.Message}\"); Console.WriteLine($\"重试时间: {ex.RetryAfter}\"); } catch (Exception ex) { Console.WriteLine($\"错误: {ex.Message}\"); } 最佳实践 API密钥管理：确保 API 密钥的安全存储和使用 错误处理：实现适当的错误处理和重试机制 缓存策略：对搜索结果和资源信息实现缓存 并发控制：对大量下载和搜索操作实现适当的并发控制 请求限流：遵守平台的请求限制，避免被封禁"
  },
  "docs/Expansion/Modrinth/README.html": {
    "href": "docs/Expansion/Modrinth/README.html",
    "title": "Modrinth 资源管理 | Qomicex.Core API文档",
    "summary": "Modrinth 资源管理 功能概述 Modrinth 模块提供了对 Modrinth 资源平台的完整访问支持，包括资源搜索、获取详情、下载等功能。Modrinth 是一个开源的 Minecraft 资源平台，专注于现代 Mod 生态系统。 支持的资源类型 Mods Mods 是最常见的资源类型，增强或修改 Minecraft 的功能。 using Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth; var modrinthMods = new Mods(); Modpacks Modpacks 是预配置的模组组合，提供完整的游戏体验。 using Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth; var modrinthModpacks = new ModPacks(); ResourcePacks ResourcePacks 改变游戏的视觉效果，包括材质、纹理等。 using Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth; var modrinthResourcePacks = new ResourcePacks(); DataPacks DataPacks 改变游戏规则和行为，包括合成配方、进度系统等。 using Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth; var modrinthDataPacks = new DataPacks(); Shaders Shaders 增强游戏的图形效果，包括光照、阴影等。 using Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth; var modrinthShaders = new Shaders(); Worlds Worlds 提供自定义游戏世界，包括生存地图、冒险地图等。 using Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth; var modrinthWorlds = new Worlds(); 资源搜索 基础搜索 using Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth; var modrinthMods = new Mods(); var searchResults = await modrinthMods.SearchAsync(\"sodium\"); foreach (var result in searchResults) { Console.WriteLine($\"Mod 名称: {result.Name}\"); Console.WriteLine($\"作者: {string.Join(\", \", result.Authors)}\"); Console.WriteLine($\"下载次数: {result.DownloadCount}\"); Console.WriteLine($\"简介: {result.Summary}\"); Console.WriteLine(); } 高级搜索 using Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth; var modrinthMods = new Mods(); var searchResults = await modrinthMods.SearchAsync( \"sodium\", gameVersion: \"1.20.1\", loaders: new[] { \"fabric\" }, categories: new[] { \"optimization\" }, index: Index.Popularity, page: 0, pageSize: 20 ); 资源详情获取 获取资源详细信息 using Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth; var modrinthMods = new Mods(); var modDetails = await modrinthMods.GetModDetailsAsync(\"AANobbMI\"); Console.WriteLine($\"Mod 名称: {modDetails.Name}\"); Console.WriteLine($\"作者: {string.Join(\", \", modDetails.Authors)}\"); Console.WriteLine($\"描述: {modDetails.Description}\"); Console.WriteLine($\"下载次数: {modDetails.DownloadCount}\"); Console.WriteLine($\"最新版本: {modDetails.LatestVersion}\"); // 获取所有版本 var versions = await modrinthMods.GetModVersionsAsync(\"AANobbMI\"); Console.WriteLine($\"可用版本数量: {versions.Count}\"); foreach (var version in versions.Take(5)) { Console.WriteLine($\" - 版本: {version.Version} ({version.GameVersion})\"); Console.WriteLine($\" 文件大小: {version.FileSize} KB\"); Console.WriteLine($\" 下载链接: {version.DownloadUrl}\"); } 资源下载 下载最新版本 using Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth; var modrinthMods = new Mods(); string modId = \"AANobbMI\"; // Sodium 的 Modrinth ID // 获取最新版本信息 var modDetails = await modrinthMods.GetModDetailsAsync(modId); var latestVersion = modDetails.LatestVersion; // 下载资源 string savePath = @\"C:\\Downloads\\Sodium-\" + latestVersion + \".jar\"; bool downloadSuccess = await modrinthMods.DownloadModAsync(modId, latestVersion, savePath); if (downloadSuccess) { Console.WriteLine($\"Mod 下载成功: {savePath}\"); } else { Console.WriteLine(\"Mod 下载失败\"); } 下载特定版本 using Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth; var modrinthMods = new Mods(); string modId = \"AANobbMI\"; // Sodium 的 Modrinth ID string version = \"0.4.14\"; string savePath = @\"C:\\Downloads\\Sodium-\" + version + \".jar\"; bool downloadSuccess = await modrinthMods.DownloadModAsync(modId, version, savePath); if (downloadSuccess) { Console.WriteLine($\"Mod 下载成功: {savePath}\"); } else { Console.WriteLine(\"Mod 下载失败\"); } 依赖处理 解析和下载依赖 using Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth; var modrinthMods = new Mods(); string modId = \"AANobbMI\"; // Sodium 的 Modrinth ID // 获取 Mod 详情 var modDetails = await modrinthMods.GetModDetailsAsync(modId); // 获取依赖列表 var dependencies = await modrinthMods.GetModDependenciesAsync(modId); Console.WriteLine($\"{modId} 的依赖项:\"); foreach (var dependency in dependencies) { Console.WriteLine($\" - {dependency.Name} (版本: {dependency.Version})\"); // 下载依赖项 string savePath = $@\"C:\\Downloads\\{dependency.Name}-{dependency.Version}.jar\"; bool downloadSuccess = await modrinthMods.DownloadModAsync(dependency.Id, dependency.Version, savePath); if (downloadSuccess) { Console.WriteLine($\" 下载成功: {savePath}\"); } else { Console.WriteLine($\" 下载失败: {dependency.Name}\"); } } 配置选项 设置自定义下载源 using Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth; var modrinthMods = new Mods(); // 设置自定义下载源（可选） modrinthMods.SetDownloadSource(\"https://your-custom-mirror.com/\"); // 下载资源 await modrinthMods.DownloadModAsync(\"AANobbMI\", \"0.4.14\", @\"C:\\Downloads\\Sodium.jar\"); 调整请求超时 using Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth; var modrinthMods = new Mods(); // 调整请求超时（默认10秒） modrinthMods.SetRequestTimeout(TimeSpan.FromSeconds(30)); // 搜索资源 var results = await modrinthMods.SearchAsync(\"sodium\"); 错误处理 using Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth; var modrinthMods = new Mods(); try { var searchResults = await modrinthMods.SearchAsync(\"sodium\"); Console.WriteLine($\"找到 {searchResults.Count} 个结果\"); } catch (ApiException ex) { Console.WriteLine($\"API 错误: {ex.Message}\"); Console.WriteLine($\"状态码: {ex.StatusCode}\"); } catch (RateLimitException ex) { Console.WriteLine($\"请求限流: {ex.Message}\"); Console.WriteLine($\"重试时间: {ex.RetryAfter}\"); } catch (Exception ex) { Console.WriteLine($\"错误: {ex.Message}\"); } 最佳实践 API 调用频率：Modrinth API 有请求限制，建议实现适当的缓存 错误处理：实现适当的错误处理和重试机制 缓存策略：对搜索结果和资源信息实现缓存 并发控制：对大量下载和搜索操作实现适当的并发控制 资源版本管理：确保下载的资源与 Minecraft 版本兼容 资源元数据 Modrinth 资源包含丰富的元数据： using Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth; var modrinthMods = new Mods(); var modDetails = await modrinthMods.GetModDetailsAsync(\"AANobbMI\"); Console.WriteLine(\"资源元数据:\"); Console.WriteLine($\"ID: {modDetails.Id}\"); Console.WriteLine($\"Slug: {modDetails.Slug}\"); Console.WriteLine($\"许可证: {modDetails.License}\"); Console.WriteLine($\"项目主页: {modDetails.Homepage}\"); Console.WriteLine($\"源代码: {modDetails.SourceCode}\"); Console.WriteLine($\"问题追踪: {modDetails.IssueTracker}\"); Console.WriteLine($\"Discord: {modDetails.Discord}\"); Console.WriteLine($\"下载总数: {modDetails.DownloadCount}\"); Console.WriteLine($\"创建时间: {modDetails.CreatedAt}\"); Console.WriteLine($\"更新时间: {modDetails.UpdatedAt}\"); Console.WriteLine($\"标签: {string.Join(\", \", modDetails.Tags)}\"); 批量操作 批量获取资源详情 using Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth; var modrinthMods = new Mods(); var modIds = new[] { \"AANobbMI\", \"P7dR8mSH\", \"Mr4mRFp7\" }; // Sodium, Lithium, Phosphor var modDetailsList = new List<ModDetails>(); foreach (var modId in modIds) { try { var details = await modrinthMods.GetModDetailsAsync(modId); modDetailsList.Add(details); } catch (Exception ex) { Console.WriteLine($\"获取资源 {modId} 详情失败: {ex.Message}\"); } } // 处理结果 foreach (var details in modDetailsList) { Console.WriteLine($\"资源: {details.Name}\"); Console.WriteLine($\"作者: {string.Join(\", \", details.Authors)}\"); Console.WriteLine($\"下载次数: {details.DownloadCount}\"); Console.WriteLine(); }"
  },
  "docs/Expansion/README.html": {
    "href": "docs/Expansion/README.html",
    "title": "扩展资源管理 | Qomicex.Core API文档",
    "summary": "扩展资源管理 功能概述 Expansion 模块提供了对第三方资源平台的集成支持，目前包括两个主要平台： CurseForge - 最大的 Minecraft 资源分享平台，提供 Mod、纹理包、地图等资源 Modrinth - 开源的 Minecraft 资源平台，专注于现代 Mod 生态系统 这些模块允许应用程序直接从这些平台搜索、获取和管理 Minecraft 相关资源。 平台支持 CurseForge 资源类型：Mod、Modpack、纹理包、数据包、光影包、地图 API支持：完整的搜索、获取和下载功能 认证方式：API Key 认证 使用场景：需要访问大量资源的启动器或管理工具 Modrinth 资源类型：Mod、Modpack、纹理包、数据包、光影包、地图 API支持：搜索、获取和下载功能 认证方式：无密钥认证（公开API） 使用场景：需要开源和现代资源的应用程序 基本架构 Expansion 模块采用抽象设计，允许轻松添加新的资源平台支持。每个平台实现都继承自统一的接口，提供一致的访问方式。 使用示例 初始化 CurseForge 平台 using Qomicex.Core.Modules.Helpers.Resources.Expansion.CurseForge; string apiKey = \"your-curseforge-api-key\"; var curseForge = new Mods(apiKey); // 或者直接使用特定资源类型 var modpacks = new Modpacks(apiKey); var resourcePacks = new ResourcePacks(apiKey); 初始化 Modrinth 平台 using Qomicex.Core.Modules.Helpers.Resources.Expansion.Modrinth; var modrinth = new Mods(); // 或者直接使用特定资源类型 var modpacks = new ModPacks(); var resourcePacks = new ResourcePacks(); 资源类型说明 所有资源平台支持以下资源类型： Mods - 游戏模组，增强或修改 Minecraft 的功能 Modpacks - 预配置的模组组合，提供完整的游戏体验 ResourcePacks - 纹理包，改变游戏的视觉效果 DataPacks - 数据包，改变游戏规则和行为 Shaders - 光影包，增强游戏的图形效果 Worlds - 存档地图，提供自定义游戏世界 通用功能 每个资源平台都提供以下通用功能： 搜索 - 根据关键词、分类、版本等条件搜索资源 详情获取 - 获取资源的详细信息、作者、版本等 下载 - 下载资源文件 版本管理 - 获取资源的不同版本信息 依赖处理 - 解析和获取资源的依赖项 最佳实践 API密钥管理：对于 CurseForge，确保妥善管理 API 密钥，避免硬编码 错误处理：实现适当的错误处理和重试机制 缓存策略：对搜索结果和资源信息实现缓存，减少 API 调用 并发控制：对大量下载和搜索操作实现适当的并发控制"
  },
  "docs/GameResourceHelper/README.html": {
    "href": "docs/GameResourceHelper/README.html",
    "title": "游戏资源管理 | Qomicex.Core API文档",
    "summary": "游戏资源管理 功能概述 GameResourceHelper 提供了 Minecraft 游戏版本列表获取、版本信息解析等功能，支持官方源和 BMCLAPI 源。 使用示例 using Qomicex.Core.Modules.Helpers.Resources; // 创建游戏资源助手实例 var gameHelper = new GameResourceHelper(); // 获取 Minecraft 版本列表（官方源） List<GameResourceHelper.VersionInfo> officialVersions = await gameHelper.GetMinecraftListAsync(1); foreach (var version in officialVersions) { Console.WriteLine($\"版本 ID: {version.Id}\"); Console.WriteLine($\"类型: {version.Type}\"); Console.WriteLine($\"发布时间: {version.ReleaseTime}\"); Console.WriteLine($\"信息 URL: {version.Url}\"); Console.WriteLine(); } // 获取 Minecraft 版本列表（BMCLAPI 源） List<GameResourceHelper.VersionInfo> bmclapiVersions = await gameHelper.GetMinecraftListAsync(0); // 获取版本详细信息 dynamic versionManifest = await gameHelper.GetMinecraftVersionManifest(1); string latestRelease = versionManifest?.latest?.release; string latestSnapshot = versionManifest?.latest?.snapshot; Console.WriteLine($\"最新正式版: {latestRelease}\"); Console.WriteLine($\"最新快照版: {latestSnapshot}\");"
  },
  "docs/GeneralHelper/README.html": {
    "href": "docs/GeneralHelper/README.html",
    "title": "通用工具 | Qomicex.Core API文档",
    "summary": "通用工具 功能概述 GeneralHelper 提供了各种通用工具方法，包括 Mod 加载器检测、文件操作、加密/解密等。 使用示例 using Qomicex.Core.Modules.Helpers; // 检测版本文件中的 Mod 加载器类型 string gameDir = @\"C:\\Game\\.minecraft\"; string versionId = \"1.20.1-forge-47.1.3\"; string[] modLoaders = new GeneralHelper().GetModLoaderType(versionId, gameDir); // 输出示例：[\"Forge 47.1.3\"] // 从 ZIP 文件中读取指定文件 string jarPath = @\"C:\\Game\\.minecraft\\versions\\1.20.1\\1.20.1.jar\"; string manifest = GeneralHelper.ReadSpecifyFileFromZip(jarPath, \"META-INF/MANIFEST.MF\"); // 验证文件哈希 string filePath = @\"C:\\Game\\.minecraft\\versions\\1.20.1\\1.20.1.jar\"; string expectedSha1 = \"abc123...\"; bool isValid = GeneralHelper.VerifyFileChecksum(filePath, expectedSha1, HashAlgorithmName.SHA1); // 清理临时文件 GeneralHelper.ClearTempFiles(); // 转换文件大小格式 string sizeStr = GeneralHelper.FormatFileSize(1024 * 1024 * 100); // \"100 MB\""
  },
  "docs/Installers/README.html": {
    "href": "docs/Installers/README.html",
    "title": "安装器 | Qomicex.Core API文档",
    "summary": "安装器 功能概述 Qomicex.Core 提供了多种 Minecraft 模组加载器的安装器，包括 Forge、Fabric、Quilt、LiteLoader 和 OptiFine。所有安装器都实现了 IInstaller 接口。 使用示例 安装 Fabric using Qomicex.Core.Modules.Helpers.Installers; // 创建 Fabric 安装器实例 var fabricInstaller = new FabricInstaller((int)InstallerBase.DownloadSource.Official, @\"C:\\Game\\.minecraft\"); // 安装 Fabric 到指定版本 string versionId = \"1.20.1-fabric-0.14.24\"; string fabricVersion = \"0.14.24\"; string gameVersion = \"1.20.1\"; try { fabricInstaller.InstallAsync(versionId, null, fabricVersion, gameVersion, null, null); Console.WriteLine(\"Fabric 安装成功！\"); } catch (Exception ex) { Console.WriteLine($\"Fabric 安装失败: {ex.Message}\"); } 安装 Forge using Qomicex.Core.Modules.Helpers.Installers; // 创建 Forge 安装器实例 var forgeInstaller = new ForgeInstaller((int)InstallerBase.DownloadSource.Official, @\"C:\\Game\\.minecraft\"); // 安装 Forge 到指定版本 string versionId = \"1.20.1-forge-47.1.3\"; string forgeVersion = \"47.1.3\"; string gameVersion = \"1.20.1\"; string installerPath = @\"C:\\Downloads\\forge-1.20.1-47.1.3-installer.jar\"; try { forgeInstaller.InstallAsync(versionId, null, forgeVersion, gameVersion, installerPath, null); Console.WriteLine(\"Forge 安装成功！\"); } catch (Exception ex) { Console.WriteLine($\"Forge 安装失败: {ex.Message}\"); } 安装 Quilt using Qomicex.Core.Modules.Helpers.Installers; // 创建 Quilt 安装器实例 var quiltInstaller = new QuiltInstaller((int)InstallerBase.DownloadSource.Official, @\"C:\\Game\\.minecraft\"); // 安装 Quilt 到指定版本 string versionId = \"1.20.1-quilt-0.18.10\"; string quiltVersion = \"0.18.10\"; string gameVersion = \"1.20.1\"; try { quiltInstaller.InstallAsync(versionId, null, quiltVersion, gameVersion, null, null); Console.WriteLine(\"Quilt 安装成功！\"); } catch (Exception ex) { Console.WriteLine($\"Quilt 安装失败: {ex.Message}\"); }"
  },
  "docs/JavaHelper/README.html": {
    "href": "docs/JavaHelper/README.html",
    "title": "Java 管理 | Qomicex.Core API文档",
    "summary": "Java 管理 功能概述 JavaHelper 提供了 Java 运行时检测、搜索和验证功能，支持快速搜索、深度搜索和自定义搜索。 使用示例 using Qomicex.Core.Modules.Helpers; // 快速搜索 Java 运行时 List<JavaHelper.JavaInfoExtended> quickResults = JavaHelper.SearchForJavaAsync(JavaHelper.QuickOptions).Result; foreach (var javaInfo in quickResults) { Console.WriteLine($\"Java 版本: {javaInfo.Version}\"); Console.WriteLine($\"路径: {javaInfo.Path}\"); Console.WriteLine($\"状态: {javaInfo.State}\"); } // 自定义搜索选项 var customOptions = new JavaHelper.JavaSearchOptions { Mode = JavaHelper.JavaSearchMode.Deep, GameDir = @\"C:\\Game\\.minecraft\", IncludeJRE = true, IncludeJDK = false, MaxDepth = 3, MaxResults = 20, ScanHiddenFolders = false, IncludeNetworkDrives = false, CustomRootPath = @\"C:\\Program Files\\Java\" }; List<JavaHelper.JavaInfoExtended> customResults = JavaHelper.SearchForJavaAsync(customOptions).Result; // 验证 Java 路径 var validationResult = JavaHelper.ValidateJavaPath(@\"C:\\Program Files\\Java\\jre1.8.0_311\"); Console.WriteLine($\"Java 验证状态: {validationResult.State}\"); if (!validationResult.IsValid) { Console.WriteLine($\"错误信息: {validationResult.StateMessage}\"); } // 获取推荐的 Java 版本 var recommendedJava = JavaHelper.GetRecommendedJavaVersion(\"1.20.1\"); Console.WriteLine($\"推荐 Java 版本: {recommendedJava}\");"
  },
  "docs/Launcher/README.html": {
    "href": "docs/Launcher/README.html",
    "title": "启动器 | Qomicex.Core API文档",
    "summary": "启动器 功能概述 Launcher 模块提供了 Minecraft 游戏启动功能，包括启动参数配置、游戏启动过程管理等。 使用示例 using Qomicex.Core.Modules.Launcher; using Qomicex.Core.Modules.Launcher.Launcher; // 创建启动器实例 var launcher = new Launcher(); // 配置启动参数 var launchParams = new LauncherParam { GameDir = @\"C:\\Game\\.minecraft\", Version = \"1.20.1-fabric-0.14.24\", JavaPath = @\"C:\\Program Files\\Java\\jre1.8.0_311\\bin\\javaw.exe\", MaxMemory = 4096, // 4GB MinMemory = 1024, // 1GB WindowWidth = 854, WindowHeight = 480, Fullscreen = false, Server = null, // 单机游戏 Username = \"PlayerName\", AuthenticationToken = \"your-auth-token\" }; // 启动 Minecraft var launchResult = launcher.StartGameAsync(launchParams); // 监听启动事件 launcher.OnGameStarted += () => Console.WriteLine(\"游戏启动成功！\"); launcher.OnGameError += (error) => Console.WriteLine($\"游戏启动失败: {error}\"); // 停止游戏 // launcher.StopGame();"
  },
  "docs/LocalResourceHelper/README.html": {
    "href": "docs/LocalResourceHelper/README.html",
    "title": "本地资源管理 | Qomicex.Core API文档",
    "summary": "本地资源管理 功能概述 LocalResourceHelper 负责 Minecraft 本地资源的管理，包括库文件检查、资源下载、版本合并等。 使用示例 using Qomicex.Core.Modules.Helpers.Resources; // 检查版本文件的合规性 string versionJsonPath = @\"C:\\Game\\.minecraft\\versions\\1.20.1\\1.20.1.json\"; string versionJson = File.ReadAllText(versionJsonPath); bool isCompliant = LocalResourceHelper.CheckCompliance(versionJson); Console.WriteLine($\"版本文件合规性: {isCompliant}\"); // 获取缺失的库文件 string gameDir = @\"C:\\Game\\.minecraft\"; List<string> missingLibraries = await LocalResourceHelper.GetMissingLibraries(gameDir, \"1.20.1\"); Console.WriteLine($\"缺失的库文件数量: {missingLibraries.Count}\"); foreach (var lib in missingLibraries) { Console.WriteLine(lib); } // 下载缺失的资源 bool downloadSuccess = await LocalResourceHelper.DownloadMissingResources(gameDir, \"1.20.1\"); Console.WriteLine($\"资源下载状态: {downloadSuccess}\"); // 验证游戏资源完整性 bool resourcesComplete = LocalResourceHelper.VerifyGameResources(gameDir, \"1.20.1\"); Console.WriteLine($\"游戏资源完整性: {resourcesComplete}\");"
  },
  "docs/LogAnalysis/README.html": {
    "href": "docs/LogAnalysis/README.html",
    "title": "日志分析 | Qomicex.Core API文档",
    "summary": "日志分析 功能概述 LogAnalysis 模块提供了 Minecraft 游戏日志和崩溃报告的分析功能，帮助开发者快速定位和诊断问题。 使用示例 using Qomicex.Core.Modules.Helpers.LogAnalysis; using Qomicex.Core.Modules.Helpers.LogAnalysis.Models; // 创建日志分析器实例 var analyzer = new MinecraftLogAnalyzer(); // 分析崩溃报告 string crashReportPath = @\"C:\\Game\\.minecraft\\crash-reports\\crash-2026-02-08.txt\"; LogAnalysisResult result = await analyzer.AnalyzeAsync(crashReportPath); if (result.IsSuccess && result.IsGameCrashed) { Console.WriteLine($\"Minecraft 版本: {result.MinecraftVersion}\"); Console.WriteLine($\"Mod 加载器: {result.ModLoader}\"); Console.WriteLine($\"检测到问题: {result.Issues.Count} 个\"); foreach (var issue in result.Issues) { Console.WriteLine($\"[{issue.Severity}] {issue.Name}\"); Console.WriteLine($\" 位置: 第{issue.LineNumber}行\"); Console.WriteLine($\" 匹配: {issue.MatchedText}\"); foreach (var solution in issue.Solutions.OrderBy(s => s.Priority)) { Console.WriteLine($\" → {solution.Description}\"); } } } else { Console.WriteLine(\"分析失败或未检测到游戏崩溃\"); if (!string.IsNullOrEmpty(result.ErrorMessage)) { Console.WriteLine($\"错误信息: {result.ErrorMessage}\"); } }"
  },
  "docs/ModLoaderResourceHelper/README.html": {
    "href": "docs/ModLoaderResourceHelper/README.html",
    "title": "模组加载器管理 | Qomicex.Core API文档",
    "summary": "模组加载器管理 功能概述 ModLoaderResourceHelper 提供了各种 Minecraft 模组加载器的信息获取和管理功能，支持 Forge、Fabric、Quilt、LiteLoader 等。 使用示例 using Qomicex.Core.Modules.Helpers.Resources; // 创建模组加载器资源助手实例 var modLoaderHelper = new ModLoaderResourceHelper(); // 获取 Fabric 版本列表 var fabricVersions = await modLoaderHelper.GetFabricVersionsAsync(); Console.WriteLine(\"可用的 Fabric 版本:\"); foreach (var version in fabricVersions) { Console.WriteLine($\" - {version}\"); } // 获取 Forge 版本列表 var forgeVersions = await modLoaderHelper.GetForgeVersionsAsync(\"1.20.1\"); Console.WriteLine(\"可用的 Forge 版本 (1.20.1):\"); foreach (var version in forgeVersions) { Console.WriteLine($\" - {version}\"); } // 获取 Quilt 版本列表 var quiltVersions = await modLoaderHelper.GetQuiltVersionsAsync(); Console.WriteLine(\"可用的 Quilt 版本:\"); foreach (var version in quiltVersions) { Console.WriteLine($\" - {version}\"); } // 获取 LiteLoader 版本列表 var liteLoaderVersions = await modLoaderHelper.GetLiteLoaderVersionsAsync(\"1.20.1\"); Console.WriteLine(\"可用的 LiteLoader 版本 (1.20.1):\"); foreach (var version in liteLoaderVersions) { Console.WriteLine($\" - {version}\"); } // 获取 OptiFine 版本列表 var optifineVersions = await modLoaderHelper.GetOptiFineVersionsAsync(\"1.20.1\"); Console.WriteLine(\"可用的 OptiFine 版本 (1.20.1):\"); foreach (var version in optifineVersions) { Console.WriteLine($\" - {version}\"); }"
  },
  "docs/SystemInfo/README.html": {
    "href": "docs/SystemInfo/README.html",
    "title": "系统信息获取 | Qomicex.Core API文档",
    "summary": "系统信息获取 功能概述 SystemInfoHelper 提供了跨平台的系统信息获取功能，包括操作系统名称、架构、内存信息等。 使用示例 using Qomicex.Core.Modules.Helpers; // 获取操作系统信息 string osName = SystemInfoHelper.OsName; // 例如：\"Windows\" string osArch = SystemInfoHelper.OsArch; // 例如：\"x64\" string separator = SystemInfoHelper.Separator; // 例如：\"\\\\\" // 获取系统内存信息 ulong totalMemory = SystemInfoHelper.GetTotalMemory(); // 总内存（字节） ulong availableMemory = SystemInfoHelper.GetAvailableMemory(); // 可用内存（字节） // 获取系统信息字符串 string systemInfo = SystemInfoHelper.GetSystemInfo(); // 输出示例：\"Windows 10.0.19045 64位 (X64) - 16.0GB总内存，8.5GB可用\" // 打印系统信息 Console.WriteLine($\"操作系统: {osName} ({osArch})\"); Console.WriteLine($\"内存: {totalMemory / (1024*1024*1024)}GB 总，{availableMemory / (1024*1024*1024)}GB 可用\");"
  },
  "docs/getting-started.html": {
    "href": "docs/getting-started.html",
    "title": "Getting Started | Qomicex.Core API文档",
    "summary": "Getting Started"
  },
  "docs/introduction.html": {
    "href": "docs/introduction.html",
    "title": "Introduction | Qomicex.Core API文档",
    "summary": "Introduction"
  },
  "index.html": {
    "href": "index.html",
    "title": "Qomicex.Core API文档 | Qomicex.Core API文档",
    "summary": "Qomicex.Core API文档 Qomicex.Core 是 Qomicex.Avalonia 项目的核心库，提供了 Minecraft 游戏管理、下载器、安装器、配置管理等关键功能。 主要功能模块 游戏管理：游戏版本检测、下载、安装和管理 模组加载器：Fabric、Forge、Quilt、LiteLoader、OptiFine 等安装器 下载器：多线程断点续传下载器 配置管理：游戏设置和配置文件处理 日志分析：游戏日志分析和错误诊断 系统信息：系统环境信息获取 快速开始 请查看左侧导航菜单中的 API 文档，了解详细的类和方法说明。 项目信息 项目地址：https://github.com/TheMyceliumOfAntan/Qomicex.Avalonia 许可证：MIT License"
  },
  "temp/docs-main/README.html": {
    "href": "temp/docs-main/README.html",
    "title": "docs | Qomicex.Core API文档",
    "summary": "docs 日冕知识库文档, 使用 Markdown 撰写. 简介 这里是日冕知识库官方仓库, 里面包含了有关于团队项目的详细介绍以及开发文档. 同时也包含部分 MineCraft 游戏内容的相关规范. 目前已经支持包括 简体中文、繁体中文、俄罗斯语等语言. 项目使用 MIT 协议开源, 欢迎广大热心网友帮助我们支持更多的语言！ 帮助我们添加一个新语言支持？ 首先, 您需要点击右上方的 Fork 来取得可修改的仓库副本 将项目克隆到本地, 使用您常用的 IDE 打开项目 确定您即将翻译的语言的 i18n 缩写. 假如您即将翻译的语言是 繁体中文（台湾）, 您在之后使用到的名称则是 zhTW, 呈现在页面中的语言名称必须对应的是“繁体中文（台湾）”（或“台湾繁体”）. “繁体中文（香港）”、简体中文（新加坡）与Español(Mexico)、Русский(Украина)同理. **请注意, 您将要为一个或多个地区适配适合当地语言习惯的本地化文本. 您首先需要考虑的即是国际承认和地区习惯之间的平衡. 任何我们认为会造成不良影响的内容均会被移除, 且制造此内容者将会被移出贡献者列表. ** 跳转到项目目录下的 docs/.vitepress 文件夹, 您将在这个目录下找到如下内容： navBar（用于存放顶部导航条的翻译内容） searchBar（用于存放搜索条的翻译内容） sideBar（用于存放侧边导航栏的翻译内容） i18n 缩写.ts（用于整合上述翻译内容） config.ts（配置文件总成） 您需要分别在 navBar、searchBar、sideBar 下创建新的翻译配置文件, 代码定义参照各目录下的 zhCN.ts, 部分代码变量名可能包含 i18n 字段, 请将其修改为您将要翻译的语言的 i18n 缩写！ 在完成上一步的文件创建和翻译工作后, 您需要在 docs/.vitepress 目录下创建 i18n 缩写.ts, 代码定义参照与同目录下的 zhCN.ts` 保持一致, 代码变量名包含 i18n 字段, 请将其修改为您将要翻译的语言的 i18n 缩写！ 在 docs/.vitepress/sharedConfig.ts 文件中找到如下内容： 注意在顶部添加相应的 import algolia: { appId: '-', apiKey: '-', indexName: 'kb-corona', locales: { root: zhSearchBarLocale, ruRU: ruSearchBarLocale, zhTW: zhTWSearchBarLocale, enUS: enUSSearchBarLocale, /* 在此处添加您的搜索条的翻译内容 */ } } 在 docs/.vitepress/config.ts 中找到如下内容： 注意在顶部添加相应的 import locales: { root: { label: '简体中文', lang: 'zh-CN', ...zhConfig }, ruRU: { label: 'Русский', lang: 'ru-RU', ...ruConfig }, zhTW: { label: '繁體中文(台)', lang: 'zh-TW', ...zhTWConfig }, enUS: { label: 'English(US)', lang: 'en-US', ...enUSConfig }, /* 在此处添加您的翻译内容整合 */ }, 最后, 在 docs 目录下创建一个新的文件夹, 文件夹名称为您将要翻译的语言的 i18n 缩写, 并将同目录下 zhCN 文件夹中的内容 复制 到您刚刚创建的文件夹中. **请注意：翻译文稿命名需要符合国际公认的标准. ** 同时, 将 docs 目录下的 index.md 也复制到在上一步创建的文件夹中. 将文件夹中的所有内容翻译为目标语言. 在完成后, 您即可向本仓库提交 PR！ 在我们审核完成后, 将会决定是否合并到主分支. 感谢您的参与！ 请注意！我们强烈建议您在提交前对自己的撰文进行测试. 您需要先下载我们配置好的环境, 然后将您的docs克隆到这个仓库本地副本的根目录（覆盖docs）, 并根据那里的readme.md安装好调试环境. 然后, 运行调试环境来进行测试. 贡献 感谢每一位翻译作者的无私奉献！ 多语言贡献者 法棍面包 俄罗斯语（ru-RU） KormiMeiko 繁体中文（zh-TW） Japerz 英语(美国) (en-US)"
  },
  "temp/docs-main/enUS/CMFS/index.html": {
    "href": "temp/docs-main/enUS/CMFS/index.html",
    "title": "Welcome to the CMFS Guide | Qomicex.Core API文档",
    "summary": "Welcome to the CMFS Guide First of all, thank you for choosing to join Minecraft CraftMineFun Server (CMFS). This series of guides will help you understand everything about CMFS, give full play to your subjective initiative, and use the special gameplay we provide to build and tour. Join with your friends or meet new a one here to play cooperatively or compete. Don't worry, our team cares most about your experience. If you encounter problems with your gaming experience, please contact us immediately! [[toc]] :::warning All servers are suspended for now Please wait for further notice (November 27, 2022) Or join our QQ group 419902868 for fast notification. ::: component CMFS-Pure: Pure survival server! You can join the game through a specific version of Minecraft and experience the unique gameplay carefully conceived by us. AH... This server is under maintenance CMFS-SquareCraft: SquareCraft Server is a Mod server that we cooperate with SquareCraft. Enjoy the \"living soul\" of Minecraft in our high-performance, stable servers: highly free and highly scalable. This server is in a hypothetical state CMFS-Eksamen You are free to join this server to request an audit by the Construction Group of Corona Studios (Corona Industries). This is essentially a vanilla creative mode building server that showcases your Minecraft building skills in our rigorous environment. When we have a need to recruit new people, we will issue an invitation for further review based on the quality of the building works that have been submitted for review: after passing, you will join our architectural team. Perhaps you can not only develop your own abilities here, but also discover colleagues here? This server is WIP! CMFS-Juego There are various mainstream mini-games and arenas we have prepared, as well as unique mini-games conceived by us. It distinguishes multiple different game versions, providing experiences from different eras. There is currently no person in charge of this server CMFS-Login \"Extended in all directions.\" This server is the entrance to the entire CMFS and is the transit server responsible for distributing players to the server they want to reach. You need to log in to the group server here through a CMFS account or a corona service account bound to a CMFS account. This server needs to be rebuilt together with CMFS-Pure CMFS-Pure Guide"
  },
  "temp/docs-main/enUS/dashboard/index.html": {
    "href": "temp/docs-main/enUS/dashboard/index.html",
    "title": "Here you can see some help about dashboard components | Qomicex.Core API文档",
    "summary": "Here you can see some help about dashboard components"
  },
  "temp/docs-main/enUS/dashboard/search.html": {
    "href": "temp/docs-main/enUS/dashboard/search.html",
    "title": "How to use dashboard search | Qomicex.Core API文档",
    "summary": "How to use dashboard search You can enter anything you want to find in the aggregate search box. After you entered something, smart prompts will pop up below to help you quickly navigate to the search results page. Use the specified search engine to find content By default, LauncherX uses Bing to find your search. If you want to specify the search engine used for aggregated searches, you can add the following prefix before your search content: Search Engine Key Google g: Bing b: Baidu bd: Examples Use Google to search \"1.16.5 Texture Pack\"：g:1.16.5 Texture Pack Use Bing to search \"1.16.5 Texture Pack\"：b:1.16.5 Texture Pack Use Baidu to search \"1.16.5 Texture Pack\"：bd:1.16.5 Texture Pack"
  },
  "temp/docs-main/enUS/guide/index.html": {
    "href": "temp/docs-main/enUS/guide/index.html",
    "title": "Welcome to the Corona Studio Knowledge Base (CSKB) | Qomicex.Core API文档",
    "summary": "Welcome to the Corona Studio Knowledge Base (CSKB) Here you can check out some technical documents, troubleshooting solutions for projects owned by Corona Studio, as well as various technical specifications and samples related to Minecraft."
  },
  "temp/docs-main/enUS/index.html": {
    "href": "temp/docs-main/enUS/index.html",
    "title": "| Qomicex.Core API文档",
    "summary": ""
  },
  "temp/docs-main/enUS/lxguide/add-game-account.html": {
    "href": "temp/docs-main/enUS/lxguide/add-game-account.html",
    "title": "Add a game account to LauncherX | Qomicex.Core API文档",
    "summary": "Add a game account to LauncherX [[toc]] Edited date: February 27, 2023 | Feiron Iguista | Japerz Preface In this guide, we recommend that you prioritize using an official Microsoft account to log in to your Minecraft. Although the official has not made clear its opposition to games without genuine verification such as offline mode, we still recommend that you support and maintain intellectual property rights by purchasing Minecraft. Using an offline copy of Minecraft may result in infringement, so all consequences will be borne by you and LauncherX is not responsible for it. This article will guide you in using LauncherX to add Local Only game accounts during initial use and subsequent use, including the following types: Microsoft Account Offline Mode Account AuthLib Account(Original Mojang account login) Since the official has stopped supporting Mojang accounts and started migrating Mojang accounts to Microsoft accounts, LauncherX will no longer support Mojang account login. For More Details: Mojang Java Edition Minecraft Account Move | Minecraft Initial Setup When you use LauncherX for the first time, you will see LauncherX greet you and ask you to perform some initial settings necessary to use LauncherX. When you reach the \"Add Account\" step, you can choose one of the following operations. Click the \"Add\" button to get started. Microsoft Acount Login Click the \"Microsoft Account\" button in the pop-up window, LauncherX will pop up another window (verification information window) containing a verification link, a one-time verification code and some buttons. The entire process takes about 10 seconds to complete (this may take a little longer depending on network performance and whether your browser saves your Microsoft account login information). Taking into account Microsoft's privacy policy, we recommend that you complete this process within 3 minutes to avoid invalidation of the one-time verification code. If the one-time code fails, you need to close the current verification information window and repeat the operation of adding a Microsoft account. Click \"Copy Code\" to copy the one-time code you need to use for this login to the clipboard. [Microsoft]Clipboard in Windows Click \"Open Verification Page\" to open the Microsoft account verification page through your default browser. Paste the one-time code you copied into the specified location as prompted on the web page. If Microsoft requires you to log in, please log in to your Microsoft account on the web page first. After this window pops up, you need to \"agree\" to continue adding the account. While LauncherX is verifying your account, you can continue with the next step of setup. If you think the verification process is too slow or failing, consider optimizing your current network environment (for example, using an accelerator for Xbox login or trying to move closer to your wireless network source, if you are using one.) Unexpected situation: Edge browser pops up requiring security verification device: For this case, you need: Hit \"Cancel\" Click \"Other login methods\" on the web page, as shown in the figure: Click \"Use my password\" or choose any login method that's convenient for you: Offline Mode This is arguably the easiest way to add an account. You can use LauncherX to enable custom skins for your local game. This feature will only take effect on your local client. See: Game Account Management/Skin Preview But I still want to remind you that using the offline version may be illegal and result in legal consequences, and you will be responsible for all the consequences. Click \"Offline Account\" Enter any player name you want. Note that some versions (especially older versions) do not support non-English and English character IDs. Offline mode only allows you to play local games and servers that support offline login. AuthLib Use a special login verification service with the help of AuthLib-Injector. Before choosing this option to log in, you should confirm that you have an AuthLib external login service from one party. To do this, you need to prepare: External login verification email Corresponding password The AuthLib server address corresponding to the authentication service (this is necessary for external logins, because LauncherX does not know whose Yggdrasil API you need to authenticate to. Typically, this address is something like \"https://<service provider's domain name>/api/yggdrasil”)\" Click \"External Login\" to get started. A window as shown in the picture will pop up: Enter the information you should have prepared previously Save account. This information will be encrypted and used as credentials, which will be used for verification after you log in to the server that supports the corresponding AuthLib service. More setup After completing the initial setup, you can enter Settings-Account to add more game accounts. After clicking \"Add Account\", everything is exactly the same as when you first set up LauncherX. We recommend that you add an offline account with the same ID after adding a Microsoft account to avoid the problem that some games cannot be started when online or not."
  },
  "temp/docs-main/enUS/lxguide/startup/index.html": {
    "href": "temp/docs-main/enUS/lxguide/startup/index.html",
    "title": "Start | Qomicex.Core API文档",
    "summary": "Start Welcome to LauncherX! We are constantly committed to creating a beautiful and convenient user experience for you. [[toc]] Creation date of this article: July 14, 2023, modification date: July 14, 2023, author: Feiron Iguista, Translated by Japerz. ::: info Due to different devices, you may encounter some minor difficulties when starting up for the first time, and we are very sorry for this. We are working hard to resolve these issues that severely impact the experience, so this article may change from time to time without prior notice. ::: Run LauncherX to launching Minecraft Basically, the prerequisites are basically the same for all desktop environments. Downloading the Configuration Assistant is the most suitable solution for ordinary users (the tool has not yet developed, so stay tuned XD.); and for the distribution environment, it is recommended to use the stable version including runtime (will be released in \"Stable Released\" when the first stable version comes out); in addition, you can manually place the LauncherX executable file you want to use directly into your directory after completing the local runtime installation. This is exactly what the Configuration Assistant automates. But for now, whether it is Windows, macOS or a Linux distribution with a desktop environment, or whether the architecture is x86-64, x86-S, amd64 or ARM64, you have downloaded the corresponding LauncherX according to the current operating system to your desired location. The folder in which it is run, and has prepared the runtime environment accordingly (the configuration assistant will be completed automatically, and this step is not required when including the run), then you can double-click its icon to run it like other apps. Next, I will list all known possible issues. Common issues Since our Java RE detection mechanism works in \"search-execution\" mode to confirm whether the runtime is available, you may encounter an error pop-up window from Java when you start LauncherX. You can turn it off directly, as this will not affect LauncherX runs. You can remove the damaged runtime."
  },
  "temp/docs-main/enUS/lxguide/startup/perOsSetup/linux.html": {
    "href": "temp/docs-main/enUS/lxguide/startup/perOsSetup/linux.html",
    "title": "Special settings for Linux | Qomicex.Core API文档",
    "summary": "Special settings for Linux [[toc]] For Linux distributions based on ARM64 architecture ::: warning Because Mojang has not officially supported ARM64 versions of Linux games. Therefore, you need to manually download and install the JRE runtime before using LauncherX. ::: Download and install the JRE runtime Here we're gonna use Azul JDK to demonstrate JRE installation process. At Azul JDK Website , scroll down a little to see the JDK version filter box: At Operating System, select Linux, and at Architecture, select ARM 64-bit to get get all available JDK versions. Clike the Download button on the right-side bar, and select .tar.gz formate JDK runtime, and after downloading, extract it to any local folder. Then select Add Manually in LauncherX and select the java executable file in the bin/ directory of the JDK folder. If it can't run You might need to do the following: Open a new terminal, or use the one that just appeared Enter export LC_CTYPE=en_US.UTF-8, and hit enter (If necessary, the above steps can be performed with administrator privileges [sudo]) Try running again. If that fails, try re-login the system. If it fails again, be sure to give us feedback at LXIT (GitHub)."
  },
  "temp/docs-main/enUS/lxguide/startup/perOsSetup/macOS.html": {
    "href": "temp/docs-main/enUS/lxguide/startup/perOsSetup/macOS.html",
    "title": "Special settings for macOS | Qomicex.Core API文档",
    "summary": "Special settings for macOS For macOS users, if you see a \"Corrupted\" error pop-up when opening LauncherX, please do the following: Open \"Terminal.app\" Open your Finder and find your LauncherX executable (LauncherX.app or LauncherX.Avalonia.app) Enter sudo xattr -d com.apple.quarantine in the terminal BUT DON'T HIT ENTER YET! As long as there is a space at the end of the above command, drag your LauncherX APP into the terminal window Now hit enter, the terminal will ask you to enter the password of the administrator account. Please enter it according to your feelings since the terminal will not display any input records in the display area. After typing the password, press Enter on the keyboard to confirm. There will be no prompt if the execution is successful. Then try launching LauncherX again, and if it fails again, be sure to give us feedback at LXIT (GitHub)."
  },
  "temp/docs-main/enUS/lxguide/startup/perOsSetup/windows.html": {
    "href": "temp/docs-main/enUS/lxguide/startup/perOsSetup/windows.html",
    "title": "Special settings for Windows | Qomicex.Core API文档",
    "summary": "Special settings for Windows Currently, you don't need to do any additional configuration to use the full functionality of the LauncherX launcher. ::: warning Please note that LauncherX DOES NOT SUPPORT operating systems below Windows 7, as well as any version of Windows S and 32-bit Windows systems. :::"
  },
  "temp/docs-main/enUS/projbobcat/additionalParsers/accountProfileParser.html": {
    "href": "temp/docs-main/enUS/projbobcat/additionalParsers/accountProfileParser.html",
    "title": "Game account parser | Qomicex.Core API文档",
    "summary": "Game account parser The game profile parser is responsible for outputing the user account into the official launcher configuration file. Initialize the parser The way to initialize the parser is very simple: var launcherAccountParser = new DefaultLauncherAccountParser(rootPath, clientToken) Among them, rootPath is the root directory where the core is located (that is, the directory where the .minecraft folder is located). clientToken is a randomly generated GUID."
  },
  "temp/docs-main/enUS/projbobcat/additionalParsers/gameProfileParser.html": {
    "href": "temp/docs-main/enUS/projbobcat/additionalParsers/gameProfileParser.html",
    "title": "Game file parser | Qomicex.Core API文档",
    "summary": "Game file parser The game archive parser is responsible for outputing the searched local games into the configuration file of the official launcher. Initialize the parser The way to initialize the parser is very simple: var launcherProfileParser = new DefaultLauncherProfileParser(rootPath, clientToken) Among them, rootPath is the root directory where the core is located (that is, the directory where the .minecraft folder is located). clientToken is a randomly generated GUID."
  },
  "temp/docs-main/enUS/projbobcat/additionalParsers/index.html": {
    "href": "temp/docs-main/enUS/projbobcat/additionalParsers/index.html",
    "title": "Attached parser | Qomicex.Core API文档",
    "summary": "Attached parser In order to maintain the same behavior as Mojang's official launcher, ProjBobcat has implemented some additional parsers to help us keep data and files in sync with the official launcher. The following table shows the currently implemented parsers: Name Description DefaultLauncherAccountParser Configuration file used to write verification information to the official launcher DefaultLauncherProfileParser Used to write the searched local games to the launcher's configuration file"
  },
  "temp/docs-main/enUS/projbobcat/authenticators/index.html": {
    "href": "temp/docs-main/enUS/projbobcat/authenticators/index.html",
    "title": "Authentication model | Qomicex.Core API文档",
    "summary": "Authentication model In ProjBobcat, we have implemented for developers all the authentication scenarios you may encounter during MineCraft development. Support list Model Applicable situations OfflineAuthenticator Offline authentication model YggdrasilAuthenticator Login model for older versions MicrosoftAuthenticator New version of Microsoft authentication model"
  },
  "temp/docs-main/enUS/projbobcat/authenticators/microsoft.html": {
    "href": "temp/docs-main/enUS/projbobcat/authenticators/microsoft.html",
    "title": "Microsoft Authentication Model | Qomicex.Core API文档",
    "summary": "Microsoft Authentication Model [[toc]] This authentication model implements the new Azure-based verification process and is applicable to all MineCraft versions currently under maintenance. Preparation Because the new version of the authentication process uses Azure-based authentication. Therefore, before you begin, make sure you have completed Configuration of Azure Apps After completing the Azure application registration, please make sure to complete Microsoft Authenticator Initialization at the program entry point. Configure cached credential providing method Due to the particularity of this verification model, developers need to save the refresh token and expiration time returned by the first verification to help the validator complete the verification. The validator will call this method for the first time during verification to query the validity of the local token cache. If the local token is still valid, the verification result will be returned directly. If the locally cached token has expired, the developer needs to manually request a new token and return the refreshed token. Here is a sample implementation code of this method: public async Task<(bool, GraphAuthResultModel?)> CacheTokenProviderAsync() { if (string.IsNullOrEmpty(XBLToken)) return (false, default); if (string.IsNullOrEmpty(XBLRefreshToken)) return (false, default); // Calculate expire date // [!code focus] var expireDate = LastRefreshedTime.AddSeconds(ExpiresIn); // [!code focus] // If the local cache token is still valid, the current token is returned directly. // [!code focus] // Otherwise, request a new token using the refresh token // [!code focus] if (expireDate > DateTime.Now) { var result = new GraphAuthResultModel // [!code focus] { // [!code focus] ExpiresIn = (int)(expireDate - DateTime.Now).TotalSeconds, // [!code focus] AccessToken = XBLToken, // [!code focus] RefreshToken = XBLRefreshToken // [!code focus] }; // [!code focus] return (true, result); // [!code focus] } // Request a new login token // [!code focus] var refreshReqDic = new List<KeyValuePair<string, string>> // [!code focus] { // [!code focus] new(\"client_id\", MicrosoftAuthenticator.ApiSettings.ClientId), // [!code focus] new(\"refresh_token\", XBLRefreshToken), // [!code focus] new(\"grant_type\", \"refresh_token\") // [!code focus] }; // [!code focus] using var refreshReq = new HttpRequestMessage(HttpMethod.Post, MicrosoftAuthenticator.MSRefreshTokenRequestUrl) // [!code focus] { // [!code focus] Content = new FormUrlEncodedContent(refreshReqDic) // [!code focus] }; // [!code focus] using var refreshRes = await DefaultClient.SendAsync(refreshReq); var refreshContent = await refreshRes.Content.ReadAsStringAsync(); var refreshModel = MicrosoftAuthenticator.ResolveMSGraphResult(refreshContent, GraphAuthResultModelContext.Default.GraphAuthResultModel); if (refreshModel is not GraphAuthResultModel model) { if (refreshModel is GraphResponseErrorModel error) // [!code focus] { // [!code focus] // Handle failed refresh operations here // [!code focus] } // [!code focus] return (false, default); } return (true, model); } Configure first login device flow verification code display method Because we use device flow verification to verify the player's Microsoft account. Therefore, we need an additional method to present the one-time key and verification address required for device flow verification to the user. Here is an example of this method: private void DeviceTokenNotifier(DeviceIdResponseModel deviceIdResponseModel) { // Display the obtained callback data to the front end DeviceCodeResponse = deviceIdResponseModel; } DeviceIdResponseModel contains all the information the user needs to complete verification: Name Function UserCode The secret key required for user authentication VerificationUri Verification address, users need to visit this URL to complete subsequent verification steps ExpiresIn Validation code expiration time (seconds) Here you can see an example of the interface: In this interface, you need to include at least the following content: The secret key required to log in Specific verification address A short operation prompt to help users complete the verification operation Initialize validator Initial verification :::warning Please make sure you are ready before performing the following process Configuring the first login device flow verification code display method to ensure that users can obtain the correct initial login information! ::: Initialize the validator: var microsoftAuthenticator = new MicrosoftAuthenticator { LauncherAccountParser = launcherAccountParser }; In the above code block, please replace these parameters according to your actual situation: Project Description launcherAccountParser For initialization of the launcher account parser, see here Not initial verification Non-initial verification means using the Token cache obtained in the first verification for secondary verification. It mainly uses CacheTokenProviderAsync to verify whether the local credentials are still valid. If the locally cached Token has expired, it will be refreshed in this method. Initialize the validator: var microsoftAuthenticator = new MicrosoftAuthenticator { CacheTokenProvider = CacheTokenProviderAsync, Email = \"[EMAIL]\", LauncherAccountParser = launcherAccountParser }; In the above code block, please replace these parameters according to your actual situation: Project Description launcherAccountParser For initialization of the launcher account parser, see here [EMAIL] Email address to verify account :::tip For the initialization of launcherAccountParser (game profile parser), please refer to the Game Profile Parser page ::: Get authentication results (first authentication) After you complete the initialization of the authentication model, you only need to call the Microsoft Authenticator's authentication method for initial account authentication. Here is a sample authentication code: // Get authentication results // [!code focus] // DeviceTokenNotifier: This is the information display method mentioned above. // [!code focus] var authResult = await msAuth.GetMSAuthResult(DeviceTokenNotifier); // [!code focus] if (authResult == null) { // Handling failed authentication // [!code focus] } // Parse user fields from Jwt Token // [!code focus] var claims = JwtTokenHelper.GetTokenInfo(authResult.IdToken); // [!code focus] var email = claims.TryGetValue(\"email\", out var outEmail) ? outEmail : null; // [!code focus] if (string.IsNullOrEmpty(email)) { // Unable to resolve user's email address from Jwt credentials, treated as authentication failure // [!code focus] // This is most likely caused by Azure application or Scope configuration failure. // [!code focus] } // Save necessary user information to local disk in preparation for next authentication // [!code focus] var msInfoModel = new MSAccountInfoModel { XBLToken = authResult.AccessToken, // [!code focus] XBLRefreshToken = authResult.RefreshToken, // [!code focus] ExpiresIn = authResult.ExpiresIn, // [!code focus] Email = email // [!code focus] }; Get Authentication results (not initial authentication) After you complete the initialization of the authentication model, you only need to call the authentication method of Microsoft Authenticator to complete the account authentication. In an asynchronous context, use AuthTaskAsync to accomplish authentication: var authResult = await microsoftAuthenticator.AuthTaskAsync(false); In a sync context, use Auth to finish authentication: var authResult = microsoftAuthenticator.Auth(); Interpret authentication results After the authentication method is completed, the authentication model will return the authentication result, which is of the parent type AuthResultBase object. All authentication results contain an enumeration value AuthStatus, which directly indicates the success or failure of the authentication result. Below you can see an interpretation of the authentication results: Failed Authentication Result By judging whether Error is empty, you can easily judge whether the authentication results returned by the authentication model are valid. The Error object will contain the following fields to tell you some details: Field Description authResult.Error.Cause The specific cause of the problem authResult.Error.Error error name authResult.Error.ErrorMessage Details of the error, possibly including a solution Successful authentication result If the Error field in the authentication result is empty, it means that the authentication is valid. A successful authentication result will contain the following information: Field Description authResult.Id A unique identifier for the username. ProjBobcat uses a specific generation method to generate this identifier. authResult.AccessToken Authorization credentials for the user account authResult.Profiles List of roles available to the user, which may contain multiple available roles authResult.SelectedProfile The role currently selected by the user. This field may be empty. If it is empty, the user needs to be prompted for manual selection. authResult.User Summary of user account information, including some basic account information authResult.LocalId Local ID, usually a randomly generated UUID authResult.RemoteId The remote ID returned by the authentication server, usually a unique identifier for the user authResult.XBoxUid XBox Live UID authResult.Email Verify email address used authResult.CurrentAuthTime The current verification time, Developers need to save this field to help confirm the validity of the local cache token authResult.ExpiresIn Token expiration time (unit: seconds), Developers need to save this field to help confirm the validity of the local cache token authResult.RefreshToken Refresh token, Developers need to save this field to help refresh expired tokens authResult.Skin Skin URL for user account :::warning Please use corresponding restrictions or encryption operations to safely store confidential data related to user tokens. The leakage of this data may cause losses. :::"
  },
  "temp/docs-main/enUS/projbobcat/authenticators/offline.html": {
    "href": "temp/docs-main/enUS/projbobcat/authenticators/offline.html",
    "title": "Offline Authentication model | Qomicex.Core API文档",
    "summary": "Offline Authentication model [[toc]] This authentication model implements the most basic authentication function. Typically used for local debugging and authentication. :::warning Using this authentication model in the production process may violate copyright laws or end user agreements in some countries and regions. For details, see Mojang End User Agreement ::: Initialize validator You can initialize the offline validator with the following code: var offlineAuthenticator = new OfflineAuthenticator { LauncherAccountParser = launcherAccountParser, Username = \"[DISPLAY_NAME]\" }; In the above code block, please replace these parameters according to your actual situation: Project Description launcherAccountParser For initialization of the launcher account resolver, see here [DISPLAY_NAME] The display name in the game usually consists of English characters, symbols and numbers. :::tip For the initialization of launcherAccountParser (game profile parser), please refer to the Game Profile Parser page ::: Get authentication results After you complete the authentication of the authentication model, you only need to call the authentication method of the offline verifier to complete the account authentication. In an asynchronous context, use AuthTaskAsync to finish authentication: var authResult = await offlineAuthenticator.AuthTaskAsync(false); In a sync context, use Auth to finish authentication: var authResult = offlineAuthenticator.Auth(); Interpret authentication results After the authentication method is completed, the authentication model will return the authentication result, which is of type AuthResultBase object. All authentication results contain an enumeration value AuthStatus, which directly indicates the success or failure of the authentication result. Below you can see an interpretation of the authentication results: Failed authentication result By judging whether Error is empty, you can easily judge whether the authentication results returned by the authentication model are valid. The Error object will contain the following fields to tell you some details: Field Description authResult.Error.Cause The specific cause of the problem authResult.Error.Error error name authResult.Error.ErrorMessage Details of the error, possibly including a solution Successful authentication result If the Error field in the authentication result is empty, it means that the authentication is valid. A successful authentication result will contain the following information: Field Description authResult.Id The unique identifier of the username, ProjBobcat uses a specific generation method to generate this identifier authResult.AccessToken The authorization credentials of the user account, which has no meaning for the offline authentication model authResult.User.UUID The UUID of this user, similar to authResult.Id authResult.User.Properties The user's property array. For the offline authentication model, this array contains only one valid value"
  },
  "temp/docs-main/enUS/projbobcat/authenticators/yggdrasil.html": {
    "href": "temp/docs-main/enUS/projbobcat/authenticators/yggdrasil.html",
    "title": "Yggdrasil Authentication Model | Qomicex.Core API文档",
    "summary": "Yggdrasil Authentication Model [[toc]] This authentication model implements an older version of Mojang's authentication scheme, which is now deprecated. ::: warning Continuing to use this model for verification of official accounts will be considered an invalid request. But the model can still be used to log in to servers that use third-party authentication services (such as AuthLib-Injector). ::: Initialize validator You can initialize the offline validator with the following code: var yggdrasilAuthenticator = new YggdrasilAuthenticator { AuthServer = \"[CUSTOM_AUTH_SERVER]\", Email = \"[EMAIL], LauncherAccountParser = launcherAccountParser, Password = \"[PASSWORD]\" }; In the above code block, please replace these parameters according to your actual situation: Project Description launcherAccountParser For initialization of the launcher account parser, see here [CUSTOM_AUTH_SERVER] Optional field, custom authentication server address. This field is usually provided by a third-party authentication service provider. If not filled in, Mojang's official authentication server address will be used [EMAIL] Email address to verify account [PASSWORD] Password to verify account :::tip For the initialization of launcherAccountParser (game profile parser), please refer to the Game Profile Parser page ::: :::warning When using a third-party authentication server, use the https:// rather than the http:// protocol to connect to the authentication server. Using an insecure authentication server may lead to sensitive data leakage and other issues. ::: Get authentication results After you complete the initialization of the authentication model, you only need to call the authentication method of the offline verifier to complete the account authentication. In an asynchronous context, use AuthTaskAsync to accomplish authentication: var authResult = await offlineAuthenticator.AuthTaskAsync(false); In a sync context, use Auth to finish authentication: var authResult = offlineAuthenticator.Auth(); Interpret authentication results After the authentication method is completed, the authentication model will return the authentication result, which is of the parent type AuthResultBase object. All authentication results contain an enumeration value AuthStatus, which directly indicates the success or failure of the authentication result. Below you can see an interpretation of the authentication results: Failed authentication result By judging whether Error is empty, you can easily judge whether the authentication results returned by the authentication model are valid. The Error object will contain the following fields to tell you some details: Field Description authResult.Error.Cause The specific cause of the problem authResult.Error.Error error name authResult.Error.ErrorMessage Details of the error, possibly including a solution Successful authentication result If the Error field in the authentication result is empty, it means that the authentication is valid. A successful authentication result will contain the following information: Field Description authResult.Id The unique identifier of the username, ProjBobcat uses a specific generation method to generate this identifier authResult.AccessToken Authorization credentials for the user account authResult.Profiles List of roles available to the user, which may contain multiple available roles authResult.SelectedProfile The role currently selected by the user. This field may be empty. If it is empty, the user needs to be prompted for manual selection. authResult.User Summary of user account information, including some basic account information authResult.LocalId Local ID, usually a randomly generated UUID authResult.RemoteId The remote ID returned by the authentication server, usually a unique identifier for the user"
  },
  "temp/docs-main/enUS/projbobcat/beforeWeStart.html": {
    "href": "temp/docs-main/enUS/projbobcat/beforeWeStart.html",
    "title": "Before we begin | Qomicex.Core API文档",
    "summary": "Before we begin Before we officially start using ProjBobcat, you need to make necessary checks and adjustments to your project properties to meet the running needs of ProjBobcat. [[toc]] Runtime requirements You need to ensure that your project's dotNET framework is running at least .NET 6.0 and higher. Currently supported .NET versions: .NET 6.0 .NET 7.0 (recommended) ::: warning We have removed support for the .NET 5.0 runtime in a previous version update. ::: Project properties Due to Windows system mechanics, you need to turn off the build option for Prefer 32-bit in the project properties. Otherwise, you may experience unexpected results when using some components of ProjBobcat. You need to switch to the project's properties page in Visual Studio and find the checkbox for Prefer 32-bit and uncheck it. 32-bit system support ::: warning ProjBobcat decided to give up all support for 32-bit systems from the beginning of the project because it is wayyyyyyy to old LMAO :::"
  },
  "temp/docs-main/enUS/projbobcat/createNewAzureApp.html": {
    "href": "temp/docs-main/enUS/projbobcat/createNewAzureApp.html",
    "title": "Configure Azure application | Qomicex.Core API文档",
    "summary": "Configure Azure application [[toc]] Start configuration Before you get started, you first need a Microsoft account. There is no cost to register an Azure Active Directory app. Sign in to Azure Portal using your Microsoft account After logging in, the page you see should look like this: Click Azure Active Directory under Azure Services You will see a page similar to the following Then click App Registration on the left tool bar: Click New Registration on the top toolbar and fill in the name of the application. And select Microsoft Personal Account Only in Supported Account Types. Since we are not using URI callback based authentication. Therefore, you do not need to fill in the Redirect URI below the form. ::: warning Please check the information in the form carefully, otherwise unexpected problems may occur in subsequent steps. ::: After clicking Create, wait for Azure AD to finish creating the app. Once created, the webpage will redirect you to the app's details page: Then click Authentication in the left column: Then find the Advanced Settings section on the right and make sure that Advanced SDK Support and Allow Public Client Flow in the section are turned on. If they are not turned on, turn them on manually. Then click the save button below and wait for the saving to complete. View Client ID Congratulations! You have completed the application registration with Azure. Next, you only need to go to the Overview page to view the Client ID of the application. Click the Overview button in the left column to view the basic information of the application: On the right you will see the details of your application, find the Application (Client) ID in Summary, This ID will be the Client ID you need to use during the Microsoft Authenticator Configuration phase."
  },
  "temp/docs-main/enUS/projbobcat/index.html": {
    "href": "temp/docs-main/enUS/projbobcat/index.html",
    "title": "ProjBobcat Development Documentation | Qomicex.Core API文档",
    "summary": "ProjBobcat Development Documentation ProjBobcat is a highly customizable, high-performance, full-featured Minecraft launcher core developed by the Corona development team. Here you can check out the usage tutorials for each major component. project address GitHub - ProjBobcat"
  },
  "temp/docs-main/enUS/projbobcat/installationAndConfig.html": {
    "href": "temp/docs-main/enUS/projbobcat/installationAndConfig.html",
    "title": "Install and configure ProjBobcat | Qomicex.Core API文档",
    "summary": "Install and configure ProjBobcat [[toc]] Install from distribution package Nuget Currently, you can easily search and download the ProjBobcat package from Nuget. You can search for ProjBobcat in the package manager of Visual Studio and add it to your project. NuGet\\Install-Package ProjBobcat -Version 1.16.0 .NET CLI To install ProjBobcat via the .NET CLI, you just need to switch the terminal to the project directory containing the .csproj file and execute in the terminal： dotnet add package ProjBobcat --version 1.16.0 PackageReference PackageReference is a new software package management specification launched by Microsoft for modern .NET projects. Details can be found at MSDN View in All you need to do is add in your project's [project name].csproj file: <PackageReference Include=\"ProjBobcat\" Version=\"1.16.0\" /> ::: tip Among them, 1.16.0 is the version number of ProjBobcat. You can replace it with other version numbers. All released versions can be viewed at ProjBobcat - Nuget. ::: Get from source code Another way to use ProjBobcat is to add the code repository directly to your project reference. ::: info Before executing the following command, you may need to install Git CLI ::: Clone the ProjBobcat repository Use the command line to switch to the root directory of the project solution and execute the following code in the command line to complete the cloning of the warehouse: git clone https://github.com/Corona-Studio/ProjBobcat.git Use Git Submodule to pull ProjBobcat ::: tip Git Submodule is a very practical feature, and here we only show its most basic use cases. You can see more use cases in Git Documentation. ::: Use the command line to switch to the root directory of the project solution and execute the following code in the command line to complete the cloning of the warehouse: git submodule add https://github.com/Corona-Studio/ProjBobcat.git Add a reference to ProjBobcat Next, in Visual Studio's Solution Explorer view, right-click the solution name at the top of the tree. And select Add-\"Existing Project\" and find ProjBobcat.csproj in the folder of the ProjBobcat project you just cloned in the file browser window. Next, find the project you need to reference ProjBobcat in Solution Explorer, right-click, and select \"Add\"-\"Project Reference\". Finally, check ProjBobcat in the pop-up window to complete the reference. ##Configure before use Modify the default number of connections Before using ProjBobcat, you need to set the entry point of your program (usually App.xaml.cs or Program.cs) Add some code to initialize ProjBobcat related services. Due to the default maximum connection limit of the .NET runtime, you may encounter a performance bottleneck when using ProjBobcat to download modules. Therefore, you need to add the following code at the entrance to modify the default maximum number of connections: using System.Net; ServicePointManager.DefaultConnectionLimit = 512; Register and initialize basic services Next, you need to add this code to the entry point to complete the initialization of the ProjBobcat service: Initialize service container ServiceHelper.Init(); Initialize CurseForge API service (optional) This service is optional, if you are not using any CurseForge related services, you can ignore this step. ::: tip Before registering for the CurseForge service, you need to prepare the API KEY officially issued by CurseForge. If you haven't already, please go to the Application Page - CurseForge to get your API KEY. ::: ::: warning API KEY is a sensitive personal credential. Please keep the API KEY properly and do not disclose it to others. ::: CurseForgeAPIHelper.SetApiKey(\"[YOUR API KEY]\"); Replace [YOUR API KEY] with the API KEY you officially obtained from CurseForge. Initialize download service When initializing the download service, you can choose to customize the User Agent used when making requests (the default is \"ProjBobcat\"). HttpClientHelper.Ua = \"[YOUR UA]\"; // OPTIONAL HttpClientHelper.Init(); Configure Microsoft Login Authenticator For specific registration methods for Azure Active Directory applications, please go to: Create New Azure Application ::: tip Before configuring Microsoft Authenticator, you need to register your app with Azure and configure it correctly. After you complete the configuration, you will get a Client ID. Relevant information: Azure Website Device code flow ::: ::: warning The CLIENT ID is a sensitive personal credential, please keep the CLIENT ID properly and do not disclose it to others. ::: MicrosoftAuthenticator.Configure(new MicrosoftAuthenticatorAPISettings { ClientId = \"[YOUR CLIENT ID]\", TenentId = \"consumers\", Scopes = new[] { \"XboxLive.signin\", \"offline_access\", \"openid\", \"profile\", \"email\" } }); After obtaining the Client ID, replace [YOUR CLIENT ID] with your Client ID."
  },
  "temp/docs-main/enUS/projbobcat/installers/curseforge.html": {
    "href": "temp/docs-main/enUS/projbobcat/installers/curseforge.html",
    "title": "CurseForge integration package installer | Qomicex.Core API文档",
    "summary": "CurseForge integration package installer [[toc]] ::: tip Please note that ProjBobcat only implements the automated installation process of the CurseForge integration package. You still need to implement the search, download, and save process of the CurseForge integration package yourself. ::: Resources CurseForge Website CurseForge API Initialize the installer The way to initialize the CurseForge installer is very simple: var curseForgeInstaller = new CurseForgeInstaller { GameId = \"[CUSTOM_INSTALL_GAME_ID]\", ModPackPath = \"[PATH_TO_YOUR_MODPACK]\", RootPath = \"[GAME_ROOT_PATH]\" }; In the above code block, please replace these parameters according to your actual situation: Project Description [GAME_ROOT_PATH] The game root directory, usually the path to the .minecraft folder [CUSTOM_INSTALL_GAME_ID] Optional, customize the name of the game to be installed [PATH_TO_YOUR_MODPACK] The path where the CurseForge integration package is located Start installation After you complete the initialization of the installer, you only need to call the installation method of the CurseForge installer to complete the installation. In an asynchronous context, use InstallTaskAsync to complete the installation: await curseForgeInstaller.InstallTaskAsync(); In a sync context, use Install to complete the installation: curseForgeInstaller.Install(); Report installation progress In some cases, the CurseForge installer may take several minutes to complete the installation. Therefore, you may need to report the current progress of the installer to the user in real time. For this purpose, the CurseForge installer provides the StageChangedEventDelegate event to help you implement task reporting. You simply need to register for the following event before starting the installation: curseForgeInstaller.StageChangedEventDelegate += (_, args) => { ReportProgress(args.Progress, args.CurrentStage); }; Among them, args.Progress indicates the current percentage progress of the installer. args.CurrentStage is a text description of the current progress of the installer."
  },
  "temp/docs-main/enUS/projbobcat/installers/fabric.html": {
    "href": "temp/docs-main/enUS/projbobcat/installers/fabric.html",
    "title": "Fabric installer | Qomicex.Core API文档",
    "summary": "Fabric installer [[toc]] ::: tip Please note that ProjBobcat only implements the Fabric automated installation process. You still need to implement the search, download, and save process of the Fabric installation package yourself. ::: Resources Fabric Website Fabric Meta API Get Fabric Loader Artifact Because ProjBobcat's Fabric installer requires you to provide the official Loader Artifact information from Fabric when initializing the installer. Therefore, we will briefly describe here how to obtain this information based on a given MineCraft version. ::: info In this example, we'll be using Minecraft version 1.19.2 to show you how to get it. ::: Send request to Fabric Meta API First, you need to send an HTTP GET request to https://meta.fabricmc.net/v2/versions/loader/[MC_VERSION]. Replace [MC_VERSION] with the Minecraft version you want to install. Here we will use 1.19.2 for exmaple. You will see something similar to the following returned: [ { \"loader\": { \"separator\": \".\", \"build\": 11, \"maven\": \"net.fabricmc:fabric-loader:0.14.11\", \"version\": \"0.14.11\", \"stable\": true }, \"intermediary\": { \"maven\": \"net.fabricmc:intermediary:1.19.2\", \"version\": \"1.19.2\", \"stable\": true }, \"launcherMeta\": { \"version\": 1, \"libraries\": {...}, \"mainClass\": {...} } }, {...}, {...} ] Fabric Meta API will return a JSON array, and each element in the array is the Loader Artifact we need. Convert JSON return to ProjBobcat type If you are using JSON.NET(Newtonsoft.JSON) in your project. You can use code similar to the following to convert the server response you get into the corresponding ProjBobcat type: // Requesting data from the Fabric Meta API (example, not actual code) ... var responseJson = await res.Content.ReadAsStringAsync(); // Convert JSON response to ProjBobcat type // [!code focus] var artifacts = JsonConvert.DeserializeObject<List<FabricLoaderArtifactModel>>(responseJson); // [!code focus] // Get the version the user wants to install (example, not actual code) var userSelect = vm.SelectedArtifactIndex; // Get a single Loader Artifact // [!code focus] var selectedArtifact = artifacts[userSelect]; // [!code focus] Here, selectedArtifact is what the Fabric installer requires FabricLoaderArtifactModel. Initialize the installer The way to initialize the Fabric installer is very simple. You need to use the selectedArtifact obtained in the previous step to initialize the installer: var fabricInstaller = new FabricInstaller { LoaderArtifact = selectedArtifact, VersionLocator = [VERSION_LOCATOR_INST], RootPath = \"[GAME_ROOT_PATH]\", CustomId = \"[CUSTOM_INSTALL_GAME_ID]\", InheritsFrom = \"[MC_VERSION_OR_GAME_ID]\" }; In the above code block, please replace these parameters according to your actual situation: Project Description [GAME_ROOT_PATH] The game root directory, usually the path to the .minecraft folder [CUSTOM_INSTALL_GAME_ID] Optional, customize the name of the game to be installed [MC_VERSION_OR_GAME_ID] The MineCraft original game version inherited by Forge, usually the game version. For example: 1.19.2 [VERSION_LOCATOR_INST] Game version locator instance, that is, the VersionLocator attribute when initializing the game core start installation After you complete the initialization of the installer, you only need to call the installation method of the Fabric installer to complete the installation. In an asynchronous context, use InstallTaskAsync to complete the installation: await fabricInstaller.InstallTaskAsync(); In a sync context, use Install to complete the installation: fabricInstaller.Install(); Report installation progress In some cases, the Fabric installer may take several minutes to complete the installation. Therefore, you may need to report the current progress of the installer to the user in real time. To this end, the Fabric installer provides the StageChangedEventDelegate event to help you implement task reporting. You simply need to register for the following event before starting the installation: fabricInstaller.StageChangedEventDelegate += (_, args) => { ReportProgress(args.Progress, args.CurrentStage); }; Among them, args.Progress indicates the current percentage progress of the installer. args.CurrentStage is a text description of the current progress of the installer."
  },
  "temp/docs-main/enUS/projbobcat/installers/forge.html": {
    "href": "temp/docs-main/enUS/projbobcat/installers/forge.html",
    "title": "Forge installer | Qomicex.Core API文档",
    "summary": "Forge installer In ProjBobcat, we support automated Forge installations for almost all major MineCraft versions. [[toc]] ::: tip Please note that ProjBobcat only implements the Forge automated installation process. You still need to implement the search, download, and save process of the Forge installation package yourself. ::: Determine which Forge installer should be used Because the Forge team has modified Forge's packaging specifications and installation process in subsequent versions. Therefore, you need to manually determine which installer to use. In ProjBobcat, we have implemented the relevant judgment logic for you. You just need to simply call the following method: var mcVersion = \"[MC_VERSION]\"; var forgeJarPath = \"[PATH_TO_YOUR_FORGE_INSTALLER]\"; var forgeVersion = ForgeInstallerFactory.GetForgeArtifactVersion(mcVersion, \"[FORGE_VERSION]\"); var isLegacy = ForgeInstallerFactory.IsLegacyForgeInstaller(forgeJarPath, forgeVersion); // [!code focus] In the above code block, please replace these parameters according to your actual situation: Project Description [MC_VERSION] The Minecraft version to install Forge into, for example: 1.19.2 [PATH_TO_YOUR_FORGE_INSTALLER] The path to the Forge installer .jar file [FORGE_VERSION] The specific version of Forge, usually XX.X.X, for example: 43.2.0 After you complete the replacement and successfully execute the above code snippet, isLegacy will indicate which Forge installer the current Forge installer should use. Initialize legacy installer If in the above process, the value of isLegacy is true, it means that you need to use a legacy installer to complete the Forge installation. To initialize the legacy installer, simply instantiate LegacyForgeInstaller and provide the appropriate parameters: IForgeInstaller forgeInstaller = new LegacyForgeInstaller { ForgeExecutablePath = \"[PATH_TO_YOUR_FORGE_INSTALLER]\", RootPath = \"[GAME_ROOT_PATH]\", CustomId = \"[CUSTOM_INSTALL_GAME_ID]\", ForgeVersion = \"[FORGE_VERSION]\", InheritsFrom = \"[MC_VERSION_OR_GAME_ID]\" }; In the above code block, please replace these parameters according to your actual situation: Project Description [GAME_ROOT_PATH] The game root directory, usually the path to the .minecraft folder [CUSTOM_INSTALL_GAME_ID] Optional, customize the name of the game to be installed [MC_VERSION_OR_GAME_ID] The MineCraft original game version inherited by Forge, usually the game version. For example: 1.19.2 Initialize the new version of the installer IForgeInstaller forgeInstaller = new HighVersionForgeInstaller { ForgeExecutablePath = \"[PATH_TO_YOUR_FORGE_INSTALLER]\", JavaExecutablePath = \"[PATH_TO_YOUR_JAVA_RUNTIME]\", RootPath = \"[GAME_ROOT_PATH]\", VersionLocator = [VERSION_LOCATOR_INST], DownloadUrlRoot = “[LIBRARIES_URL_ROOT]”, CustomId = \"[CUSTOM_INSTALL_GAME_ID]\", MineCraftVersion = \"[MC_VERSION]\", MineCraftVersionId = \"[ACTUAL_MC_GAME_ID]\", InheritsFrom = \"[MC_VERSION_OR_GAME_ID]\" }; In the above code block, please replace these parameters according to your actual situation: Project Description [PATH_TO_YOUR_JAVA_RUNTIME] The path where Java (javaw.exe) runtime is located [LIBRARIES_URL_ROOT] The root URL of the download source, for example: \"https://bmclapi2.bangbang93.com/\" [VERSION_LOCATOR_INST] Game version locator instance, that is, the VersionLocator attribute when initializing the game core [ACTUAL_MC_GAME_ID] The actual MineCraft game name, the name of the original game in the version folder. Normally, this value is consistent with [MC_VERSION]. Uniform initialization based on isLegacy value Because LegacyForgeInstaller and HighVersionForgeInstaller both implement the IForgeInstaller interface. Therefore, you can easily use a ternary operator to selectively initialize the corresponding installer: var isLegacy = ForgeInstallerFactory.IsLegacyForgeInstaller(forgeJarPath, forgeVersion); IForgeInstaller forgeInstaller = isLegacy ? new LegacyForgeInstaller { ForgeExecutablePath = \"[PATH_TO_YOUR_FORGE_INSTALLER]\", RootPath = \"[GAME_ROOT_PATH]\", CustomId = \"[CUSTOM_INSTALL_GAME_ID]\", ForgeVersion = \"[FORGE_VERSION]\", InheritsFrom = \"[MC_VERSION_OR_GAME_ID]\" } : new HighVersionForgeInstaller { ForgeExecutablePath = \"[PATH_TO_YOUR_FORGE_INSTALLER]\", JavaExecutablePath = \"[PATH_TO_YOUR_JAVA_RUNTIME]\", RootPath = \"[GAME_ROOT_PATH]\", VersionLocator = [VERSION_LOCATOR_INST], DownloadUrlRoot = “[LIBRARIES_URL_ROOT]”, CustomId = \"[CUSTOM_INSTALL_GAME_ID]\", MineCraftVersion = \"[MC_VERSION]\", MineCraftVersionId = \"[ACTUAL_MC_GAME_ID]\", InheritsFrom = \"[MC_VERSION_OR_GAME_ID]\" }; Start installation After you complete the initialization of the installer, you only need to call the installation method of the Forge installer to complete the installation. In an asynchronous context, use InstallForgeTaskAsync to complete the installation: await forgeInstaller.InstallForgeTaskAsync(); In a sync context, use InstallForge to complete the installation: forgeInstaller.InstallForge(); Report installation progress In some cases, the Forge installer may take several minutes to complete the installation. Therefore, you may need to report the current progress of the installer to the user in real time. For this purpose, the Forge installer provides the StageChangedEventDelegate event to help you implement task reporting. You simply need to register for the following event before starting the installation: ((InstallerBase)forgeInstaller).StageChangedEventDelegate += (_, args) => { ReportProgress(args.Progress * 100, args.CurrentStage); }; Among them, args.Progress indicates the current percentage progress of the installer. args.CurrentStage is a text description of the current progress of the installer."
  },
  "temp/docs-main/enUS/projbobcat/installers/index.html": {
    "href": "temp/docs-main/enUS/projbobcat/installers/index.html",
    "title": "| Qomicex.Core API文档",
    "summary": "#Installer In ProjBobcat, we've implemented most of the modding infrastructure you're likely to encounter during MineCraft development for developers. Support list Project Name Support Status Forge (old version) Supported ✅ Forge (new version) Supported ✅ NeoForge Supported (Experimental) ⚠ LiteLoader Supported ✅ Fabric Supported ✅ Optifine Supported ✅ Quilt Supported (Experimental) ⚠ CurseForge Integration Pack Supported ✅"
  },
  "temp/docs-main/enUS/projbobcat/installers/liteloader.html": {
    "href": "temp/docs-main/enUS/projbobcat/installers/liteloader.html",
    "title": "LiteLoader Installer | Qomicex.Core API文档",
    "summary": "LiteLoader Installer [[toc]] ::: tip Please note that ProjBobcat only implements the LiteLoader automated installation process. You still need to implement the search, download, and save process of the LiteLoader installation package yourself. ::: ::: warning LiteLoader, as the early Minecraft mod system, has lacked maintenance and follow-up support for a long time. Therefore, we may remove support for LiteLoader installation in future release. ::: Resources LiteLoader Versions API BMCLAPI Development documentation Get LiteLoader Download Version Model Because ProjBobcat's LiteLoader installer requires you to provide download information from the LiteLoader when initializing the installer. Therefore, we will briefly describe here how to obtain this information based on a given MineCraft version. ::: info In this example, we'll be using Minecraft 1.7.10 to show you how to get it. ::: ::: warning Since LiteLoader officially does not provide public API documentation. Therefore, in this process, we need to use a third-party mirror source to complete data acquisition. Here, we use BMCLAPI to obtain relevant version information. ::: First, you need to send an HTTP GET request to https://bmclapi2.bangbang93.com/liteloader/list?mcversion=[MC_VERSION]. Replace [MC_VERSION] with the Minecraft version you want to install. Here we will use 1.7.10 for demostration. You will see something similar to the following returned: { \"_id\": \"59685511433f993503c1c879\", \"mcversion\": \"1.7.10\", \"build\": { \"tweakClass\": \"com.mumfrey.liteloader.launch.LiteLoaderTweaker\", \"libraries\": [...], \"stream\": \"RELEASE\", \"file\": \"liteloader-1.7.10.jar\", \"version\": \"1.7.10_04\", \"md5\": \"63ada46e033d0cb6782bada09ad5ca4e\", \"timestamp\": \"1414368553\", \"srcJar\": \"liteloader-1.7.10_04-mcpnames-sources.jar\", \"mcpJar\": \"liteloader-1.7.10_04-mcpnames.jar\" }, \"hash\": \"63ada46e033d0cb6782bada09ad5ca4e\", \"type\": \"RELEASE\", \"version\": \"1.7.10_04\", \"__v\": 0 } BMCLAPI will return a JSON object, and deserializing the object into the ProjBobcat type is the LiteLoaderDownloadVersionModel we need. Convert JSON return to ProjBobcat type If you are using JSON.NET(Newtonsoft.JSON) in your project. You can use code similar to the following to convert the server response you get into the corresponding ProjBobcat type: // Requesting data from BMCLAPI (example, not actual code) ... var responseJson = await res.Content.ReadAsStringAsync(); // Convert JSON response to ProjBobcat type // [!code focus] var versionModel = JsonConvert.DeserializeObject<LiteLoaderDownloadVersionModel>(responseJson); // [!code focus] This versionModel is the LiteLoaderDownloadVersionMode required by the Fabric installer. Get RawVersionModel When initializing the LiteLoader installer, the installer needs to use the raw JSON content of the MineCraft game version corresponding to the LiteLoader. That is, the contents of the [ROOT_PATH]/versions/[MC_VERSION]/[MC_VERSION].json file. If you have installed the original game corresponding to LiteLoader, you can get the RawVersionModel through the following code: // Get the path to the version JSON file var jsonPath = GamePathHelper.GetGameJsonPath(rP, id); // Read the contents of the file var jsonContent = await File.ReadAllTextAsync(jsonPath); // Convert JSON content to RawVersionModel var baseVersionModel = JsonConvert.DeserializeObject<RawVersionModel>(jsonContent); This baseVersionModel is the RawVersionModel required by the LiteLoader installer. Initialize the installer The way to initialize the LiteLoader installer is very simple. You need to initialize the installer using the versionModel and baseVersionModel obtained in the previous steps: var liteLoaderInstaller = new LiteLoaderInstaller { InheritVersion = baseVersionModel, InheritsFrom = \"[MC_VERSION_OR_GAME_ID]\", RootPath = \"[GAME_ROOT_PATH]\", VersionModel = versionModel, CustomId = \"[CUSTOM_INSTALL_GAME_ID]\" }; In the above code block, please replace these parameters according to your actual situation: Project Description [GAME_ROOT_PATH] The game root directory, usually the path to the .minecraft folder [CUSTOM_INSTALL_GAME_ID] Optional, customize the name of the game to be installed [MC_VERSION_OR_GAME_ID] The Minecraft original game version inherited by Forge, usually the game version. For example: 1.19.2 [VERSION_LOCATOR_INST] Game version locator instance, that is, the VersionLocator attribute when initializing the game core start installation After you complete the initialization of the installer, you only need to call the installation method of the LiteLoader installer to complete the installation. In an asynchronous context, use InstallTaskAsync to complete the installation: await liteLoaderInstaller.InstallTaskAsync(); In a sync context, use Install to complete the installation: liteLoaderInstaller.Install(); Report installation progress In some cases, the LiteLoader installer may take several minutes to complete the installation. Therefore, you may need to report the current progress of the installer to the user in real time. To this end, the LiteLoader installer provides the StageChangedEventDelegate event to help you implement task reporting. You simply need to register for the following event before starting the installation: liteLoaderInstaller.StageChangedEventDelegate += (_, args) => { ReportProgress(args.Progress, args.CurrentStage); }; Among them, args.Progress indicates the current percentage progress of the installer. args.CurrentStage is a text description of the current progress of the installer."
  },
  "temp/docs-main/enUS/projbobcat/installers/optifine.html": {
    "href": "temp/docs-main/enUS/projbobcat/installers/optifine.html",
    "title": "Optifine Installer | Qomicex.Core API文档",
    "summary": "Optifine Installer [[toc]] ::: tip Please note that ProjBobcat only implements the Optifine automated installation process. You still need to implement the search, download, and save process of the Optifine installation package yourself. ::: Resources BMCLAPI Development Documentation Get Optifine Download Version Model Because ProjBobcat's Optifine installer requires you to provide download information from Optifine when initializing the installer. Therefore, we will briefly describe here how to obtain this information based on a given Minecraft version. ::: info In this example, we'll be using Minecraft version 1.19.2 to show you how to get it. ::: ::: warning Since Optifine officially does not provide public API documentation. Therefore, in this process, we need to use a third-party mirror source to complete data acquisition. Here, we use BMCLAPI to obtain relevant version information. ::: First, you need to send an HTTP GET request to https://bmclapi2.bangbang93.com/optifine/[MC_VERSION]. Replace [MC_VERSION] with the MineCraft version you want to install. Here we will use version 1.19.2. You will see something similar to the following returned: [ { \"_id\": \"6307b8a38a3998ab475d139d\", \"mcversion\": \"1.19.2\", \"patch\": \"H9\", \"type\": \"HD_U\", \"__v\": 0, \"filename\": \"OptiFine_1.19.2_HD_U_H9.jar\", \"forge\": \"Forge 43.1.1\" }, {...}, {...} ] BMCLAPI will return a JSON array, and each element in the array is the Download Version Model we need. Convert JSON return to ProjBobcat type If you are using JSON.NET(Newtonsoft.JSON) in your project. You can use code similar to the following to convert the server response you get into the corresponding ProjBobcat type: // Requesting data from BMCLAPI (example, not actual code) ... var responseJson = await res.Content.ReadAsStringAsync(); // Convert JSON response to ProjBobcat type // [!code focus] var versions = JsonConvert.DeserializeObject<List<OptifineDownloadVersionModel>>(responseJson); // [!code focus] // Get the version the user wants to install (example, not actual code) var userSelect = vm.SelectedIndex; // Get a single Download Version Model // [!code focus] var selectedVersion = versions[userSelect]; // [!code focus] Here, selectedVersion is the OptifineDownloadVersionModel required by the Optifine installer. Initialize the installer The way to initialize the Optifine installer is very simple. You first need to prepare the Optifine installation package .jar file. and a Java runtime available. You need to initialize the installer using the selectedVersion obtained in the previous step: var optifineInstaller = new OptifineInstaller { JavaExecutablePath = \"[PATH_TO_YOUR_JAVA_RUNTIME]\", OptifineDownloadVersion = selectedVersion, OptifineJarPath = \"[PATH_TO_YOUR_OPTIFINE_JAR]\", RootPath = \"[GAME_ROOT_PATH]\", CustomId = \"[CUSTOM_INSTALL_GAME_ID]\", InheritsFrom = \"[MC_VERSION_OR_GAME_ID]\" }; In the above code block, please replace these parameters according to your actual situation: Project Description [GAME_ROOT_PATH] The game root directory, usually the path to the .minecraft folder [CUSTOM_INSTALL_GAME_ID] Optional, customize the name of the game to be installed [MC_VERSION_OR_GAME_ID] The MineCraft original game version inherited by Forge, usually the game version. For example: 1.19.2 [VERSION_LOCATOR_INST] Game version locator instance, that is, the VersionLocator attribute when initializing the game core [PATH_TO_YOUR_OPTIFINE_JAR] The path where the Optifine installation package is located [PATH_TO_YOUR_JAVA_RUNTIME] The path where Java (javaw.exe) runtime is located start installation After you complete the initialization of the installer, you only need to call the installation method of the Optifine installer to complete the installation. In an asynchronous context, use InstallTaskAsync to complete the installation: await optifineInstaller.InstallTaskAsync(); In a sync context, use Install to complete the installation: optifineInstaller.Install(); Report installation progress In some cases, the Optifine installer may take several minutes to complete the installation. Therefore, you may need to report the current progress of the installer to the user in real time. For this purpose, the Optifine installer provides the StageChangedEventDelegate event to help you implement task reporting. You simply need to register for the following event before starting the installation: optifineInstaller.StageChangedEventDelegate += (_, args) => { ReportProgress(args.Progress, args.CurrentStage); }; Among them, args.Progress indicates the current percentage progress of the installer. args.CurrentStage is a text description of the current progress of the installer."
  },
  "temp/docs-main/enUS/projbobcat/installers/quilt.html": {
    "href": "temp/docs-main/enUS/projbobcat/installers/quilt.html",
    "title": "Quilt 安装器 | Qomicex.Core API文档",
    "summary": "Quilt 安装器 [[toc]] ::: tip Please note that ProjBobcat only implements the Quilt automated installation process. You still need to implement the search, download, and save process of the Quilt installation package yourself. ::: ::: warning The Quilt installer is currently in an experimental stage, and the related API and installation process may undergo significant changes. ::: Resources Quilt Website Quilt Documentation Quilt Meta API Compatibility check Before you start installing Quilt, you need to query whether the version of MineCraft you are modifying is supported via the Quilt Meta API. First, you need to send an HTTP GET request to https://meta.quiltmc.org/v3/versions/game. You will see something similar to the following returned: [ { \"version\": \"1.19.3\", \"stable\": true }, { \"version\": \"1.19.3-rc3\", \"stable\": false }, {...}, {...} ] Here, you need to check whether the game version you are about to install appears in Quilt's official support list. You need to compare the game version with the version field in the JSON object. **If your game does not appear on the support list, the installation will not continue. ** Get Quilt Loader Model Because ProjBobcat's Quilt installer requires you to provide download information from Quilt when initializing the installer. Therefore, we will briefly describe here how to obtain this information based on a given MineCraft version. ::: info In this example, we'll be using Minecraft version 1.19.2 to show you how to get it. ::: First, you need to send an HTTP GET request to https://meta.quiltmc.org/v3/versions/loader. You will see something similar to the following returned: [ { \"separator\": \".\", \"build\": 25, \"maven\": \"org.quiltmc:quilt-loader:0.18.1-beta.25\", \"version\": \"0.18.1-beta.25\" }, {...}, {...} ] Quilt Meta API will return a JSON array, and each element in the array is the Loader Artifact we need. Convert JSON return to ProjBobcat type If you are using JSON.NET(Newtonsoft.JSON) in your project. You can use code similar to the following to convert the server response you get into the corresponding ProjBobcat type: // Requesting data from the Quilt Meta API (example, not actual code) ... var responseJson = await res.Content.ReadAsStringAsync(); // Convert JSON response to ProjBobcat type // [!code focus] var artifacts = JsonConvert.DeserializeObject<List<QuiltLoaderModel>>(responseJson); // [!code focus] // Get the version the user wants to install (example, not actual code) var userSelect = vm.SelectedArtifactIndex; // Get a single Loader Artifact // [!code focus] var selectedArtifact = artifacts[userSelect]; // [!code focus] This selectedArtifact is the QuiltLoaderModel required by the Fabric installer. Initialize the installer Initializing the Quilt installer is very simple. You need to use the selectedArtifact obtained in the previous step to initialize the installer: var quiltInstaller = new QuiltInstaller { InheritsFrom = \"[MC_VERSION_OR_GAME_ID]\", RootPath = \"[GAME_ROOT_PATH]\", CustomId = \"[CUSTOM_INSTALL_GAME_ID]\", LoaderArtifact = selectedArtifact }; In the above code block, please replace these parameters according to your actual situation: Project Description [GAME_ROOT_PATH] The game root directory, usually the path to the .minecraft folder [CUSTOM_INSTALL_GAME_ID] Optional, customize the name of the game to be installed [MC_VERSION_OR_GAME_ID] The Minecraft original game version inherited by Forge, usually the game version. For example: 1.19.2 start installation After you complete the initialization of the installer, you only need to call the installation method of the Fabric installer to complete the installation. In an asynchronous context, use InstallTaskAsync to complete the installation: await quiltInstaller.InstallTaskAsync(); In a sync context, use Install to complete the installation: quiltInstaller.Install(); Report installation progress In some cases, the Quilt installer may take several minutes to complete the installation. Therefore, you may need to report the current progress of the installer to the user in real time. For this purpose, the Quilt installer provides the StageChangedEventDelegate event to help you implement task reporting. You simply need to register for the following event before starting the installation: quiltInstaller.StageChangedEventDelegate += (_, args) => { ReportProgress(args.Progress, args.CurrentStage); }; Among them, args.Progress indicates the current percentage progress of the installer. args.CurrentStage is a text description of the current progress of the installer."
  },
  "temp/docs-main/enUS/projbobcat/resourceCompleter/createAndConfigCompleter.html": {
    "href": "temp/docs-main/enUS/projbobcat/resourceCompleter/createAndConfigCompleter.html",
    "title": "Create and configure completers | Qomicex.Core API文档",
    "summary": "Create and configure completers [[toc]] Initialize the completer The method of creating a resource completer is very simple. You only need to use the following code to complete the initialization of the completer: var completer = new DefaultResourceCompleter { MaxDegreeOfParallelism = [MAX_DEGREE_OF_PARALLELISM], ResourceInfoResolvers = new List<IResourceInfoResolver> { ... // Initialization of resource information resolvers }, TotalRetry = [NUMBER_OF_TOTAL_RETRY], CheckFile = [CHECK_FILE_AFTER_DOWNLOADED], DownloadParts = [TOTAL_DOWNLOAD_SEGMENTS_FOR_LARGE_FILE] }; ::: tip For tutorials on the initialization of the resource information resolver, please refer to the chapter Resource Information Resolver ::: In the above code block, please replace these parameters according to your actual situation: Project Data Type Description [MAX_DEGREE_OF_PARALLELISM] INT Resource check parallelism (check the number of game resources at the same time) [CHECK_FILE_AFTER_DOWNLOADED] BOOLEAN Check file integrity after file download is complete (if resource checksum exists) [TOTAL_DOWNLOAD_SEGMENTS_FOR_LARGE_FILE] INT Number of fragments when downloading large files ::: warning [MAX_DEGREE_OF_PARALLELISM] and [TOTAL_DOWNLOAD_SEGMENTS_FOR_LARGE_FILE] Please adjust the value according to the hardware performance as appropriate. Setting a value that is too large may cause a decrease in throughput. ::: Complete game resources After initializing the resource completer, you only need to call the completion method to start checking and completing operations: In an asynchronous context, use CheckAndDownloadTaskAsync to complete the installation: var result = await completer.CheckAndDownloadTaskAsync(); // [!code focus] if (result.TaskStatus == TaskResultStatus.Error && (result.Value?.IsLibDownloadFailed ?? false)) { // After completing the completion, the resource inspector will return the execution results. // You can check the property value in result to determine whether completion is complete // IsLibDownloadFailed will reflect whether the library files necessary for startup have been successfully completed. // Generally speaking, if the completion of the library file fails, it is likely to cause the game to fail to start. } In a sync context, use CheckAndDownload to complete the installation: var result = completer.CheckAndDownload(); // [!code focus] Report progress In some cases, the resource completer may take several minutes to complete checking and downloading the resource. Therefore, you may need to report the completer's current progress to the user in real time. Report Resource Inspector progress You can get real-time check progress by registering the event GameResourceInfoResolveStatus: completer.GameResourceInfoResolveStatus += (_, args) => { ReportProgress(args.Progress, args.Status); }; Among them, args.Progress indicates the current percentage progress of the checker. args.Status is a text description of the current progress of the checker. Report completion file download progress You can get real-time check progress by registering the event DownloadFileCompletedEvent: completer.DownloadFileCompletedEvent += (sender, args) => { // The sender parameter is the last successfully downloaded file of the completer, the type is DownloadFile // args returns the download status of the file (success/failure), and the retry count of the file, // Type is DownloadFileCompletedEventArgs }; ::: tip DownloadFile Class Structure DownloadFileCompletedEventArgs Event Structure ::: Report progress information for files being downloaded You can get real-time check progress by registering the event DownloadFileChangedEvent: rC.DownloadFileChangedEvent += (_, args) => { // args returns the specific information of the file being downloaded (number of bytes received, total number of bytes, current speed, percentage progress) // Type is DownloadFileChangedEventArgs }; ::: tip DownloadFileChangedEventArgs Event Structure :::"
  },
  "temp/docs-main/enUS/projbobcat/resourceCompleter/index.html": {
    "href": "temp/docs-main/enUS/projbobcat/resourceCompleter/index.html",
    "title": "Resource completer | Qomicex.Core API文档",
    "summary": "Resource completer In ProjBobcat, we provide developers with a completer for completing Minecraft core resource files. These resources include: game audio, materials, textures, language files, library files necessary for startup, etc."
  },
  "temp/docs-main/enUS/projbobcat/resourceCompleter/resourceInfoResolver/assetInfoResolver.html": {
    "href": "temp/docs-main/enUS/projbobcat/resourceCompleter/resourceInfoResolver/assetInfoResolver.html",
    "title": "Assets resolver | Qomicex.Core API文档",
    "summary": "Assets resolver [[toc]] The Assets resolver provides parsing and verification functions for game asset files. These files are generally stored in .minecraft/assets directory Get the Version Manifest Versions list First, you need to submit a request to https://launchermeta.mojang.com/mc/game/version_manifest.json Send an HTTP GET request. You will see something similar to the following returned: { \"latest\": { \"release\": \"1.19.3\", \"snapshot\": \"23w06a\" }, \"versions\": [ { \"id\": \"23w06a\", \"type\": \"snapshot\", \"url\": \"https://piston-meta.mojang.com/v1/packages/92ed97b686fe8904d8ec00fd486c435582fd0155/23w06a.json\", \"time\": \"2023-02-08T15:11:06+00:00\", \"releaseTime\": \"2023-02-08T15:00:04+00:00\" }, ... ] } The Mojang server will return a JSON object, and the versions field is the Versions array we need. Convert JSON return to ProjBobcat type If you are using JSON.NET(Newtonsoft.JSON) in your project. You can use code similar to the following to convert the server response you get into the corresponding ProjBobcat type: // Requesting data from the Mojang API (example, not actual code) ... var responseJson = await res.Content.ReadAsStringAsync(); // Convert JSON response to ProjBobcat type // [!code focus] var manifest = JsonConvert.DeserializeObject<VersionManifest>(responseJson); // [!code focus] // Get the Versions list // [!code focus] var versions = manifest.Versions; // [!code focus] Here, versions is the Versions array required by the Assets resolver. Initialize resolver You can initialize the Assets resolver with the following code: var resolver = new AssetInfoResolver { AssetIndexUriRoot = \"https://launchermeta.mojang.com/\", AssetUriRoot = \"https://resources.download.minecraft.net/\", BasePath = \"[GAME_ROOT_PATH]\", VersionInfo = [SEARCHED_VERSION_INFO], CheckLocalFiles = [CHECK_LOCAL_FILES], Versions = versions // Versions array obtained in the previous step }; In the above code block, please replace these parameters according to your actual situation: Project Description [GAME_ROOT_PATH] The game root directory, usually the path to the .minecraft folder [SEARCHED_VERSION_INFO] VersionInfo of the version to check (obtained via game locator) [CHECK_LOCAL_FILES] Check local files (if false, skip all checks)"
  },
  "temp/docs-main/enUS/projbobcat/resourceCompleter/resourceInfoResolver/gameLoggingInfoResolver.html": {
    "href": "temp/docs-main/enUS/projbobcat/resourceCompleter/resourceInfoResolver/gameLoggingInfoResolver.html",
    "title": "log4j log formatting component resolver | Qomicex.Core API文档",
    "summary": "log4j log formatting component resolver [[toc]] The log4j log formatting component resolver provides parsing and verification functions for game asset files. These files are stored in .minecraft/logging directory Using this resource resolver allows MineCraft to output log content formatted by log4j, similar to the following: <log4j:Event logger=\"ekb\" timestamp=\"1676012129\" level=\"INFO\" thread=\"Render thread\"> <log4j:Message> <![CDATA[Created: 512x512x4 minecraft:textures/atlas/shulker_boxes.png-atlas]]> </log4j:Message> </log4j:Event> Initialize Resolver You can initialize the log4j log formatting component resolver with the following code: var resolver = new GameLoggingInfoResolver { BasePath = \"[GAME_ROOT_PATH]\", VersionInfo = [SEARCHED_VERSION_INFO], CheckLocalFiles = [CHECK_LOCAL_FILES] }; In the above code block, please replace these parameters according to your actual situation: Project Description [GAME_ROOT_PATH] The game root directory, usually the path to the .minecraft folder [SEARCHED_VERSION_INFO] VersionInfo of the version to check (obtained via game locator) [CHECK_LOCAL_FILES] Check local files (if false, skip all checks)"
  },
  "temp/docs-main/enUS/projbobcat/resourceCompleter/resourceInfoResolver/index.html": {
    "href": "temp/docs-main/enUS/projbobcat/resourceCompleter/resourceInfoResolver/index.html",
    "title": "Resource information resolver | Qomicex.Core API文档",
    "summary": "Resource information resolver In ProjBobcat, we use ResourceInfoResolver (ResourceInfoResolver) to help the resource completer identify missing files in MineCraft. The following table shows the resource resolvers currently supported by ProjBobcat: Class name Introduction AssetInfoResolver Used to parse the assets required by the game (audio, language, fonts, textures, etc.) GameLoggingInfoResolver Used to parse the log4j log formatting component officially provided by MineCraft LibraryInfoResolver Used to parse library files necessary for game startup VersionInfoResolver Used to parse JAR files provided in game JSON"
  },
  "temp/docs-main/enUS/projbobcat/resourceCompleter/resourceInfoResolver/libraryInfoResolver.html": {
    "href": "temp/docs-main/enUS/projbobcat/resourceCompleter/resourceInfoResolver/libraryInfoResolver.html",
    "title": "Libraries resolver | Qomicex.Core API文档",
    "summary": "Libraries resolver [[toc]] The Libraries resolver provides parsing and verification functions for game asset files. These files are stored in In the .minecraft/libraries directory, these files are the runtime files necessary to start MineCraft. Initialize the resolver You can initialize the Libraries resolver with the following code: var resolver = new LibraryInfoResolver { BasePath = \"[GAME_ROOT_PATH]\", ForgeUriRoot = \"https://files.minecraftforge.net/maven/\", ForgeMavenUriRoot = \"https://maven.minecraftforge.net/\", ForgeMavenOldUriRoot = \"https://files.minecraftforge.net/maven/\", FabricMavenUriRoot = \"https://maven.fabricmc.net/\", LibraryUriRoot = \"https://libraries.minecraft.net/\", VersionInfo = [SEARCHED_VERSION_INFO], CheckLocalFiles = [CHECK_LOCAL_FILES] }; In the above code block, please replace these parameters according to your actual situation: Project Description [GAME_ROOT_PATH] The game root directory, usually the path to the .minecraft folder [SEARCHED_VERSION_INFO] VersionInfo of the version to check (obtained via game locator) [CHECK_LOCAL_FILES] Check local files (if false, skip all checks)"
  },
  "temp/docs-main/enUS/projbobcat/resourceCompleter/resourceInfoResolver/versionInfoResolver.html": {
    "href": "temp/docs-main/enUS/projbobcat/resourceCompleter/resourceInfoResolver/versionInfoResolver.html",
    "title": "Version information resolver | Qomicex.Core API文档",
    "summary": "Version information resolver [[toc]] The version information resolver provides parsing and verification functions for game asset files. These files are stored in .minecraft/versions/{GAME_VERSION}/{GAME_VERSION}.jar directory. These files are the core files necessary to start MineCraft. Initialize the parser You can initialize the initialization parser with the following code: var resolver = new VersionInfoResolver { BasePath = \"[GAME_ROOT_PATH]\", VersionInfo = [SEARCHED_VERSION_INFO], CheckLocalFiles = [CHECK_LOCAL_FILES] }; In the above code block, please replace these parameters according to your actual situation: Project Description [GAME_ROOT_PATH] The game root directory, usually the path to the .minecraft folder [SEARCHED_VERSION_INFO] VersionInfo of the version to check (obtained via game locator) [CHECK_LOCAL_FILES] Check local files (if false, skip all checks)"
  },
  "temp/docs-main/enUS/skin/index.html": {
    "href": "temp/docs-main/enUS/skin/index.html",
    "title": "Minecraft Skin Specifications (1.18+) | Qomicex.Core API文档",
    "summary": "Minecraft Skin Specifications (1.18+) Here are the new skin specs starting with Minecraft 1.18 Sample 1 Sample 2 (including grid)"
  },
  "temp/docs-main/enUS/team.html": {
    "href": "temp/docs-main/enUS/team.html",
    "title": "| Qomicex.Core API文档",
    "summary": "import { VPTeamPage, VPTeamPageTitle, VPTeamMembers } from 'vitepress/theme'; const members = [ { avatar: 'https://www.github.com/laolarou726.png', name: 'laolarou726', title: 'Founder', links: [ { icon: 'github', link: 'https://github.com/laolarou726' } ] }, { avatar: 'https://github.com/CodingEric.png', name: 'CodingEric', title: 'UI / UX', links: [ { icon: 'github', link: 'https://github.com/CodingEric' } ] }, { avatar: 'https://github.com/leon-o.png', name: 'Leon', title: 'UI, Back-end, Operator and Maintainer', links: [ { icon: 'github', link: 'https://github.com/leon-o' } ] }, { avatar: 'https://github.com/komorebi64.png', name: 'Croteco', title: 'Back-end, Operator and Maintainer', links: [ { icon: 'github', link: 'https://github.com/komorebi64' } ] }, { avatar: 'https://github.com/fr1g.png', name: 'Feiron Iguista', title: 'Front-end, Minecraft Server Operator and Maintainer', links: [ { icon: 'github', link: 'https://github.com/fr1g' } ] } ]; Our Team Corona Studio is a team of professionals and enthusiasts with Minecraft third-party game services as its core business. Was formerly the CMFL development team."
  },
  "temp/docs-main/index.html": {
    "href": "temp/docs-main/index.html",
    "title": "| Qomicex.Core API文档",
    "summary": "其他Corona Studio链接 Corona Studio官网 Corona Studio MIN 查看友链 \uE724"
  },
  "temp/docs-main/ruRU/CMFS/index.html": {
    "href": "temp/docs-main/ruRU/CMFS/index.html",
    "title": "欢迎来到 CMFS 指南 | Qomicex.Core API文档",
    "summary": "欢迎来到 CMFS 指南 首先, 感谢你选择加入 CraftMineFun Server Minecraft群组服务器（以下简称CMFS）. 本系列指南将会帮助你理解关于CMFS的一切, 并发挥你的主观能动性, 利用我们提供的特色玩法来建设、游览. 和您的朋友们一起, 抑或是在这里认识新朋友, 合作游玩, 或者竞赛角逐. 请放心, 由我们的团队来维护您的体验. 如果您遇到了游玩体验上的问题, 请立即联系我们！ [[toc]] :::warning 所有服务器处于暂停运营的状态 请等待另行通知（2022年11月27日） 或加入群 419902868 等待第一时间的通知. ::: 组成部分 CMFS-Pure 纯净生存服务器！您可以通过特定版本的Minecraft来加入游戏, 体验由我们精心构思的独特玩法. 这个服务器正在维护 CMFS-SquareCraft 枘方世界服务器 我们和枘方世界合作的Mod服务器. 在我们高性能的稳定的服务器中享受Minecraft“活的灵魂”：高度自由, 高度扩展. 这个服务器处于设想状态 CMFS-Eksamen 您可以自由地加入这个服务器以申请进行日冕工作室的建筑组（日冕重工）的审核. 这里本质上是个原版创造模式建筑服, 在我们严格的环境中体现您的Minecraft建筑实力. 当我们有招新需求时, 会根据已提交审核的作品质量发出进一步审核的邀请：通过后, 您将加入我们的建筑组, 或许您不仅能在这里发展自身能力, 还能在这里发现同好？ 这个服务器正在构件中 CMFS-Juego 这里有我们准备的各种主流的小游戏和竞技场, 以及由我们构思的独特小游戏. 其中区分多个不同的游戏版本, 提供了不同时代的体验. 这个服务器暂无负责人 CMFS-Login “四通八达. ” 这个服务器是整个CMFS的入口, 是负责分散诸位玩家到其想要到达的服务器的中转服务器. 您需要在这里通过CMFS账号或绑定CMFS账号的日冕服务账号来登入群组服. 这个服务器需要和Pure一并重构 CMFS-Pure 指南"
  },
  "temp/docs-main/ruRU/dashboard/index.html": {
    "href": "temp/docs-main/ruRU/dashboard/index.html",
    "title": "在这里你可以看到有关仪表盘组件的一些帮助知识 | Qomicex.Core API文档",
    "summary": "在这里你可以看到有关仪表盘组件的一些帮助知识"
  },
  "temp/docs-main/ruRU/dashboard/search.html": {
    "href": "temp/docs-main/ruRU/dashboard/search.html",
    "title": "如何使用仪表盘搜索 | Qomicex.Core API文档",
    "summary": "如何使用仪表盘搜索 您可以在聚合搜索输入框中输入任何您想要查找的内容. 在您输入内容后, 下方会弹出智能提示来帮助您快速的导航到搜索结果页面 使用指定的搜索引擎来查找内容 在默认情况下, LauncherX 会使用 必应（Bing）来查找您的搜索内容. 如果您想指定聚合搜索使用的搜索引擎, 您可以在您的搜索内容前加入下面的前缀： 搜索引擎 值 百度 bd: 谷歌 g: 必应 b: 样例 使用百度搜索 “1.16.5材质包”：bd:1.16.5材质包 使用谷歌搜索 “1.16.5材质包”：g:1.16.5材质包 使用必应搜索 “1.16.5材质包”：b:1.16.5材质包"
  },
  "temp/docs-main/ruRU/guide/index.html": {
    "href": "temp/docs-main/ruRU/guide/index.html",
    "title": "欢迎来到日冕知识库（CSKB） | Qomicex.Core API文档",
    "summary": "欢迎来到日冕知识库（CSKB） 在这里您可以查阅到日冕工作室所属项目的部分技术文档、疑难解答, 以及 Minecraft 相关的各种技术规范和样例"
  },
  "temp/docs-main/ruRU/index.html": {
    "href": "temp/docs-main/ruRU/index.html",
    "title": "| Qomicex.Core API文档",
    "summary": ""
  },
  "temp/docs-main/ruRU/projbobcat/additionalParsers/accountProfileParser.html": {
    "href": "temp/docs-main/ruRU/projbobcat/additionalParsers/accountProfileParser.html",
    "title": "Парсер игровых аккаунтов | Qomicex.Core API文档",
    "summary": "Парсер игровых аккаунтов Парсер игровых профилей отвечает за запись учетных записей пользователей в файл конфигурации официального лаунчера. Инициализация парсера Способ инициализации парсера очень прост: var launcherAccountParser = new DefaultLauncherAccountParser(rootPath, clientToken) Где rootPath — это корневой каталог, в котором находится ядро (т. е. каталог, в котором находится папка .minecraft). clientToken — это случайно сгенерированный GUID."
  },
  "temp/docs-main/ruRU/projbobcat/additionalParsers/gameProfileParser.html": {
    "href": "temp/docs-main/ruRU/projbobcat/additionalParsers/gameProfileParser.html",
    "title": "Парсер игровых профилей | Qomicex.Core API文档",
    "summary": "Парсер игровых профилей Парсер игровых профилей отвечает за запись найденных локальных игр в файл конфигурации официального лаунчера. Инициализация парсера Способ инициализации парсера очень прост: var launcherProfileParser = new DefaultLauncherProfileParser(rootPath, clientToken) Где rootPath — это корневой каталог, в котором находится ядро (т. е. каталог, в котором находится папка .minecraft). clientToken — это случайно сгенерированный GUID."
  },
  "temp/docs-main/ruRU/projbobcat/additionalParsers/index.html": {
    "href": "temp/docs-main/ruRU/projbobcat/additionalParsers/index.html",
    "title": "Дополнительные парсеры | Qomicex.Core API文档",
    "summary": "Дополнительные парсеры Чтобы ProjBobcat вел себя так же, как официальный лаунчер Mojang, мы реализовали для него несколько дополнительных парсеров, которые помогают нам синхронизировать данные и профили с официальным лаунчером. В следующей таблице перечислены парсеры, которые были реализованы в настоящее время: Название Описание DefaultLauncherAccountParser Используется для записи информации о проверке в файл конфигурации официального лаунчера DefaultLauncherProfileParser Используется для записи найденных локальных игр в файл конфигурации лаунчера"
  },
  "temp/docs-main/ruRU/projbobcat/authenticators/index.html": {
    "href": "temp/docs-main/ruRU/projbobcat/authenticators/index.html",
    "title": "Модели аутентификации | Qomicex.Core API文档",
    "summary": "Модели аутентификации В ProjBobcat мы реализовали для разработчиков все сценарии аутентификации, с которыми вы можете столкнуться в процессе разработки Minecraft. Список поддержки Название систем Применимый сценарий OfflineAuthenticator Система оффлайн-аутентификации YggdrasilAuthenticator Подходит для старых систем входа в систему MicrosoftAuthenticator Новая система аутентификации Microsoft"
  },
  "temp/docs-main/ruRU/projbobcat/authenticators/microsoft.html": {
    "href": "temp/docs-main/ruRU/projbobcat/authenticators/microsoft.html",
    "title": "Система аутентификации Microsoft | Qomicex.Core API文档",
    "summary": "Система аутентификации Microsoft [[toc]] Эта системы аутентификации реализует новый процесс аутентификации на основе Azure, который применим ко всем версиям Minecraft, которые в настоящее время обслуживаются. Подготовка Поскольку новый процесс аутентификации использует метод аутентификации на основе Azure. Поэтому, прежде чем начать, убедитесь, что вы завершили конфигурацию приложения Azure. После завершения регистрации приложения Azure убедитесь, что вы завершили инициализацию аутентификатора Microsoft в точке входа программы. Настройка метода предоставления кэшированных учетных данных Из-за особенностей этой системи аутентификации разработчикам необходимо сохранять токен обновления и время истечения срока действия, возвращаемые при первой аутентификации, чтобы помочь аутентификатору завершить аутентификацию. При аутентификации аутентификатор сначала вызовет этот метод, чтобы проверить действительность локального кэша токенов. Если локальный токен все еще действителен, результат аутентификации будет возвращен напрямую. Если токен, кэшированный локально, истек, разработчику необходимо вручную запросить новый токен, а затем вернуть обновленный токен. Ниже мы приводим пример реализации этого метода: public async Task<(bool, GraphAuthResultModel?)> CacheTokenProviderAsync() { if (string.IsNullOrEmpty(XBLToken)) return (false, default); if (string.IsNullOrEmpty(XBLRefreshToken)) return (false, default); // Рассчитать время истечения срока действия // [!code focus] var expireDate = LastRefreshedTime.AddSeconds(ExpiresIn); // [!code focus] // Если локальный кэшированный токен все еще действителен, вернуть текущий токен напрямую // [!code focus] // В противном случае используйте токен обновления для запроса нового токена // [!code focus] if (expireDate > DateTime.Now) { var result = new GraphAuthResultModel // [!code focus] { // [!code focus] ExpiresIn = (int)(expireDate - DateTime.Now).TotalSeconds, // [!code focus] AccessToken = XBLToken, // [!code focus] RefreshToken = XBLRefreshToken // [!code focus] }; // [!code focus] return (true, result); // [!code focus] } // Запросить новый токен входа // [!code focus] var refreshReqDic = new List<KeyValuePair<string, string>> // [!code focus] { // [!code focus] new(\"client_id\", MicrosoftAuthenticator.ApiSettings.ClientId), // [!code focus] new(\"refresh_token\", XBLRefreshToken), // [!code focus] new(\"grant_type\", \"refresh_token\") // [!code focus] }; // [!code focus] using var refreshReq = new HttpRequestMessage(HttpMethod.Post, MicrosoftAuthenticator.MSRefreshTokenRequestUrl) // [!code focus] { // [!code focus] Content = new FormUrlEncodedContent(refreshReqDic) // [!code focus] }; // [!code focus] using var refreshRes = await DefaultClient.SendAsync(refreshReq); var refreshContent = await refreshRes.Content.ReadAsStringAsync(); var refreshModel = MicrosoftAuthenticator.ResolveMSGraphResult(refreshContent, GraphAuthResultModelContext.Default.GraphAuthResultModel); if (refreshModel is not GraphAuthResultModel model) { if (refreshModel is GraphResponseErrorModel error) // [!code focus] { // [!code focus] // Обработка неудачной операции обновления здесь // [!code focus] } // [!code focus] return (false, default); } return (true, model); } Настройка метода отображения кода аутентификации потока устройства при первом входе Поскольку мы используем аутентификацию потока устройства для аутентификации учетной записи Microsoft игрока. Поэтому нам нужен дополнительный метод для отображения пользователю одноразового ключа и адреса аутентификации, необходимых для аутентификации потока устройства. Ниже приведен пример этого метода: private void DeviceTokenNotifier(DeviceIdResponseModel deviceIdResponseModel) { // Отображение полученных данных обратного вызова на внешнем интерфейсе DeviceCodeResponse = deviceIdResponseModel; } DeviceIdResponseModel содержит всю информацию, необходимую пользователю для завершения аутентификации: Название Действие UserCode Ключ, необходимый для аутентификации пользователя VerificationUri Адрес аутентификации, который пользователи должны посетить для выполнения последующих шагов аутентификации ExpiresIn Время истечения срока действия кода аутентификации (секунды) Ниже вы можете увидеть пример интерфейса отображения: В этом интерфейсе вам необходимо включить как минимум следующее содержимое: Ключ, необходимый для входа Конкретный адрес аутентификации Краткая подсказка по работе, чтобы помочь пользователям завершить операцию аутентификации Инициализация аутентификатора Первая аутентификация :::warning Убедитесь, что вы подготовили метод отображения кода аутентификации потока устройства при первом входе перед выполнением следующего процесса, чтобы убедиться, что пользователи могут получить правильную информацию для первого входа! ::: Инициализация аутентификатора: var microsoftAuthenticator = new MicrosoftAuthenticator { LauncherAccountParser = launcherAccountParser }; В приведенном выше блоке кода замените эти параметры в соответствии с вашей реальной ситуацией: Элемент Описание launcherAccountParser Для инициализации парсера учетных записей лаунчера см. здесь Не первая аутентификация Не первая аутентификация — это использование кэша токенов, полученного при первой аутентификации, для вторичной аутентификации. В основном он проверяет, действительны ли локальные учетные данные через CacheTokenProviderAsync. Если токен, кэшированный локально, истек, он будет обновлен в этом методе. Инициализация аутентификатора: var microsoftAuthenticator = new MicrosoftAuthenticator { CacheTokenProvider = CacheTokenProviderAsync, Email = \"[EMAIL]\", LauncherAccountParser = launcherAccountParser }; В приведенном выше блоке кода замените эти параметры в соответствии с вашей реальной ситуацией: Элемент Описание launcherAccountParser Для инициализации парсера учетных записей лаунчера см. здесь [EMAIL] Адрес электронной почты учетной записи аутентификации :::tip Для инициализации launcherAccountParser (парсера игровых профилей) см. страницу Парсер игровых профилей. ::: Получение результата аутентификации (первая аутентификация) После завершения инициализации системи аутентификации вам нужно только вызвать метод аутентификации аутентификатора Microsoft для первоначальной аутентификации учетной записи. Ниже приведен пример кода аутентификации: // Получить результат аутентификации // [!code focus] // DeviceTokenNotifier — это метод отображения информации, упомянутый ранее // [!code focus] var authResult = await msAuth.GetMSAuthResult(DeviceTokenNotifier); // [!code focus] if (authResult == null) { // Обработка неудачной аутентификации // [!code focus] } // Разбор полей пользователя из токена Jwt // [!code focus] var claims = JwtTokenHelper.GetTokenInfo(authResult.IdToken); // [!code focus] var email = claims.TryGetValue(\"email\", out var outEmail) ? outEmail : null; // [!code focus] if (string.IsNullOrEmpty(email)) { // Невозможно разобрать адрес электронной почты пользователя из учетных данных Jwt, рассматривается как сбой аутентификации // [!code focus] // Это, скорее всего, вызвано сбоем конфигурации приложения Azure или Scope // [!code focus] } // Сохранение необходимой информации о пользователе на локальный диск для подготовки к следующей аутентификации // [!code focus] var msInfoModel = new MSAccountInfoModel { XBLToken = authResult.AccessToken, // [!code focus] XBLRefreshToken = authResult.RefreshToken, // [!code focus] ExpiresIn = authResult.ExpiresIn, // [!code focus] Email = email // [!code focus] }; Получение результата аутентификации (не первая аутентификация) После завершения инициализации системи аутентификации вам нужно только вызвать метод аутентификации аутентификатора Microsoft для завершения аутентификации учетной записи. В асинхронном контексте используйте AuthTaskAsync для завершения аутентификации: var authResult = await microsoftAuthenticator.AuthTaskAsync(false); В синхронном контексте используйте Auth для завершения аутентификации: var authResult = microsoftAuthenticator.Auth(); Интерпретация результата аутентификации После завершения метода аутентификации оно вернет результат аутентификации, который является объектом родительского типа AuthResultBase. Все результаты аутентификации содержат значение перечисления AuthStatus, которое напрямую указывает на успех или неудачу аутентификации. Ниже вы можете увидеть интерпретацию результата аутентификации: Неудачный результат аутентификации Определив, является ли Error пустым, вы можете легко определить, является ли результат аутентификации, возвращенный системой аутентификации, действительным. Объект Error будет содержать следующие поля, чтобы сообщить вам некоторые подробности: Поле Описание authResult.Error.Cause Конкретная причина проблемы authResult.Error.Error Название ошибки authResult.Error.ErrorMessage Подробная информация об ошибке, может содержать решение Успешный результат аутентификации Если поле Error в результате аутентификации пусто, это означает, что эта аутентификация действительна. Успешный результат аутентификации будет содержать следующую информацию: Поле Описание authResult.Id Уникальный идентификатор этого имени пользователя, ProjBobcat использует определенный метод генерации для генерации этого идентификатора authResult.AccessToken Учетные данные авторизации учетной записи пользователя authResult.Profiles Список доступных ролей для пользователя, может содержать несколько доступных ролей authResult.SelectedProfile Текущая выбранная роль пользователя, это поле может быть пустым. Если оно пустое, пользователю необходимо предложить выбрать вручную. authResult.User Сводка информации об учетной записи пользователя, содержит некоторую основную информацию об учетной записи authResult.LocalId Локальный ID, обычно случайно сгенерированный UUID authResult.RemoteId Удаленный ID, возвращенный сервером аутентификации, обычно уникальный идентификатор пользователя authResult.XBoxUid XBox Live UID authResult.Email Адрес электронной почты, используемый для аутентификации authResult.CurrentAuthTime Текущее время аутентификации, разработчикам необходимо сохранить это поле, чтобы помочь подтвердить действительность локального кэшированного токена authResult.ExpiresIn Время истечения срока действия токена (единица измерения: секунды), разработчикам необходимо сохранить это поле, чтобы помочь подтвердить действительность локального кэшированного токена authResult.RefreshToken Токен обновления, разработчикам необходимо сохранить это поле, чтобы помочь обновить просроченные токены authResult.Skin URL-адрес скина учетной записи пользователя :::warning Пожалуйста, используйте соответствующие ограничения или шифрование для безопасного хранения конфиденциальных данных, связанных с токенами пользователей. Утечка этой части данных может привести к потерям. :::"
  },
  "temp/docs-main/ruRU/projbobcat/authenticators/offline.html": {
    "href": "temp/docs-main/ruRU/projbobcat/authenticators/offline.html",
    "title": "Система оффлайн-аутентификации | Qomicex.Core API文档",
    "summary": "Система оффлайн-аутентификации [[toc]] Эта система аутентификации реализует самые основные функции аутентификации. Обычно используется для локальной отладки и аутентификации. :::warning Использование этой системы аутентификации в производственной среде может нарушать законы об авторском праве или лицензионное соглашение с конечным пользователем в некоторых странах и регионах. Для получения дополнительной информации см. Лицензионное соглашение с конечным пользователем Mojang (на английском языке). ::: Инициализация аутентификатора Вы можете инициализировать оффлайн-аутентификатор с помощью следующего кода: var offlineAuthenticator = new OfflineAuthenticator { LauncherAccountParser = launcherAccountParser, Username = \"[DISPLAY_NAME]\" }; В приведенном выше блоке кода замените эти параметры в соответствии с вашей реальной ситуацией: Элемент Описание launcherAccountParser Для инициализации парсера учетных записей лаунчера см. здесь [DISPLAY_NAME] Отображаемое имя в игре, обычно состоящее из английских символов, знаков и цифр :::tip Для инициализации launcherAccountParser (парсера игровых профилей) см. страницу Парсер игровых профилей. ::: Получение результата аутентификации После завершения инициализации системы аутентификации вам нужно только вызвать метод аутентификации оффлайн-аутентификатора для завершения аутентификации учетной записи. В асинхронном контексте используйте AuthTaskAsync для завершения аутентификации: var authResult = await offlineAuthenticator.AuthTaskAsync(false); В синхронном контексте используйте Auth для завершения аутентификации: var authResult = offlineAuthenticator.Auth(); Интерпретация результата аутентификации После завершения метода аутентификации оно вернет результат аутентификации, который является объектом типа AuthResultBase. Все результаты аутентификации содержат значение перечисления AuthStatus, которое напрямую указывает на успех или неудачу аутентификации. Ниже вы можете увидеть интерпретацию результата аутентификации: Неудачный результат аутентификации Определив, является ли Error пустым, вы можете легко определить, является ли результат аутентификации, возвращенный системой аутентификации, действительным. Объект Error будет содержать следующие поля, чтобы сообщить вам некоторые подробности: Поле Описание authResult.Error.Cause Конкретная причина проблемы authResult.Error.Error Название ошибки authResult.Error.ErrorMessage Подробная информация об ошибке, может содержать решение Успешный результат аутентификации Если поле Error в результате аутентификации пусто, это означает, что эта аутентификация действительна. Успешный результат аутентификации будет содержать следующую информацию: Поле Описание authResult.Id Уникальный идентификатор этого имени пользователя, ProjBobcat использует определенный метод генерации для генерации этого идентификатора authResult.AccessToken Учетные данные авторизации учетной записи пользователя, что не имеет смысла для системы оффлайн-аутентификации authResult.User.UUID UUID этого пользователя, аналогично authResult.Id authResult.User.Properties Массив свойств пользователя, для системы оффлайн-аутентификации этот массив содержит только одно допустимое значение"
  },
  "temp/docs-main/ruRU/projbobcat/authenticators/yggdrasil.html": {
    "href": "temp/docs-main/ruRU/projbobcat/authenticators/yggdrasil.html",
    "title": "Система аутентификации Yggdrasil | Qomicex.Core API文档",
    "summary": "Система аутентификации Yggdrasil [[toc]] Эта система аутентификации реализует старую схему аутентификации Mojang, которая в настоящее время устарела. :::warning Продолжение использования этой системой для аутентификации официальных учетных записей будет рассматриваться как недействительный запрос. Однако эту систему все еще можно использовать для входа на серверы, использующие сторонние службы аутентификации (например, AuthLib-Injector). ::: Инициализация аутентификатора Вы можете инициализировать офлайн-аутентификатор с помощью следующего кода: var yggdrasilAuthenticator = new YggdrasilAuthenticator { AuthServer = \"[CUSTOM_AUTH_SERVER]\", Email = \"[EMAIL]\", LauncherAccountParser = launcherAccountParser, Password = \"[PASSWORD]\" }; В приведенном выше блоке кода замените эти параметры в соответствии с вашей реальной ситуацией: Элемент Описание launcherAccountParser Для инициализации парсера учетных записей лаунчера см. здесь [CUSTOM_AUTH_SERVER] Необязательное поле, настраиваемый адрес сервера аутентификации, это поле обычно предоставляется сторонним поставщиком услуг аутентификации, если не заполнено, используется официальный адрес сервера аутентификации Mojang [EMAIL] Адрес электронной почты учетной записи аутентификации [PASSWORD] Пароль учетной записи аутентификации :::tip Для инициализации launcherAccountParser (парсера игровых профилей) см. страницу Парсер игровых профилей. ::: :::warning При использовании стороннего сервера аутентификации используйте протокол https://, а не http:// для подключения к серверу аутентификации. Использование небезопасного сервера аутентификации может привести к таким проблемам, как утечка конфиденциальных данных. ::: Получение результата аутентификации После завершения инициализации системы аутентификации вам нужно только вызвать метод аутентификации офлайн-аутентификатора для завершения аутентификации учетной записи. В асинхронном контексте используйте AuthTaskAsync для завершения аутентификации: var authResult = await offlineAuthenticator.AuthTaskAsync(false); В синхронном контексте используйте Auth для завершения аутентификации: var authResult = offlineAuthenticator.Auth();``` ## Интерпретация результата аутентификации После завершения метода аутентификации оно вернет результат аутентификации, который является объектом родительского типа [AuthResultBase](https://github.com/Corona-Studio/ProjBobcat/blob/master/ProjBobcat/ProjBobcat/Class/Model/Auth/AuthResultBase.cs). Все результаты аутентификации содержат значение перечисления **AuthStatus**, которое напрямую указывает на успех или неудачу аутентификации. Ниже вы можете увидеть интерпретацию результата аутентификации: ### Неудачный результат аутентификации Определив, является ли **Error** пустым, вы можете легко определить, является ли результат аутентификации, возвращенный системой аутентификации, действительным. Объект **Error** будет содержать следующие поля, чтобы сообщить вам некоторые подробности: | Поле | Описание | |:-----------------------------:|:----------------:| | authResult.Error.Cause | Конкретная причина проблемы | | authResult.Error.Error | Название ошибки | | authResult.Error.ErrorMessage | Подробная информация об ошибке, может содержать решение | ### Успешный результат аутентификации Если поле **Error** в результате аутентификации пусто, это означает, что эта аутентификация действительна. Успешный результат аутентификации будет содержать следующую информацию: | Поле | Описание | |:--------------------------:|:---------------------------------------:| | authResult.Id | Уникальный идентификатор этого имени пользователя, ProjBobcat использует определенный метод генерации для генерации этого идентификатора | | authResult.AccessToken | Учетные данные авторизации учетной записи пользователя | | authResult.Profiles | Список доступных ролей для пользователя, может содержать несколько доступных ролей | | authResult.SelectedProfile | Текущая выбранная роль пользователя, это поле может быть пустым. Если оно пустое, пользователю необходимо предложить выбрать вручную. | | authResult.User | Сводка информации об учетной записи пользователя, содержит некоторую основную информацию об учетной записи | | authResult.LocalId | Локальный ID, обычно случайно сгенерированный UUID | | authResult.RemoteId | Удаленный ID, возвращенный сервером аутентификации, обычно уникальный идентификатор пользователя |"
  },
  "temp/docs-main/ruRU/projbobcat/beforeWeStart.html": {
    "href": "temp/docs-main/ruRU/projbobcat/beforeWeStart.html",
    "title": "Перед тем как начать | Qomicex.Core API文档",
    "summary": "Перед тем как начать Прежде чем вы начнете использовать ProjBobcat, вам необходимо проверить и настроить свойства вашего проекта, чтобы он соответствовал требованиям ProjBobcat. [[toc]] Требования к среде выполнения Вам необходимо убедиться, что ваш проект работает как минимум на .NET 6.0 или более поздней версии. Поддерживаемые в настоящее время версии .NET: .NET 8.0 ::: warning В предыдущих обновлениях мы удалили поддержку сред выполнения .NET 5.0, .NET 6.0 и .NET 7.0. ::: Свойства проекта Из-за системных механизмов Windows вам необходимо отключить опцию сборки \"Предпочитать 32-разрядную версию\" в свойствах вашего проекта. В противном случае при использовании некоторых компонентов ProjBobcat могут возникнуть непредвиденные результаты. Вам нужно перейти на страницу свойств проекта в Visual Studio, найти флажок \"Предпочитать 32-разрядную версию\" и снять его. Поддержка 32-разрядных систем ::: warning С самого начала проекта ProjBobcat было решено отказаться от поддержки 32-разрядных систем, потому что они действительно очень, очень старые ( :::"
  },
  "temp/docs-main/ruRU/projbobcat/createNewAzureApp.html": {
    "href": "temp/docs-main/ruRU/projbobcat/createNewAzureApp.html",
    "title": "Настройка приложения Azure | Qomicex.Core API文档",
    "summary": "Настройка приложения Azure [[toc]] Начало настройки Прежде чем начать, вам понадобится учетная запись Microsoft. Регистрация приложения в Azure Active Directory бесплатна. Войдите на портал Azure с помощью своей учетной записи Microsoft. После входа вы должны увидеть страницу, подобную этой: Нажмите Azure Active Directory в разделе Службы Azure. Вы увидите страницу, похожую на следующую: Затем нажмите Регистрация приложений в левой панели функций: Нажмите Новая регистрация на верхней панели инструментов, введите имя приложения. И выберите Только личные учетные записи Microsoft в разделе Поддерживаемые типы учетных записей. Поскольку мы не используем аутентификацию на основе обратного вызова URI, вам не нужно заполнять URI перенаправления в нижней части формы. ::: warning Пожалуйста, внимательно проверьте информацию в форме, иначе на последующих шагах могут возникнуть непредвиденные проблемы. ::: Нажмите \"Создать\" и дождитесь, пока Azure AD завершит создание приложения. После завершения создания веб-страница перенаправит вас на страницу сведений о приложении: Затем нажмите Аутентификация на левой боковой панели: Затем найдите раздел Дополнительные параметры справа и убедитесь, что Поддержка расширенного SDK и Разрешить общедоступные клиентские потоки в этом разделе включены. Если они не включены, включите их вручную. Затем нажмите кнопку \"Сохранить\" ниже и дождитесь завершения сохранения. Просмотр Client ID Поздравляем! Вы завершили регистрацию приложения Azure, теперь вам просто нужно перейти на страницу Обзор, чтобы просмотреть Client ID приложения. Нажмите кнопку Обзор на левой боковой панели, чтобы просмотреть основную информацию о приложении: Справа вы увидите подробную информацию о приложении, найдите ID приложения (клиента) в Сводке. Этот ID будет Client ID, который вам нужно будет использовать на этапе настройки аутентификатора Microsoft."
  },
  "temp/docs-main/ruRU/projbobcat/index.html": {
    "href": "temp/docs-main/ruRU/projbobcat/index.html",
    "title": "Документация разработчика ProjBobcat | Qomicex.Core API文档",
    "summary": "Документация разработчика ProjBobcat ProjBobcat — это легко настраиваемое, высокопроизводительное и полнофункциональное ядро запуска Minecraft, разработанное Corona Development Group. Здесь вы можете найти руководства по использованию различных компонентов. Ссылка на проект GitHub - ProjBobcat"
  },
  "temp/docs-main/ruRU/projbobcat/installationAndConfig.html": {
    "href": "temp/docs-main/ruRU/projbobcat/installationAndConfig.html",
    "title": "Установка и настройка ProjBobcat | Qomicex.Core API文档",
    "summary": "Установка и настройка ProjBobcat [[toc]] Установка из пакета Nuget В настоящее время вы можете легко найти и загрузить пакеты ProjBobcat из Nuget. Вы можете найти ProjBobcat в менеджере пакетов Visual Studio и добавить его в свой проект. Или вы можете вручную выполнить следующую команду в «Консоли диспетчера пакетов»: NuGet\\Install-Package ProjBobcat -Version 1.40.0 .NET CLI Чтобы установить ProjBobcat через .NET CLI, вам просто нужно переключить терминал в каталог проекта, содержащий файл .csproj, и выполнить в терминале: dotnet add package ProjBobcat --version 1.40.0 PackageReference PackageReference — это новая спецификация управления пакетами, представленная Microsoft для современных проектов .NET. Подробную информацию можно найти в MSDN. Вам просто нужно добавить в файл [Имя проекта].csproj вашего проекта: <PackageReference Include=\"ProjBobcat\" Version=\"1.40.0\" /> ::: tip Здесь 1.40.0 — это номер версии ProjBobcat, вы можете заменить его другими номерами версий. Все выпуски можно просмотреть в ProjBobcat - Nuget. ::: Ссылка на исходный код Другой способ использовать ProjBobcat — это напрямую добавить репозиторий кода в ссылки вашего проекта. ::: info Перед выполнением следующих команд вам может потребоваться сначала установить Git CLI. ::: Клонирование репозитория ProjBobcat Используйте командную строку, чтобы переключиться в корневой каталог решения вашего проекта, и выполните следующий код в командной строке, чтобы завершить клонирование репозитория: git clone https://github.com/Corona-Studio/ProjBobcat.git Использование Git Submodule для извлечения ProjBobcat ::: tip Git Submodule — очень полезная функция, здесь мы показываем только ее самый основной вариант использования. Больше примеров использования вы можете найти в официальной документации Git. ::: Используйте командную строку, чтобы переключиться в корневой каталог решения вашего проекта, и выполните следующий код в командной строке, чтобы завершить клонирование репозитория: git submodule add https://github.com/Corona-Studio/ProjBobcat.git Добавление ссылки на ProjBobcat Затем в представлении Обозреватель решений в Visual Studio щелкните правой кнопкой мыши имя решения в верхней части дерева. И выберите «Добавить»-«Существующий проект» и найдите ProjBobcat.csproj в папке проекта ProjBobcat, которую вы только что клонировали, в окне обзора файлов. Затем найдите проект, на который вам нужно сослаться на ProjBobcat, в Обозревателе решений, щелкните его правой кнопкой мыши и выберите «Добавить»-«Ссылка на проект». Наконец, установите флажок ProjBobcat во всплывающем окне, чтобы завершить ссылку на него. Конфигурация перед использованием Изменение количества подключений по умолчанию Перед использованием ProjBobcat вам необходимо добавить некоторый код в точку входа вашей программы (обычно App.xaml.cs или Program.cs), чтобы инициализировать связанные службы ProjBobcat. Из-за ограничения максимального количества подключений по умолчанию в среде выполнения .NET вы можете столкнуться с узкими местами производительности при использовании модуля загрузки ProjBobcat. Поэтому вам необходимо добавить следующий код в точку входа, чтобы изменить максимальное количество подключений по умолчанию: using System.Net; ServicePointManager.DefaultConnectionLimit = 512; Регистрация и инициализация базовых служб Далее вам необходимо добавить этот код в точку входа, чтобы завершить инициализацию службы ProjBobcat: Инициализация контейнера служб ServiceHelper.Init(); Инициализация службы CurseForge API (необязательно) Эта услуга является необязательной. Если вы не используете какие-либо службы, связанные с CurseForge, вы можете пропустить этот шаг. ::: tip Перед регистрацией в сервисе CurseForge вам необходимо подготовить API KEY, выданный официальным CurseForge. Если у вас его еще нет, перейдите на страницу приложения - CurseForge, чтобы получить свой API KEY. ::: ::: warning API KEY — это конфиденциальные личные учетные данные, пожалуйста, храните API KEY в безопасности и не передавайте его другим. ::: CurseForgeAPIHelper.SetApiKey(\"[YOUR API KEY]\"); Замените [YOUR API KEY] на API KEY, который вы получили от официального CurseForge. Инициализация службы загрузки При инициализации службы загрузки вы можете выбрать настройку User Agent, используемого при запросе (по умолчанию «ProjBobcat»). HttpClientHelper.Ua = \"[YOUR UA]\"; // Необязательно Настройка аутентификатора входа в Microsoft Для получения конкретных методов регистрации приложений Azure Active Directory перейдите по ссылке: Как зарегистрировать приложение Azure ::: tip Перед настройкой аутентификатора Microsoft вам необходимо зарегистрировать свое приложение в Azure и правильно его настроить. После завершения настройки вы получите строку Client ID. Связанные материалы: Официальный сайт Azure Поток кода устройства ::: ::: warning CLIENT ID — это конфиденциальные личные учетные данные, пожалуйста, храните CLIENT ID в безопасности и не передавайте его другим. ::: MicrosoftAuthenticator.Configure(new MicrosoftAuthenticatorAPISettings { ClientId = \"[YOUR CLIENT ID]\", TenentId = \"consumers\", Scopes = new[] { \"XboxLive.signin\", \"offline_access\", \"openid\", \"profile\", \"email\" } }); После получения Client ID замените [YOUR CLIENT ID] своим Client ID."
  },
  "temp/docs-main/ruRU/projbobcat/installers/curseforge.html": {
    "href": "temp/docs-main/ruRU/projbobcat/installers/curseforge.html",
    "title": "Установщик модпаков CurseForge | Qomicex.Core API文档",
    "summary": "Установщик модпаков CurseForge [[toc]] ::: tip Обратите внимание, что ProjBobcat реализует только автоматизированный процесс установки модпаков CurseForge. Вам все равно нужно самостоятельно реализовать процессы поиска, загрузки и сохранения модпаков CurseForge. ::: Полезные ресурсы Официальный сайт CurseForge CurseForge API Инициализация установщика Инициализировать установщик CurseForge очень просто: var curseForgeInstaller = new CurseForgeInstaller { GameId = \"[CUSTOM_INSTALL_GAME_ID]\", ModPackPath = \"[PATH_TO_YOUR_MODPACK]\", RootPath = \"[GAME_ROOT_PATH]\" }; В приведенном выше блоке кода замените эти параметры в соответствии с вашей реальной ситуацией: Элемент Описание [GAME_ROOT_PATH] Корневой каталог игры, обычно путь к папке .minecraft [CUSTOM_INSTALL_GAME_ID] Необязательно, пользовательское имя игры, которую вы собираетесь установить [PATH_TO_YOUR_MODPACK] Путь к вашему модпаку CurseForge Начало установки После завершения инициализации установщика вам нужно только вызвать метод установки установщика CurseForge для завершения установки. В асинхронном контексте используйте InstallTaskAsync для завершения установки: await curseForgeInstaller.InstallTaskAsync(); В синхронном контексте используйте Install для завершения установки: curseForgeInstaller.Install(); Отчет о ходе установки В некоторых случаях установка с помощью установщика CurseForge может занять несколько минут. Поэтому вам может потребоваться сообщать пользователю о текущем ходе установки в режиме реального времени. Для этого установщик CurseForge предоставляет событие StageChangedEventDelegate, чтобы помочь вам реализовать отчет о задачах. Вам просто нужно зарегистрировать следующее событие перед началом установки: curseForgeInstaller.StageChangedEventDelegate += (_, args) => { ReportProgress(args.Progress, args.CurrentStage); }; Где args.Progress указывает текущий процент выполнения установщика. args.CurrentStage — это текстовое описание текущего этапа установщика."
  },
  "temp/docs-main/ruRU/projbobcat/installers/fabric.html": {
    "href": "temp/docs-main/ruRU/projbobcat/installers/fabric.html",
    "title": "Установщик Fabric | Qomicex.Core API文档",
    "summary": "Установщик Fabric [[toc]] ::: tip Обратите внимание, что ProjBobcat реализует только автоматизированный процесс установки Fabric. Вам все равно нужно самостоятельно реализовать процессы поиска, загрузки и сохранения установочных пакетов Fabric. ::: Полезные ресурсы Официальный сайт Fabric Fabric Meta API Получение артефакта загрузчика Fabric Поскольку установщик Fabric в ProjBobcat требует, чтобы вы предоставили информацию об артефакте загрузчика от официального Fabric при инициализации установщика. Поэтому здесь мы кратко опишем, как получить эту информацию в соответствии с указанной версией Minecraft. ::: info В этом примере мы будем использовать Minecraft 1.19.2, чтобы показать вам, как его получить. ::: Отправка запроса в Fabric Meta API Сначала вам нужно отправить запрос HTTP GET на https://meta.fabricmc.net/v2/versions/loader/[MC_VERSION]. Замените [MC_VERSION] на версию Minecraft, которую вы хотите установить. Здесь мы будем использовать 1.19.2. Вы увидите ответ, подобный следующему: [ { \"loader\": { \"separator\": \".\", \"build\": 11, \"maven\": \"net.fabricmc:fabric-loader:0.14.11\", \"version\": \"0.14.11\", \"stable\": true }, \"intermediary\": { \"maven\": \"net.fabricmc:intermediary:1.19.2\", \"version\": \"1.19.2\", \"stable\": true }, \"launcherMeta\": { \"version\": 1, \"libraries\": {...}, \"mainClass\": {...} } }, {...}, {...} ] Fabric Meta API вернет массив JSON, и каждый элемент в массиве — это артефакт загрузчика, который нам нужен. Преобразование ответа JSON в тип ProjBobcat Если вы используете JSON.NET (Newtonsoft.JSON) в своем проекте. Вы можете использовать код, подобный приведенному ниже, для преобразования ответа сервера, который вы получили, в соответствующий тип ProjBobcat: // Запрос данных из Fabric Meta API (пример, не реальный код) ... var responseJson = await res.Content.ReadAsStringAsync(); // Преобразование ответа JSON в тип ProjBobcat // [!code focus] var artifacts = JsonConvert.DeserializeObject<List<FabricLoaderArtifactModel>>(responseJson); // [!code focus] // Получение версии, которую хочет установить пользователь (пример, не реальный код) var userSelect = vm.SelectedArtifactIndex; // Получение одного артефакта загрузчика // [!code focus] var selectedArtifact = artifacts[userSelect]; // [!code focus] Здесь selectedArtifact — это FabricLoaderArtifactModel, необходимый установщику Fabric. Инициализация установщика Инициализировать установщик Fabric очень просто. Вам нужно использовать selectedArtifact, полученный на предыдущем шаге, для инициализации установщика: var fabricInstaller = new FabricInstaller { LoaderArtifact = selectedArtifact, VersionLocator = [VERSION_LOCATOR_INST], RootPath = \"[GAME_ROOT_PATH]\", CustomId = \"[CUSTOM_INSTALL_GAME_ID]\", InheritsFrom = \"[MC_VERSION_OR_GAME_ID]\" }; В приведенном выше блоке кода замените эти параметры в соответствии с вашей реальной ситуацией: Элемент Описание [GAME_ROOT_PATH] Корневой каталог игры, обычно путь к папке .minecraft [CUSTOM_INSTALL_GAME_ID] Необязательно, пользовательское имя игры, которую вы собираетесь установить [MC_VERSION_OR_GAME_ID] Версия оригинальной игры Minecraft, от которой наследуется Forge, обычно версия игры. Например: 1.19.2 [VERSION_LOCATOR_INST] Экземпляр локатора версий игры, то есть свойство VersionLocator при инициализации ядра игры Начало установки После завершения инициализации установщика вам нужно только вызвать метод установки установщика Fabric для завершения установки. В асинхронном контексте используйте InstallTaskAsync для завершения установки: await fabricInstaller.InstallTaskAsync(); В синхронном контексте используйте Install для завершения установки: fabricInstaller.Install();``` ## Отчет о ходе установки В некоторых случаях установка с помощью установщика Fabric может занять несколько минут. Поэтому вам может потребоваться сообщать пользователю о текущем ходе установки в режиме реального времени. Для этого установщик Fabric предоставляет событие **StageChangedEventDelegate**, чтобы помочь вам реализовать отчет о задачах. Вам просто нужно зарегистрировать следующее событие **перед началом установки**: ```c# fabricInstaller.StageChangedEventDelegate += (_, args) => { ReportProgress(args.Progress, args.CurrentStage); }; Где args.Progress указывает текущий процент выполнения установщика. args.CurrentStage — это текстовое описание текущего этапа установщика."
  },
  "temp/docs-main/ruRU/projbobcat/installers/forge.html": {
    "href": "temp/docs-main/ruRU/projbobcat/installers/forge.html",
    "title": "Установщик Forge | Qomicex.Core API文档",
    "summary": "Установщик Forge В ProjBobcat мы поддерживаем автоматическую установку Forge практически для всех основных версий Minecraft. [[toc]] ::: tip Обратите внимание, что ProjBobcat реализует только автоматизированный процесс установки Forge. Вам все равно нужно самостоятельно реализовать процессы поиска, загрузки и сохранения установочных пакетов Forge. ::: Определение того, какой установщик Forge использовать Поскольку команда Forge изменила спецификацию упаковки и процесс установки Forge в последующих версиях, вам необходимо вручную определить, какой установщик использовать. В ProjBobcat мы уже реализовали для вас соответствующую логику определения. Вам просто нужно вызвать следующий метод: var mcVersion = \"[MC_VERSION]\"; var forgeJarPath = \"[PATH_TO_YOUR_FORGE_INSTALLER]\"; var forgeVersion = ForgeInstallerFactory.GetForgeArtifactVersion(mcVersion, \"[FORGE_VERSION]\"); var isLegacy = ForgeInstallerFactory.IsLegacyForgeInstaller(forgeJarPath, forgeVersion); // [!code focus] В приведенном выше блоке кода замените эти параметры в соответствии с вашей реальной ситуацией: Элемент Описание [MC_VERSION] Версия Minecraft для установки Forge, например: 1.19.2 [PATH_TO_YOUR_FORGE_INSTALLER] Путь к файлу .jar установщика Forge [FORGE_VERSION] Конкретная версия Forge, обычно XX.X.X, например: 43.2.0 После того, как вы завершите замену и успешно выполните приведенный выше фрагмент кода, isLegacy укажет, какой установщик Forge следует использовать для текущего установщика Forge. Инициализация устаревшего установщика Если в описанном выше процессе значение isLegacy равно true, это означает, что вам необходимо использовать устаревший установщик для завершения установки Forge. Чтобы инициализировать устаревший установщик, просто создайте экземпляр LegacyForgeInstaller и укажите соответствующие параметры: IForgeInstaller forgeInstaller = new LegacyForgeInstaller { ForgeExecutablePath = \"[PATH_TO_YOUR_FORGE_INSTALLER]\", RootPath = \"[GAME_ROOT_PATH]\", CustomId = \"[CUSTOM_INSTALL_GAME_ID]\", ForgeVersion = \"[FORGE_VERSION]\", InheritsFrom = \"[MC_VERSION_OR_GAME_ID]\" }; В приведенном выше блоке кода замените эти параметры в соответствии с вашей реальной ситуацией: Элемент Описание [GAME_ROOT_PATH] Корневой каталог игры, обычно путь к папке .minecraft [CUSTOM_INSTALL_GAME_ID] Необязательно, пользовательское имя игры, которую вы собираетесь установить [MC_VERSION_OR_GAME_ID] Версия оригинальной игры Minecraft, от которой наследуется Forge, обычно версия игры. Например: 1.19.2 Инициализация нового установщика IForgeInstaller forgeInstaller = new HighVersionForgeInstaller { ForgeExecutablePath = \"[PATH_TO_YOUR_FORGE_INSTALLER]\", JavaExecutablePath = \"[PATH_TO_YOUR_JAVA_RUNTIME]\", RootPath = \"[GAME_ROOT_PATH]\", VersionLocator = [VERSION_LOCATOR_INST], DownloadUrlRoot = \"[LIBRARIES_URL_ROOT]\", CustomId = \"[CUSTOM_INSTALL_GAME_ID]\", MinecraftVersion = \"[MC_VERSION]\", MinecraftVersionId = \"[ACTUAL_MC_GAME_ID]\", InheritsFrom = \"[MC_VERSION_OR_GAME_ID]\" }; В приведенном выше блоке кода замените эти параметры в соответствии с вашей реальной ситуацией: Элемент Описание [PATH_TO_YOUR_JAVA_RUNTIME] Путь к среде выполнения Java (javaw.exe) [LIBRARIES_URL_ROOT] Корневой URL-адрес источника загрузки, например: \"https://bmclapi2.bangbang93.com/\" [VERSION_LOCATOR_INST] Экземпляр локатора версий игры, то есть свойство VersionLocator при инициализации ядра игры [ACTUAL_MC_GAME_ID] Фактическое имя игры Minecraft, то есть имя оригинальной игры в папке version. В большинстве случаев это значение совпадает с [MC_VERSION]. Унифицированная инициализация на основе значения isLegacy Поскольку LegacyForgeInstaller и HighVersionForgeInstaller одновременно реализуют интерфейс IForgeInstaller. Поэтому вы можете легко использовать тернарный оператор для выборочной инициализации соответствующего установщика: var isLegacy = ForgeInstallerFactory.IsLegacyForgeInstaller(forgeJarPath, forgeVersion); IForgeInstaller forgeInstaller = isLegacy ? new LegacyForgeInstaller { ForgeExecutablePath = \"[PATH_TO_YOUR_FORGE_INSTALLER]\", RootPath = \"[GAME_ROOT_PATH]\", CustomId = \"[CUSTOM_INSTALL_GAME_ID]\", ForgeVersion = \"[FORGE_VERSION]\", InheritsFrom = \"[MC_VERSION_OR_GAME_ID]\" } : new HighVersionForgeInstaller { ForgeExecutablePath = \"[PATH_TO_YOUR_FORGE_INSTALLER]\", JavaExecutablePath = \"[PATH_TO_YOUR_JAVA_RUNTIME]\", RootPath = \"[GAME_ROOT_PATH]\", VersionLocator = [VERSION_LOCATOR_INST], DownloadUrlRoot = \"[LIBRARIES_URL_ROOT]\", CustomId = \"[CUSTOM_INSTALL_GAME_ID]\", MinecraftVersion = \"[MC_VERSION]\", MinecraftVersionId = \"[ACTUAL_MC_GAME_ID]\", InheritsFrom = \"[MC_VERSION_OR_GAME_ID]\" }; Начало установки После завершения инициализации установщика вам нужно только вызвать метод установки установщика Forge для завершения установки. В асинхронном контексте используйте InstallForgeTaskAsync для завершения установки: await forgeInstaller.InstallForgeTaskAsync(); В синхронном контексте используйте InstallForge для завершения установки: forgeInstaller.InstallForge(); Отчет о ходе установки В некоторых случаях установка с помощью установщика Forge может занять несколько минут. Поэтому вам может потребоваться сообщать пользователю о текущем ходе установки в режиме реального времени. Для этого установщик Forge предоставляет событие StageChangedEventDelegate, чтобы помочь вам реализовать отчет о задачах. Вам просто нужно зарегистрировать следующее событие перед началом установки: ((InstallerBase)forgeInstaller).StageChangedEventDelegate += (_, args) => { ReportProgress(args.Progress * 100, args.CurrentStage); }; Где args.Progress указывает текущий процент выполнения установщика. args.CurrentStage — это текстовое описание текущего этапа установщика."
  },
  "temp/docs-main/ruRU/projbobcat/installers/index.html": {
    "href": "temp/docs-main/ruRU/projbobcat/installers/index.html",
    "title": "Установщики | Qomicex.Core API文档",
    "summary": "Установщики В ProjBobcat мы реализовали для разработчиков большую часть инфраструктуры модов, с которой вы можете столкнуться в процессе разработки Minecraft. Список поддержки Название проекта Статус поддержки Forge (старая версия) Поддерживается ✅ Forge (новая версия) Поддерживается ✅ LiteLoader Поддерживается ✅ Fabric Поддерживается ✅ Optifine Поддерживается ✅ Quilt Поддерживается (экспериментально) ⚠ Модпаки CurseForge Поддерживается ✅"
  },
  "temp/docs-main/ruRU/projbobcat/installers/liteloader.html": {
    "href": "temp/docs-main/ruRU/projbobcat/installers/liteloader.html",
    "title": "Установщик LiteLoader | Qomicex.Core API文档",
    "summary": "Установщик LiteLoader [[toc]] ::: tip Обратите внимание, что ProjBobcat реализует только автоматизированный процесс установки LiteLoader. Вам все равно нужно самостоятельно реализовать процессы поиска, загрузки и сохранения установочных пакетов LiteLoader. ::: ::: warning LiteLoader, как система модов для ранних версий Minecraft, долгое время не обслуживалась и не поддерживалась. Поэтому мы можем удалить поддержку установки LiteLoader в будущих версиях. ::: Полезные ресурсы LiteLoader Versions API Документация разработчика BMCLAPI Получение модели версии загрузки LiteLoader Поскольку установщик LiteLoader в ProjBobcat требует, чтобы вы предоставили информацию о загрузке от LiteLoader при инициализации установщика. Поэтому здесь мы кратко опишем, как получить эту информацию в соответствии с указанной версией Minecraft. ::: info В этом примере мы будем использовать Minecraft 1.7.10, чтобы показать вам, как его получить. ::: ::: warning Поскольку официальный LiteLoader не предоставляет общедоступной документации по API, в этом процессе нам необходимо использовать сторонние зеркальные источники для получения данных. Здесь мы используем BMCLAPI для получения соответствующей информации о версии. ::: Сначала вам нужно отправить запрос HTTP GET на https://bmclapi2.bangbang93.com/liteloader/list?mcversion=[MC_VERSION]. Замените [MC_VERSION] на версию Minecraft, которую вы хотите установить. Здесь мы будем использовать 1.7.10. Вы увидите ответ, подобный следующему: { \"_id\": \"59685511433f993503c1c879\", \"mcversion\": \"1.7.10\", \"build\": { \"tweakClass\": \"com.mumfrey.liteloader.launch.LiteLoaderTweaker\", \"libraries\": [...], \"stream\": \"RELEASE\", \"file\": \"liteloader-1.7.10.jar\", \"version\": \"1.7.10_04\", \"md5\": \"63ada46e033d0cb6782bada09ad5ca4e\", \"timestamp\": \"1414368553\", \"srcJar\": \"liteloader-1.7.10_04-mcpnames-sources.jar\", \"mcpJar\": \"liteloader-1.7.10_04-mcpnames.jar\" }, \"hash\": \"63ada46e033d0cb6782bada09ad5ca4e\", \"type\": \"RELEASE\", \"version\": \"1.7.10_04\", \"__v\": 0 } BMCLAPI вернет объект JSON. Десериализация этого объекта в тип ProjBobcat — это LiteLoaderDownloadVersionModel, который нам нужен. Преобразование ответа JSON в тип ProjBobcat Если вы используете JSON.NET (Newtonsoft.JSON) в своем проекте. Вы можете использовать код, подобный приведенному ниже, для преобразования ответа сервера, который вы получили, в соответствующий тип ProjBobcat: // Запрос данных из BMCLAPI (пример, не реальный код) ... var responseJson = await res.Content.ReadAsStringAsync(); // Преобразование ответа JSON в тип ProjBobcat // [!code focus] var versionModel = JsonConvert.DeserializeObject<LiteLoaderDownloadVersionModel>(responseJson); // [!code focus] Здесь versionModel — это LiteLoaderDownloadVersionMode, необходимый установщику Fabric. Получение RawVersionModel При инициализации установщика LiteLoader установщику необходимо использовать исходное содержимое JSON соответствующей версии игры Minecraft для LiteLoader. То есть содержимое файла [ROOT_PATH]/versions/[MC_VERSION]/[MC_VERSION].json. Если вы уже установили оригинальную игру, соответствующую LiteLoader, вы можете получить RawVersionModel с помощью следующего кода: // Получение пути к файлу JSON версии var jsonPath = GamePathHelper.GetGameJsonPath(rP, id); // Чтение содержимого файла var jsonContent = await File.ReadAllTextAsync(jsonPath); // Преобразование содержимого JSON в RawVersionModel var baseVersionModel = JsonConvert.DeserializeObject<RawVersionModel>(jsonContent); Здесь baseVersionModel — это RawVersionModel, необходимый установщику LiteLoader. Инициализация установщика Инициализировать установщик LiteLoader очень просто. Вам нужно использовать versionModel и baseVersionModel, полученные на предыдущих шагах, для инициализации установщика: var liteLoaderInstaller = new LiteLoaderInstaller { InheritVersion = baseVersionModel, InheritsFrom = \"[MC_VERSION_OR_GAME_ID]\", RootPath = \"[GAME_ROOT_PATH]\", VersionModel = versionModel, CustomId = \"[CUSTOM_INSTALL_GAME_ID]\" }; В приведенном выше блоке кода замените эти параметры в соответствии с вашей реальной ситуацией: Элемент Описание [GAME_ROOT_PATH] Корневой каталог игры, обычно путь к папке .minecraft [CUSTOM_INSTALL_GAME_ID] Необязательно, пользовательское имя игры, которую вы собираетесь установить [MC_VERSION_OR_GAME_ID] Версия оригинальной игры Minecraft, от которой наследуется Forge, обычно версия игры. Например: 1.19.2 [VERSION_LOCATOR_INST] Экземпляр локатора версий игры, то есть свойство VersionLocator при инициализации ядра игры Начало установки После завершения инициализации установщика вам нужно только вызвать метод установки установщика LiteLoader для завершения установки. В асинхронном контексте используйте InstallTaskAsync для завершения установки: await liteLoaderInstaller.InstallTaskAsync();``` В синхронном контексте используйте **Install** для завершения установки: ```c# liteLoaderInstaller.Install(); Отчет о ходе установки В некоторых случаях установка с помощью установщика LiteLoader может занять несколько минут. Поэтому вам может потребоваться сообщать пользователю о текущем ходе установки в режиме реального времени. Для этого установщик LiteLoader предоставляет событие StageChangedEventDelegate, чтобы помочь вам реализовать отчет о задачах. Вам просто нужно зарегистрировать следующее событие перед началом установки: liteLoaderInstaller.StageChangedEventDelegate += (_, args) => { ReportProgress(args.Progress, args.CurrentStage); }; Где args.Progress указывает текущий процент выполнения установщика. args.CurrentStage — это текстовое описание текущего этапа установщика."
  },
  "temp/docs-main/ruRU/projbobcat/installers/optifine.html": {
    "href": "temp/docs-main/ruRU/projbobcat/installers/optifine.html",
    "title": "Установщик Optifine | Qomicex.Core API文档",
    "summary": "Установщик Optifine [[toc]] ::: tip Обратите внимание, что ProjBobcat реализует только автоматизированный процесс установки Optifine. Вам все равно нужно самостоятельно реализовать процессы поиска, загрузки и сохранения установочных пакетов Optifine. ::: Полезные ресурсы Документация разработчика BMCLAPI Получение модели версии загрузки Optifine Поскольку установщик LiteLoader в ProjBobcat требует, чтобы вы предоставили информацию о загрузке от LiteLoader при инициализации установщика. Поэтому здесь мы кратко опишем, как получить эту информацию в соответствии с указанной версией Minecraft. ::: info В этом примере мы будем использовать Minecraft 1.19.2, чтобы показать вам, как его получить. ::: ::: warning Поскольку официальный Optifine не предоставляет общедоступной документации по API, в этом процессе нам необходимо использовать сторонние зеркальные источники для получения данных. Здесь мы используем BMCLAPI для получения соответствующей информации о версии. ::: Сначала вам нужно отправить запрос HTTP GET на https://bmclapi2.bangbang93.com/optifine/[MC_VERSION]. Замените [MC_VERSION] на версию Minecraft, которую вы хотите установить. Здесь мы будем использовать 1.19.2. Вы увидите ответ, подобный следующему: [ { \"_id\": \"6307b8a38a3998ab475d139d\", \"mcversion\": \"1.19.2\", \"patch\": \"H9\", \"type\": \"HD_U\", \"__v\": 0, \"filename\": \"OptiFine_1.19.2_HD_U_H9.jar\", \"forge\": \"Forge 43.1.1\" }, {...}, {...} ] BMCLAPI вернет массив JSON, и каждый элемент в массиве — это модель версии загрузки, которая нам нужна. Преобразование ответа JSON в тип ProjBobcat Если вы используете JSON.NET (Newtonsoft.JSON) в своем проекте. Вы можете использовать код, подобный приведенному ниже, для преобразования ответа сервера, который вы получили, в соответствующий тип ProjBobcat: // Запрос данных из BMCLAPI (пример, не реальный код) ... var responseJson = await res.Content.ReadAsStringAsync(); // Преобразование ответа JSON в тип ProjBobcat // [!code focus] var versions = JsonConvert.DeserializeObject<List<OptifineDownloadVersionModel>>(responseJson); // [!code focus] // Получение версии, которую хочет установить пользователь (пример, не реальный код) var userSelect = vm.SelectedIndex; // Получение одной модели версии загрузки // [!code focus] var selectedVersion = versions[userSelect]; // [!code focus] Здесь selectedVersion — это OptifineDownloadVersionModel, необходимый установщику Optifine. Инициализация установщика Инициализировать установщик Optifine очень просто. Сначала вам нужно подготовить файл .jar установщика Optifine и доступную среду выполнения Java. Вам нужно использовать selectedVersion, полученный на предыдущем шаге, для инициализации установщика: var optifineInstaller = new OptifineInstaller { JavaExecutablePath = \"[PATH_TO_YOUR_JAVA_RUNTIME]\", OptifineDownloadVersion = selectedVersion, OptifineJarPath = \"[PATH_TO_YOUR_OPTIFINE_JAR]\", RootPath = \"[GAME_ROOT_PATH]\", CustomId = \"[CUSTOM_INSTALL_GAME_ID]\", InheritsFrom = \"[MC_VERSION_OR_GAME_ID]\" }; В приведенном выше блоке кода замените эти параметры в соответствии с вашей реальной ситуацией: Элемент Описание [GAME_ROOT_PATH] Корневой каталог игры, обычно путь к папке .minecraft [CUSTOM_INSTALL_GAME_ID] Необязательно, пользовательское имя игры, которую вы собираетесь установить [MC_VERSION_OR_GAME_ID] Версия оригинальной игры Minecraft, от которой наследуется Forge, обычно версия игры. Например: 1.19.2 [VERSION_LOCATOR_INST] Экземпляр локатора версий игры, то есть свойство VersionLocator при инициализации ядра игры [PATH_TO_YOUR_OPTIFINE_JAR] Путь к вашему установочному пакету Optifine [PATH_TO_YOUR_JAVA_RUNTIME] Путь к среде выполнения Java (javaw.exe) Начало установки После завершения инициализации установщика вам нужно только вызвать метод установки установщика Optifine для завершения установки. В асинхронном контексте используйте InstallTaskAsync для завершения установки: await optifineInstaller.InstallTaskAsync(); В синхронном контексте используйте Install для завершения установки: optifineInstaller.Install(); Отчет о ходе установки В некоторых случаях установка с помощью установщика Optifine может занять несколько минут. Поэтому вам может потребоваться сообщать пользователю о текущем ходе установки в режиме реального времени. Для этого установщик Optifine предоставляет событие StageChangedEventDelegate, чтобы помочь вам реализовать отчет о задачах. Вам просто нужно зарегистрировать следующее событие перед началом установки: optifineInstaller.StageChangedEventDelegate += (_, args) => { ReportProgress(args.Progress, args.CurrentStage); }; Где args.Progress указывает текущий процент выполнения установщика. args.CurrentStage — это текстовое описание текущего этапа установщика."
  },
  "temp/docs-main/ruRU/projbobcat/installers/quilt.html": {
    "href": "temp/docs-main/ruRU/projbobcat/installers/quilt.html",
    "title": "Установщик Quilt | Qomicex.Core API文档",
    "summary": "Установщик Quilt [[toc]] ::: tip Обратите внимание, что ProjBobcat реализует только автоматизированный процесс установки Quilt. Вам все равно нужно самостоятельно реализовать процессы поиска, загрузки и сохранения установочных пакетов Quilt. ::: ::: warning Установщик Quilt в настоящее время находится на экспериментальной стадии, и связанные с ним API и процесс установки могут претерпеть значительные изменения. ::: Полезные ресурсы Официальный сайт Quilt Руководство по установке Quilt Quilt Meta API Проверка совместимости Перед началом установки Quilt вам необходимо проверить через Quilt Meta API, поддерживается ли версия Minecraft, которую вы собираетесь изменить. Сначала вам нужно отправить запрос HTTP GET на https://meta.quiltmc.org/v3/versions/game. Вы увидите ответ, подобный следующему: [ { \"version\": \"1.19.3\", \"stable\": true }, { \"version\": \"1.19.3-rc3\", \"stable\": false }, {...}, {...} ] Здесь вам нужно проверить, есть ли версия игры, которую вы собираетесь установить, в официальном списке поддержки Quilt. Вам нужно сравнить версию игры с полем version в объекте JSON. Если вашей игры нет в списке поддержки, установка не может быть продолжена. Получение модели загрузчика Quilt Поскольку установщик Quilt в ProjBobcat требует, чтобы вы предоставили информацию о загрузке от Quilt при инициализации установщика. Поэтому здесь мы кратко опишем, как получить эту информацию в соответствии с указанной версией Minecraft. ::: info В этом примере мы будем использовать Minecraft 1.19.2, чтобы показать вам, как его получить. ::: Сначала вам нужно отправить запрос HTTP GET на https://meta.quiltmc.org/v3/versions/loader. Вы увидите ответ, подобный следующему: [ { \"separator\": \".\", \"build\": 25, \"maven\": \"org.quiltmc:quilt-loader:0.18.1-beta.25\", \"version\": \"0.18.1-beta.25\" }, {...}, {...} ] Quilt Meta API вернет массив JSON, и каждый элемент в массиве — это артефакт загрузчика, который нам нужен. Преобразование ответа JSON в тип ProjBobcat Если вы используете JSON.NET (Newtonsoft.JSON) в своем проекте. Вы можете использовать код, подобный приведенному ниже, для преобразования ответа сервера, который вы получили, в соответствующий тип ProjBobcat: // Запрос данных из Quilt Meta API (пример, не реальный код) ... var responseJson = await res.Content.ReadAsStringAsync(); // Преобразование ответа JSON в тип ProjBobcat // [!code focus] var artifacts = JsonConvert.DeserializeObject<List<QuiltLoaderModel>>(responseJson); // [!code focus] // Получение версии, которую хочет установить пользователь (пример, не реальный код) var userSelect = vm.SelectedArtifactIndex; // Получение одного артефакта загрузчика // [!code focus] var selectedArtifact = artifacts[userSelect]; // [!code focus] Здесь selectedArtifact — это QuiltLoaderModel, необходимый установщику Fabric. Инициализация установщика Инициализировать установщик Quilt очень просто. Вам нужно использовать selectedArtifact, полученный на предыдущем шаге, для инициализации установщика: var quiltInstaller = new QuiltInstaller { InheritsFrom = \"[MC_VERSION_OR_GAME_ID]\", RootPath = \"[GAME_ROOT_PATH]\", CustomId = \"[CUSTOM_INSTALL_GAME_ID]\", LoaderArtifact = selectedArtifact }; В приведенном выше блоке кода замените эти параметры в соответствии с вашей реальной ситуацией: Элемент Описание [GAME_ROOT_PATH] Корневой каталог игры, обычно путь к папке .minecraft [CUSTOM_INSTALL_GAME_ID] Необязательно, пользовательское имя игры, которую вы собираетесь установить [MC_VERSION_OR_GAME_ID] Версия оригинальной игры Minecraft, от которой наследуется Forge, обычно версия игры. Например: 1.19.2 Начало установки После завершения инициализации установщика вам нужно только вызвать метод установки установщика Fabric для завершения установки. В асинхронном контексте используйте InstallTaskAsync для завершения установки: await quiltInstaller.InstallTaskAsync(); В синхронном контексте используйте Install для завершения установки: quiltInstaller.Install(); Отчет о ходе установки В некоторых случаях установка с помощью установщика Quilt может занять несколько минут. Поэтому вам может потребоваться сообщать пользователю о текущем ходе установки в режиме реального времени. Для этого установщик Quilt предоставляет событие StageChangedEventDelegate, чтобы помочь вам реализовать отчет о задачах. Вам просто нужно зарегистрировать следующее событие перед началом установки: quiltInstaller.StageChangedEventDelegate += (_, args) => { ReportProgress(args.Progress, args.CurrentStage); }; Где args.Progress указывает текущий процент выполнения установщика. args.CurrentStage — это текстовое описание текущего этапа установщика."
  },
  "temp/docs-main/ruRU/projbobcat/resourceCompleter/createAndConfigCompleter.html": {
    "href": "temp/docs-main/ruRU/projbobcat/resourceCompleter/createAndConfigCompleter.html",
    "title": "Создание и настройка комплитера | Qomicex.Core API文档",
    "summary": "Создание и настройка комплитера [[toc]] Инициализация комплитера Создать комплитер ресурсов очень просто, вам просто нужно использовать следующий код для завершения инициализации комплитера: var completer = new DefaultResourceCompleter { MaxDegreeOfParallelism = [MAX_DEGREE_OF_PARALLELISM], ResourceInfoResolvers = new List<IResourceInfoResolver> { ...// Инициализация распознавателей информации о ресурсах }, TotalRetry = [NUMBER_OF_TOTAL_RETRY], CheckFile = [CHECK_FILE_AFTER_DOWNLOADED], DownloadParts = [TOTAL_DOWNLOAD_SEGMENTS_FOR_LARGE_FILE] }; ::: tip Руководства по инициализации распознавателей информации о ресурсах см. в разделе Распознаватели информации о ресурсах. ::: В приведенном выше блоке кода замените эти параметры в соответствии с вашей реальной ситуацией: Элемент Тип данных Описание [MAX_DEGREE_OF_PARALLELISM] INT Степень параллелизма проверки ресурсов (количество одновременно проверяемых игровых ресурсов) [CHECK_FILE_AFTER_DOWNLOADED] BOOLEAN Проверка целостности файла после его загрузки (если существует контрольная сумма ресурса) [TOTAL_DOWNLOAD_SEGMENTS_FOR_LARGE_FILE] INT Количество сегментов для загрузки больших файлов ::: warning Значения [MAX_DEGREE_OF_PARALLELISM] и [TOTAL_DOWNLOAD_SEGMENTS_FOR_LARGE_FILE] следует настраивать в зависимости от производительности оборудования. Установка слишком больших значений может привести к снижению пропускной способности. ::: Завершение игровых ресурсов После завершения инициализации комплитера ресурсов вам нужно только вызвать метод завершения, чтобы начать операции проверки и завершения: В асинхронном контексте используйте CheckAndDownloadTaskAsync для завершения установки: var result = await completer.CheckAndDownloadTaskAsync(); // [!code focus] if (result.TaskStatus == TaskResultStatus.Error && (result.Value?.IsLibDownloadFailed ?? false)) { // После завершения комплитер ресурсов вернет результат выполнения. // Вы можете проверить значения свойств в result, чтобы определить, завершено ли завершение. // IsLibDownloadFailed отражает, были ли успешно завершены необходимые для запуска библиотеки. // В общем, если завершение файлов библиотек не удалось, это, скорее всего, приведет к сбою запуска игры. } В синхронном контексте используйте CheckAndDownload для завершения установки: var result = completer.CheckAndDownload(); // [!code focus] Отчет о ходе выполнения В некоторых случаях комплитеру ресурсов может потребоваться несколько минут для завершения проверки и загрузки ресурсов. Поэтому вам может потребоваться сообщать пользователю о текущем ходе выполнения комплитера в режиме реального времени. Отчет о ходе выполнения проверки ресурсов Вы можете получать ход проверки в режиме реального времени, зарегистрировав событие GameResourceInfoResolveStatus: completer.GameResourceInfoResolveStatus += (_, args) => { ReportProgress(args.Progress, args.Status); }; Где args.Progress указывает текущий процент выполнения проверки. args.Status — это текстовое описание текущего этапа проверки. Отчет о ходе загрузки файлов комплитером Вы можете получать ход проверки в режиме реального времени, зарегистрировав событие DownloadFileCompletedEvent: completer.DownloadFileCompletedEvent += (sender, args) => { // Параметр sender — это последний успешно загруженный файл комплитером, тип — DownloadFile. // args возвращает статус загрузки этого файла (успешно/неудачно), а также счетчик повторных попыток файла, // тип — DownloadFileCompletedEventArgs. }; ::: tip Структура класса DownloadFile Структура события DownloadFileCompletedEventArgs ::: Отчет об информации о ходе загружаемых файлов Вы можете получать ход проверки в режиме реального времени, зарегистрировав событие DownloadFileChangedEvent: rC.DownloadFileChangedEvent += (_, args) => { // args возвращает подробную информацию о загружаемом файле (полученные байты, общее количество байтов, текущая скорость, процент выполнения). // тип — DownloadFileChangedEventArgs. }; ::: tip Структура события DownloadFileChangedEventArgs :::"
  },
  "temp/docs-main/ruRU/projbobcat/resourceCompleter/index.html": {
    "href": "temp/docs-main/ruRU/projbobcat/resourceCompleter/index.html",
    "title": "Комплетер ресурсов | Qomicex.Core API文档",
    "summary": "Комплетер ресурсов В ProjBobcat мы предоставляем разработчикам комплитер для завершения основных файлов ресурсов Minecraft. Эти ресурсы включают: игровое аудио, материалы, текстуры, языковые файлы, файлы библиотек, необходимые для запуска, и т. д."
  },
  "temp/docs-main/ruRU/projbobcat/resourceCompleter/resourceInfoResolver/assetInfoResolver.html": {
    "href": "temp/docs-main/ruRU/projbobcat/resourceCompleter/resourceInfoResolver/assetInfoResolver.html",
    "title": "Распознаватель ассетов | Qomicex.Core API文档",
    "summary": "Распознаватель ассетов [[toc]] Распознаватель ассетов предоставляет функции для разбора и проверки файлов ассетов игры, которые обычно хранятся в каталоге .minecraft/assets. Получение списка версий манифеста версий Сначала вам нужно отправить запрос HTTP GET на https://launchermeta.mojang.com/mc/game/version_manifest.json. Вы увидите ответ, подобный следующему: { \"latest\": { \"release\": \"1.19.3\", \"snapshot\": \"23w06a\" }, \"versions\": [ { \"id\": \"23w06a\", \"type\": \"snapshot\", \"url\": \"https://piston-meta.mojang.com/v1/packages/92ed97b686fe8904d8ec00fd486c435582fd0155/23w06a.json\", \"time\": \"2023-02-08T15:11:06+00:00\", \"releaseTime\": \"2023-02-08T15:00:04+00:00\" }, ... ] } Сервер Mojang вернет объект JSON, и поле versions — это массив версий, который нам нужен. Преобразование ответа JSON в тип ProjBobcat Если вы используете JSON.NET (Newtonsoft.JSON) в своем проекте. Вы можете использовать код, подобный приведенному ниже, для преобразования ответа сервера, который вы получили, в соответствующий тип ProjBobcat: // Запрос данных из Mojang API (пример, не реальный код) ... var responseJson = await res.Content.ReadAsStringAsync(); // Преобразование ответа JSON в тип ProjBobcat // [!code focus] var manifest = JsonConvert.DeserializeObject<VersionManifest>(responseJson); // [!code focus] // Получение списка версий // [!code focus] var versions = manifest.Versions; // [!code focus] Здесь versions — это массив Versions, необходимый распознавателю ассетов. Инициализация распознавателя Вы можете инициализировать распознаватель ассетов с помощью следующего кода: var resolver = new AssetInfoResolver { AssetIndexUriRoot = \"https://launchermeta.mojang.com/\", AssetUriRoot = \"https://resources.download.minecraft.net/\", BasePath = \"[GAME_ROOT_PATH]\", VersionInfo = [SEARCHED_VERSION_INFO], CheckLocalFiles = [CHECK_LOCAL_FILES], Versions = versions // Массив версий, полученный на предыдущем шаге }; В приведенном выше блоке кода замените эти параметры в соответствии с вашей реальной ситуацией: Элемент Описание [GAME_ROOT_PATH] Корневой каталог игры, обычно путь к папке .minecraft [SEARCHED_VERSION_INFO] VersionInfo версии для проверки (получается через локатор игр) [CHECK_LOCAL_FILES] Проверка локальных файлов (если false, все проверки пропускаются)"
  },
  "temp/docs-main/ruRU/projbobcat/resourceCompleter/resourceInfoResolver/gameLoggingInfoResolver.html": {
    "href": "temp/docs-main/ruRU/projbobcat/resourceCompleter/resourceInfoResolver/gameLoggingInfoResolver.html",
    "title": "Распознаватель компонентов форматирования журнала log4j | Qomicex.Core API文档",
    "summary": "Распознаватель компонентов форматирования журнала log4j [[toc]] Распознаватель компонентов форматирования журнала log4j предоставляет функции для разбора и проверки файлов ассетов игры, которые хранятся в каталоге .minecraft/logging. Использование этого распознавателя ресурсов позволяет Minecraft выводить содержимое журнала, отформатированное с помощью log4j, подобно следующему: <log4j:Event logger=\"ekb\" timestamp=\"1676012129\" level=\"INFO\" thread=\"Render thread\"> <log4j:Message> <![CDATA[Created: 512x512x4 minecraft:textures/atlas/shulker_boxes.png-atlas]]> </log4j:Message> </log4j:Event> Инициализация распознавателя Вы можете инициализировать распознаватель компонентов форматирования журнала log4j с помощью следующего кода: var resolver = new GameLoggingInfoResolver { BasePath = \"[GAME_ROOT_PATH]\", VersionInfo = [SEARCHED_VERSION_INFO], CheckLocalFiles = [CHECK_LOCAL_FILES] }; В приведенном выше блоке кода замените эти параметры в соответствии с вашей реальной ситуацией: Элемент Описание [GAME_ROOT_PATH] Корневой каталог игры, обычно путь к папке .minecraft [SEARCHED_VERSION_INFO] VersionInfo версии для проверки (получается через локатор игр) [CHECK_LOCAL_FILES] Проверка локальных файлов (если false, все проверки пропускаются)"
  },
  "temp/docs-main/ruRU/projbobcat/resourceCompleter/resourceInfoResolver/index.html": {
    "href": "temp/docs-main/ruRU/projbobcat/resourceCompleter/resourceInfoResolver/index.html",
    "title": "Распознаватель информации о ресурсах | Qomicex.Core API文档",
    "summary": "Распознаватель информации о ресурсах В ProjBobcat мы используем распознаватель информации о ресурсах (ResourceInfoResolver), чтобы помочь комплитеру ресурсов определить недостающие файлы Minecraft. В следующей таблице показаны распознаватели ресурсов, которые в настоящее время поддерживаются ProjBobcat: Имя класса Введение AssetInfoResolver Используется для разбора ассетов, необходимых для игры (аудио, языки, шрифты, текстуры и т. д.) GameLoggingInfoResolver Используется для разбора компонента форматирования журнала log4j, предоставляемого официальным Minecraft LibraryInfoResolver Используется для разбора файлов библиотек, необходимых для запуска игры VersionInfoResolver Используется для разбора файлов JAR, указанных в игровом JSON"
  },
  "temp/docs-main/ruRU/projbobcat/resourceCompleter/resourceInfoResolver/libraryInfoResolver.html": {
    "href": "temp/docs-main/ruRU/projbobcat/resourceCompleter/resourceInfoResolver/libraryInfoResolver.html",
    "title": "Распознаватель библиотек | Qomicex.Core API文档",
    "summary": "Распознаватель библиотек [[toc]] Распознаватель библиотек предоставляет функции для разбора и проверки файлов ассетов игры, которые хранятся в каталоге .minecraft/libraries. Эти файлы являются файлами времени выполнения, необходимыми для запуска Minecraft. Инициализация распознавателя Вы можете инициализировать распознаватель библиотек с помощью следующего кода: var resolver = new LibraryInfoResolver { BasePath = \"[GAME_ROOT_PATH]\", ForgeUriRoot = \"https://files.minecraftforge.net/maven/\", ForgeMavenUriRoot = \"https://maven.minecraftforge.net/\", ForgeMavenOldUriRoot = \"https://files.minecraftforge.net/maven/\", FabricMavenUriRoot = \"https://maven.fabricmc.net/\", LibraryUriRoot = \"https://libraries.minecraft.net/\", VersionInfo = [SEARCHED_VERSION_INFO], CheckLocalFiles = [CHECK_LOCAL_FILES] }; В приведенном выше блоке кода замените эти параметры в соответствии с вашей реальной ситуацией: Элемент Описание [GAME_ROOT_PATH] Корневой каталог игры, обычно путь к папке .minecraft [SEARCHED_VERSION_INFO] VersionInfo версии для проверки (получается через локатор игр) [CHECK_LOCAL_FILES] Проверка локальных файлов (если false, все проверки пропускаются)"
  },
  "temp/docs-main/ruRU/projbobcat/resourceCompleter/resourceInfoResolver/versionInfoResolver.html": {
    "href": "temp/docs-main/ruRU/projbobcat/resourceCompleter/resourceInfoResolver/versionInfoResolver.html",
    "title": "Распознаватель информации о версии | Qomicex.Core API文档",
    "summary": "Распознаватель информации о версии [[toc]] Распознаватель информации о версии предоставляет функции для разбора и проверки файлов ассетов игры, которые хранятся в каталоге .minecraft/versions/{GAME_VERSION}/{GAME_VERSION}.jar. Эти файлы являются основными файлами, необходимыми для запуска Minecraft. Инициализация распознавателя Вы можете инициализировать распознаватель с помощью следующего кода: var resolver = new VersionInfoResolver { BasePath = \"[GAME_ROOT_PATH]\", VersionInfo = [SEARCHED_VERSION_INFO], CheckLocalFiles = [CHECK_LOCAL_FILES] }; В приведенном выше блоке кода замените эти параметры в соответствии с вашей реальной ситуацией: Элемент Описание [GAME_ROOT_PATH] Корневой каталог игры, обычно путь к папке .minecraft [SEARCHED_VERSION_INFO] VersionInfo версии для проверки (получается через локатор игр) [CHECK_LOCAL_FILES] Проверка локальных файлов (если false, все проверки пропускаются)"
  },
  "temp/docs-main/ruRU/skin/index.html": {
    "href": "temp/docs-main/ruRU/skin/index.html",
    "title": "Minecraft 皮肤规范（1.18+） | Qomicex.Core API文档",
    "summary": "Minecraft 皮肤规范（1.18+） 以下是从 Minecraft 1.18 开始的新皮肤规范 样例 1 样例2（包含网格）"
  },
  "temp/docs-main/ruRU/team.html": {
    "href": "temp/docs-main/ruRU/team.html",
    "title": "| Qomicex.Core API文档",
    "summary": "import { VPTeamPage, VPTeamPageTitle, VPTeamMembers } from 'vitepress/theme'; const members = [ { avatar: 'https://www.github.com/laolarou726.png', name: '老腊肉', title: 'Создатель', links: [ { icon: 'github', link: 'https://github.com/laolarou726' } ] }, { avatar: 'https://github.com/CodingEric.png', name: 'CodingEric', title: 'UI / UX', links: [ { icon: 'github', link: 'https://github.com/CodingEric' } ] }, { avatar: 'https://github.com/leon-o.png', name: 'Leon', title: 'UI, бэкенд-сервисы, эксплуатация и обслуживание', links: [ { icon: 'github', link: 'https://github.com/leon-o' } ] }, { avatar: 'https://github.com/komorebi64.png', name: 'Croteco', title: 'Бэкенд-сервисы, эксплуатация и обслуживание', links: [ { icon: 'github', link: 'https://github.com/komorebi64' } ] }, { avatar: 'https://github.com/fr1g.png', name: '法棍', title: 'Фронтенд, эксплуатация и обслуживание Minecraft серверов', links: [ { icon: 'github', link: 'https://github.com/fr1g' } ] } ]; Наша команда Corona Studio (日冕工作室) — это команда профессионалов и энтузиастов, основной деятельностью которой являются сторонние сервисы для игры Minecraft. Ранее известна как команда разработчиков CMFL Launcher."
  },
  "temp/docs-main/zhCN/CMFS/help/guide-pure/index.html": {
    "href": "temp/docs-main/zhCN/CMFS/help/guide-pure/index.html",
    "title": "Pure服务器帮助 | Qomicex.Core API文档",
    "summary": "Pure服务器帮助 上次更新：2026年1月27日 [[toc]] 常见问题 我应该使用什么账户加入服务器？ 目前，CMFS-Pure和CMFS-Radost仅支持微软官方账户认证。这意味着玩家必须购买并使用有效的正版账户。 我应该选择哪个地址来加入服务器？ 一般情况下，直接选择pure.craftmine.fun即可。如果提示无法连接到服务器，可以尝试使用国际解析的pure.cmfs.kami.su 或 pure.cmfs.vot.moe （国际解析并非国际优化线路！）若以上方法均不能起作用，尝试： 使用LauncherX启动器 检查网络代理和防火墙设置 检查DNS设置 我应该使用什么客户端进入服务器？ 要想加入群组服的登录服务器，至少需要Minecraft Java版原版或兼容的模组客户端，游戏版本至少为1.20.1。请注意，根据子服自有的规则，部分版本可能无法加入某些子服务器，一般情况下可以在【空间导航】菜单的悬浮提示上可见；有些客户端模组在部分子服中会破坏游戏体验，甚至可能被认定为作弊，使用兼容的模组客户端前请查看子服服规确认。 我没有名为【空间导航】的指南针 按下键盘上的斜杠/并输入menu（组合起来就是命令/menu）然后按下enter执行，同样可以打开空间导航。也可以找管理员申请补办。 如何前往子服务器？ 通过使用【空间导航】菜单，玩家可以在菜单中央一行的按钮中选择目标服务器。点击后原地等待服务器传送即可。在部分服务器中存在命令/logoff可以用于回到登录服务器，以重新选择目标服务器。 关于主城 主城是由 @康桥 主导建筑的一片优美的中式园林。可能存在方法从园内跑到外面，但是仍然什么都做不了。 群聊… 欢迎加入总群：419902868 或Pure群：805935004。这些群聊遵从日冕工作室的公开交流群管理规定和条款 群组服规则（总则） 在任何组成服务器中作弊都是禁止的。所有子服务器都不接受对作弊、外挂的辩解。 利用服务器特性干扰服务器正常运行的行为是禁止的。登录服有权将任何人列入禁止进入的黑名单。 在子服违反子服规则，也可能根据恶劣程度受到全群组的处罚。"
  },
  "temp/docs-main/zhCN/CMFS/help/guide-pure/survival-commands.html": {
    "href": "temp/docs-main/zhCN/CMFS/help/guide-pure/survival-commands.html",
    "title": "命令 | Qomicex.Core API文档",
    "summary": "@useFixer 命令 这里列出了一些有助于游戏或属于本服特色的命令。 :::warning 没有进行分类 有空再说 ::: /compass: 打开一个类似HUD的指南针【来自：purpur】 /logoff: 登出当前子服 /coi: 查询方块操作记录（切换，相当于/co i） /avalon: 前往主世界（幻想乡） /legacy: 前往旧梦地 /clear-my-trip <? | yes>: 清除两个世界之间的跨越记录。附加yes表示确认清除。 /where <~player>: 查询一个玩家当前所在的维度。对方也将收到被你查询的通知。 /age <? | all>: 查询日龄。第一个参数留空以查询自己的日龄，使用all查询排行榜前十名。使用此命令有25秒冷却时间。 /sos & /sos-solved: 呼救。这将广播你的坐标和所处纬度。使用/sos-solved取消呼救。 /disable-my-protect: 在新手保护期期间使用此命令以提前关闭自己的新手保护。 /setchatcolor <? | ~colorHexCode>: 为自己的聊天文字设置颜色。留空则重置为默认。示例：/setchatcolor <#39c5bb> /report: 将触发内置举报功能，下一条消息将作为举报内容发送到服务端。发送.//将取消此次举报。 /joke: 随机一条笑话。 /random-info: 随机一条Tips。 /date & /date-info: 查询日期的命令。后者会提供更完善的内容。 /tell <~player> <~text>: 说悄悄话，第一个参数是你要说给谁听（必须在线），第二个参数开始是你的悄悄话内容。请注意，悄悄话会被记录在服务器后台和双方客户端的日志之中。【来自：原版】 /me <~text>: 用一种戏剧化的方式发言或表达自己的状态到聊天区。 /welcome_newbee: 在新玩家进入服务器的时候，聊天区出现的“点我”实际上执行这个命令，将会发送一条有历史渊源的欢迎词。 /tps: 查询当前服务器的TPS（刻每秒，用于参考服务器运行压力，越高越好，一般20为上限） /ping: 查询当前到服务器的真实延迟【来自：paper】 /gsit: 随地坐下【来自：GSit】 /: 未完待续（上次更新：2026年1月27日） 注释 符号含义 <blablabla>：命令参数。这意味着这里必须填入blablabla，否则无法达成命令介绍的效果。 <? | blabla>：命令参数可为空或blabla。 <~player>：输入任意一个玩家名称作为参数。 <...text>：输入任意文本，或多个参数都是文本。 /cmd1 & /cmd2：两个命令相同或差别很小。 命令来源 此处列举的命令有多个来源。它可能来自原版游戏，可能来自服务端，或者来自哪个插件或脚本。本页标注的所有非自定义命令（使用脚本或定制插件实现的）都标注了来源。i"
  },
  "temp/docs-main/zhCN/CMFS/help/guide-pure/survival-gameplay.html": {
    "href": "temp/docs-main/zhCN/CMFS/help/guide-pure/survival-gameplay.html",
    "title": "| Qomicex.Core API文档",
    "summary": ""
  },
  "temp/docs-main/zhCN/CMFS/help/guide-pure/survival-rules.html": {
    "href": "temp/docs-main/zhCN/CMFS/help/guide-pure/survival-rules.html",
    "title": "令行禁止、陟罚臧否 | Qomicex.Core API文档",
    "summary": "@useFixer 令行禁止、陟罚臧否 在这里查看“生存服中，什么是可以做的，什么是不能做的”。 [[toc]] 处罚类型 在服务器中存在以下类型的处罚。 1）世界内处罚 包括但不限于：没收违规所得、清空账户（背包等）数据、清空常住地存储的物品、拆除建筑、移除存在痕迹i 在服务器活跃玩家中超过2/3同意的情况下可以处以移除存在痕迹的惩罚。这将直接重新生成其住地的部分方块，或进一步扩大到删除其所有建筑和留下的文字信息。只要是个正常人类应该都不会触发这一条。i 2）行为限制 包括但不限于：禁止使用指令、限制世界内行动、公屏禁言、禁止穿戴盔甲、禁止建造（若禁止建造特定类型的结构，若发现私自建造，可直接触发封禁）i 3）封禁和共享黑名单 账户封禁一般都有时限，0.5~30天或更高不等，原则上不处以永久封禁。i 对于未成年在校学生的封禁应该酌情适用非工作日计日。即，如果是行为恶劣且悔改态度不良的未成年在校学生（无论休学、走读与否），自动将封禁日分散到每个周末，并且在所有周末之间的工作日也保持封禁状态。假设小乃龙符合条件并在周六起被封禁3天，实际封禁生效时长为此周六到下周六（包括周一到周五），周日当天解除封禁。实际情况会根据法定节假日调整，但是如果进一步恶劣也可以考虑只参考周末为非工作日。学校特殊假期（比如中高考考场假）或其他不在法定节假日的不在校情况不算在内。i 行为格外恶劣的，管理层将会在服主圈子内传播证据以警告其他服主慎重对待违规者。一般来讲正常人在我们这不会出现这种情况。i 连坐制度和数罪并罚 部分针对恶劣行为的处罚适用于连坐。连坐倍率由涉事账号数量决定，即：i A * d = s A：涉事账号总数。如果持有者有其他已知小号，则一并算在内 d：被裁定的总处罚量（封禁天数或其他量化数字，单位不同则分开计算） s：给每个账号的实际处罚量 假设Alex和Steve十分恶劣地偷了Noob的家、辱骂了Noob、许诺给Noob买瓜子却拖延兑现，而Alex持有小号Alexandr、Alexa、Aleksandrov、Alexandria（共持有5个账户在服务器内），则根据规定裁决的处罚量：辱骂他人（封禁1天）、恶劣盗窃（封禁3天、退回所得、清空作案账号数据）应如下计算：i (5+1) * (1+3) = 24天（封禁每账户） 附加：退回所得、清空账号Alex、Steve的数据 封禁结果：Alex、Alexandr、Alexa、Aleksandrov、Alexandria、Steve六个账户分别被封禁24天 禁止行为 故意骚扰 坐在他人头上、占据他人建筑群内地皮，或其他被认为是骚扰行为，屡次要求停止但仍然未停止的，处以限制移动范围、限制命令使用一周，受害者可以主张赔偿。累计犯3次处3天以上封禁 对他人污言秽语、骂人者，先处以5天以上封禁，然后禁言15天以上。累计犯3次将封禁。禁言同步到CMFS各群 公屏骂战的所有参与方视为【影响服务器秩序-刷屏】并适用于连坐计算 通过任意渠道骚扰其他玩家的，适用《公开群规》和本规则联合处罚。严重者将报至有关执法机关 盗窃 未留借用木牌的紧急借用、未经允许的取用、超过约定时间的借用、借用导致物品损坏且不赔偿，未得到物品主人宽容谅解的，被视为一般盗窃，勒令退还同样物品，累计犯3次处1天以上封禁 破坏、拆解他人建筑物并将物品据为己有的，处3天以上封禁，退回违规所得 恶意发起PVP 若被攻击者明确表示不希望打架，发起者仍未停止攻击并造成被攻击者损失，发起者处以封禁3天以上 若攻击者意图抢劫物品，处以15天以上封禁并退回违规所得，原则上允许清空账户数据 建造陷阱坑害他人造成损失且没有警告标牌、没有得到谅解的，勒令赔偿，影响多人则封禁1天以上 破坏 制造封人塔、封人书：30天以上封禁，清空账户数据。原则上允许处以永久封禁 故意破坏、引爆、制造机器引爆、机器卡服：15天以上封禁。原则上允许处以永久封禁 故意破坏他人特殊建筑物（包括但不限于建筑群建筑、雕像、地图画、生电机器、生产场地）无论是否将材料、产品和其他在破坏过程中得到的物品据为己有，均需足额赔偿。限期内无法赔偿的，清空账户数据并封禁3天以上 作弊 所有类型的作弊均处以30天以上封禁，原则上可以处以永久封禁并被视为恶劣行为。 影响服务器秩序 打广告、引流：原则上处以永久封禁 刷屏：禁言5天以上。犯三次则处以1天以上的封禁。禁言同步到CMFS各群 卡恶性bug：区别于正常生电，利用脚本、插件、机制漏洞影响服务器平衡秩序，处以15天以上封禁，清空账户数据，上不封顶 触犯现实法律 触犯《民法典》或《治安管理处罚法》：视情况而定。如果在未违反上述其他服务器禁止条规的情况下原告决定在现实中对簿公堂，运维组将按需配合提供证据，或同时处以3天以上的封禁。 触犯《刑法》或更高级法律：严重违规，将报告执法机关并依法提供证据和其他有关信息，并永久封禁。 特别规则 在服务器的主世界-矿石替换生效区域（区域：1752 6056; 1752 -312; 8384 -312; 8384 6056）为历史问题遗留区域。如果在矿石替换区内制造世吞或三向将被封禁七天以上 原则上主世界不允许出现世吞或三向，若仅制造出来，勒令拆除；若启动，将强制删除机器并处以禁止使用命令一周的限制；若犯三次则处以5天以上的封禁 破坏旧梦地建筑的，原则上可处以永久封禁 标记有【禁止外借】工具被借出的，借出者没收工具并处以五天以上封禁，接受者处以三天以上封禁；若系偷盗抢劫，工具主人处以警告，偷盗者封禁一天并清空账户数据。 案件处理 案件参与方包括：原告（主张自己权益受到侵害的）、被告（原告主张的侵害人）、主理（法官，管理层成员）、助理（由法官指派，搜集证据或其他帮助案件处理的人） 如果原告在短期内多次报案，且最终结果都是被告无罪，则应判原告为故意骚扰。 根据实际影响判断依据罪名的量刑，主理有自由裁量权 全体成员应共同维护这个虚拟社区的环境，监督改错、举报线索。对于部分恶劣行为，一般情况下，如果活跃玩家投票同意超过2/3，将适用条规中的极端处罚。 证物 证物包含文件证物和服务器记录。 所有玩家有权限使用命令/co i来查询近期的方块操作记录。需要明确提供受损地点和容器的坐标（直接发送给主理） 其他纠纷如有必要，管理员将调取服务器日志和特别事件日志。 若要提交客户端日志、截图文件，必须确保文件包含创建日期、修改日期。不包含此类信息的线索必须结合其他玩家的线索交叉验证。 创哥理赔 只有适用于以下条件的损失适用于创哥理赔。将相关证据提交给管理员，管理员将会尝试弥补你的损失。 物品借给其他玩家，且该玩家有1个自然年未上线，且该物品有自定义名称，提供重命名过程的截图（原物品属性、重命名后物品属性 作为受害者遭遇禁止行为中认定的违规行为并受到损失、无法得到赔偿的，可以申请理赔 因服务器更新、数据损坏、机制影响/覆盖 导致损失的 以下情况因无法断定真实性或为个人原因，不进行理赔： 被盗号或其他人操作导致的物品被扔 非坑害导致的掉入虚空 非坑害、被其他人攻击导致的掉落物被清除 自己扔的（包括系统礼包因背包塞满而自动丢出，如果自己挂机导致物品丢失，自然算作个人原因） 在历史遗留问题的矿物替换区域主动放置矿物装饰物但被脚本移除的 允许的客户端Mod 正常情况下，能适度优化游玩体验且不会给他人带来负面体验的模组是可以添加的。以下是部分列表用于让玩家了解哪些mod可以用。 完全禁止 所有公认的作弊客户端和作弊模组。 矿物透视 建议不要用 Tweakeroo：部分功能可能被认为是作弊 JourneyMap：单纯我觉得不够好用；鉴于服务器推荐整合包选择了Xaero系列，想必使用Xaero将会有更好的对共享路标的支持。 e4mc：你都玩服务器了还要这个做什么？ 允许使用 Bobby Litematica AppleSkins Xaero地图系列（小地图、大地图、XPlus） 展示装备状态的HUD 客户端性能优化类 Zoomify或其他类似的放大模组 Optifine 各种连接纹理、UI优化（CozyUI等） …… 法律相关 CMFS（所有CMFS，除非另有说明），仅适用于中华人民共和国现行法律和瑞典Mojang AB的Eula、著作权声明。中国境外的用户使用CMFS同样需要遵守中华人民共和国法律。 中华人民共和国执法机关持有有效搜查令的，运维组依法配合调查和提取证据。 若在CMFS遇到合法权利受损，正在进行或即将进行诉讼需要证据，或报警立案的，运维组将尽全力固定和提供所需的证据。CMFS不承担任何因举证造成的损失或开支。 CMFS与任何的中国境内外的Minecraft著作权、商标持有人均不存在从属关系。CMFS依据Minecraft Eula等协议和其他参与的开/闭源软件许可证运营。 CMFS为学习和研究用途的公共服务部署实例，不承担因连接到CMFS后导致的任何损失的责任或其他连带责任。 管理准则 违反管理准则的运维组/管理组成员将被暂停职务, 直到日冕工作室管理组决定恢复。 核心思想 游戏服务器管理人员应当以维护所有人游戏体验和维护团队长期利益为主要目标, 在服务器规则未明令禁止的情况下, 所有管理员有权利制止任何可能违背此目标的行为, 但是一切处罚需要依照现行规则, 透明、公开地判罚和解释。 禁止行为 禁止收费或免费地给予玩家非活动允许发放的物品 如果玩家切实需要, 允许给予一些照顾, 但是禁止滥用。根据日志若被日冕管理组发现滥用,"
  },
  "temp/docs-main/zhCN/CMFS/help/guide-radost/index.html": {
    "href": "temp/docs-main/zhCN/CMFS/help/guide-radost/index.html",
    "title": "Radost 小游戏群组 | Qomicex.Core API文档",
    "summary": "Radost 小游戏群组 简介 Radost一词来自俄语Радость，意为“欢愉、快乐”。我们旨在提供一系列可以在坐在电脑前办公的闲暇之余就可以快速放松的小游戏体验，也不乏会有一些创意孵化的新鲜小游戏。 加入 直接加入Pure群组，在【空间导航】选择【Radost】即可进入小游戏菜单以选择小游戏。 :::info 连接信息 游戏版本：1.20.1+ 原版，具体见菜单中标注的子服游戏版本 地址：pure.craftmine.fun | pure.cmfs.kami.su（海外解析） 建议使用纯净原版客户端游玩 ::: 共建 加入【小游戏共建】？我们将给你提供一个契机——如果你有一定的技术，并且有想要实现的小游戏玩法，可以加入CMFS的【小游戏共建】计划。在我们提供的免费服务器面板上部署你的小游戏，然后接入CMFS-Radost小游戏群组，然后与我们一起发力宣传，看看你的小游戏反响如何！ 通过共建审核后，你将获得子服的完整OP权限，你可以全权管理属于你的免费子服。 但是与此同时，你必须遵守这些规则： 你不能允许在子服里出现任何源自Corona Studio以外的广告 你不能因为这个子服盈利。也就是说，你必须保证子服是公益运营的 你不能违反最基本的CMFS规则和国家法律法规（无论是Corona Studio所在国还是你所在国的） 你不能说开就开、说停就停；你的子服必须有一定的完成度，并且停服必须提前一个月预告；必须坚持维护运营 申请加入共建计划的实体可以是个人也可以是运营团队 你不能利用子服面板搭建无关内容 你不能直接在子服内拉起、宣传未经我们许可的群聊 注意！我们保留直接撤下子服的权利！"
  },
  "temp/docs-main/zhCN/CMFS/help/index.html": {
    "href": "temp/docs-main/zhCN/CMFS/help/index.html",
    "title": "CMFS 帮助 | Qomicex.Core API文档",
    "summary": "CMFS 帮助 ::: info 这里提供了一些您可能需要的服务器游戏帮助。 :::"
  },
  "temp/docs-main/zhCN/CMFS/help/invalid-session.html": {
    "href": "temp/docs-main/zhCN/CMFS/help/invalid-session.html",
    "title": "解决“无效的会话”问题 | Qomicex.Core API文档",
    "summary": "解决“无效的会话”问题 ::: info 在您加入开启正版验证服务器时可能会遇到来自游戏的错误提示。而这个错误提示往往伴随着解决此问题的建议。 也就是说，只有正版账号 在加入 开启正版验证的服务器时 才有可能会遇到这个问题。 ::: 一般解决方法 这个错误只会在您启动游戏并加入某正版验证服务器时所使用的正版账号的验证信息失效时发生。可能的原因如下： 游戏帐户的验证信息过期。 在此设备登陆这个账户后，又在其他设备登陆该游戏帐户，导致该验证信息失效。 因此，唯一解决方案就是：退出游戏，然后重新启动启动器以让启动器重新获取验证信息用于正版登陆。 LauncherX 用户 上述方法是原理性的，所以理论对任何启动器都有效。但是对于 LauncherX 用户来说，您无需重启启动器。只需要： 退出游戏 在恢复（默认）的 LauncherX 窗口中点击右下角您的账户名（或“请登陆”，如果您没有登陆日冕账户的话。） 找到您出问题的账户（必然是微软账户，因为这是正版登陆的问题） 右键点击它，并在右键菜单中点击“刷新” 再次启动游戏 您当然也可以通过重启 LauncherX 的方式来刷新，不过倘若此刻您的 LauncherX 任务队列中存在着下载任务呢？ 理论上，这样就可以获取到最新的验证信息，从而解决“无效会话”的问题了。 倘若仍然无法解决，您应该进行以下检查： 检查网络连接。如果您的连接存在问题，将很有可能导致无法正常获取您的正版账号信息。相关参考文章：检测网络（LauncherX） 检查您的正版账号状态。包括但不限于：账号启用状态（有没有出现封号？）和账号安全状态（账号是否被盗用？）。相关链接：Microsoft账号管理 | Mojang账号管理 | Microsoft帮助 | Minecraft: 帮助"
  },
  "temp/docs-main/zhCN/CMFS/index.html": {
    "href": "temp/docs-main/zhCN/CMFS/index.html",
    "title": "欢迎来到 CMFS 指南 | Qomicex.Core API文档",
    "summary": "欢迎来到 CMFS 指南 ——首先，感谢你选择加入 CraftMineFun Server - Minecraft群组服务器（以下简称CMFS）。本系列指南将会帮助你理解关于CMFS的一切，并发挥你的主观能动性，利用我们提供的特色玩法来建设、游览。和您的朋友们一起，抑或是在这里认识新朋友，合作游玩，或者竞赛角逐。请放心，由我们的团队来维护您的体验。如果您遇到了游玩体验上的问题，请立即联系我们！ 欢迎加入总群：419902868 或Pure群：805935004。这些群聊遵从日冕工作室的公开交流群管理规定和条款 :::warning 存在服务器处于暂停运营的状态 请等待另行通知（2025年2月27日） ::: :::tip 账户和个人验证 目前所有服务器只能使用微软账户验证，即必须使用正版国际版账户登录。 ::: 组成部分 CMFS-Pure 负责人：法棍 #纯净群组 #生存 #插件 目前已开放： Pure 生存服 :::info 连接信息 游戏版本：推荐【1.21.8】游玩（兼容1.21.2~1.21.8） 地址：pure.craftmine.fun | pure.cmfs.kami.su（海外解析） 生存服允许部分优化模组。参见：Pure生存服详细规则 ::: 加入群805935004了解更多！ 需要帮助？ CMFS-Lappland 负责人：法棍 #RPG #生存 #轻剧情 #MOD #原创 正在策划中，敬请期待！ 此服务器计划正在招贤纳士 CMFS-Radost 负责人：Dxir #纯净群组 #小游戏 #多版本 目前已开放： 黎明杀鸡 起床战争 通过Pure群组服加入小游戏！ 有玩法、有想法？欢迎与我们共同建设Radost！了解更多"
  },
  "temp/docs-main/zhCN/CMFS/servers/index.html": {
    "href": "temp/docs-main/zhCN/CMFS/servers/index.html",
    "title": "查看附属服务器和子服务器 | Qomicex.Core API文档",
    "summary": "查看附属服务器和子服务器 CMFS系列游戏服务器基本可分为纯净服和模组服两种。其中，纯净服组成一个群组服网络，而模组服基本各自独立。"
  },
  "temp/docs-main/zhCN/CMFS/servers/mood/index.html": {
    "href": "temp/docs-main/zhCN/CMFS/servers/mood/index.html",
    "title": "CMFS-Mood | Qomicex.Core API文档",
    "summary": "CMFS-Mood 由我们打造并运营的模组服务器系列。"
  },
  "temp/docs-main/zhCN/CMFS/servers/mood/lappland.html": {
    "href": "temp/docs-main/zhCN/CMFS/servers/mood/lappland.html",
    "title": "Project Lappland | Qomicex.Core API文档",
    "summary": "Project Lappland :::warning WIP 我们期待有优秀的编剧和RPG技术人员与我们一起共同实现这个世界的构筑。 ::: Project LappLand（其他地方用“ProjLapp”代称），是一个借助mod和无数脚本和魔改维持的奇特的地外冒险。我们引入一系列轻RPG元素和剧情，引导玩家在地球的遥远殖民地上自由征服。 [[toc]] 玩法 ProjLapp的剧情主要侧重于营造氛围和环境，主要玩法是特定的模组生存。 生存 全天候的玩法。围绕着故事进行经营、建立自己的聚落定居点、感受和邻居之间的“地缘事务”——就像19~20世纪的艾美莉卡西部一样，这里距离“总部”很远，这里是无主之地。 故事 你是怎么来到这里的？你又是为了什么来到这里？想必你有自己的答案——“总部”选定你参与到这样的远星拓荒之中，对你来说究竟是扬名立万的机会，还是将你推入了无底的深渊？ 活动 限时游玩的故事或经营玩法。 规则 禁止 原版生电 卡服以及其他创造大量实体的行为 不宣而战 - 偷袭行为和其他不正当破坏行为将受到惩罚 破坏任务地点 利用bug的其他恶性的行为 围堵任务地点或副本入口 其他违反公序良俗的行为 明确允许 向任何非保护期内的聚落宣战（必须先通过系统功能发起） 约架PVP（必须通过系统功能发起，且参与双方都将临时启用死亡不掉落）"
  },
  "temp/docs-main/zhCN/CMFS/servers/pure/exam.html": {
    "href": "temp/docs-main/zhCN/CMFS/servers/pure/exam.html",
    "title": "日冕重工 审核服务器 | Qomicex.Core API文档",
    "summary": "日冕重工 审核服务器 这个服务器是专供有意愿加入日冕重工的朋友进行能力考核的内部原版创造模式服务器。"
  },
  "temp/docs-main/zhCN/CMFS/servers/pure/index.html": {
    "href": "temp/docs-main/zhCN/CMFS/servers/pure/index.html",
    "title": "CMFS-Pure | Qomicex.Core API文档",
    "summary": "CMFS-Pure 这是一个包含一切我们能想象到的原版玩法的群组服务器，接入了包含：生存、小游戏、(非公开)创造 等服务器，以后视情况也将开放：空岛生存、原版创造、原版RPG 等新的子服玩法！此外，我们等待有志向的伙伴来参与共建新的小游戏玩法！（见：） 通过CSKB的目录来展开查看接入Pure群组的子服务器。"
  },
  "temp/docs-main/zhCN/CMFS/servers/pure/radost.html": {
    "href": "temp/docs-main/zhCN/CMFS/servers/pure/radost.html",
    "title": "CMFS-Radost 小游戏共建生态 | Qomicex.Core API文档",
    "summary": "CMFS-Radost 小游戏共建生态 如果你有开服经验和玩法想法，我们可以一起实现！你将获得：1）对应子服OP；2）提交你的玩法并保留你的服务端自主权；3）与CMFS管理组一并协调管理玩法！加群【】 「Radost」一词来自俄语的“Радость”, 希望你在这里感受基于原版游戏的快节奏小游戏的快乐！此系列服务器与Pure共用群组入口。 ::: info 连接信息 接受的游戏版本： 地址：pure.craftmine.fun 备用地址：pure.cmfs.kami.su | pure.cmfs.vot.moe 群聊：805935004 ::: 关于共建和其他更多信息，参见： 帮助：Radost"
  },
  "temp/docs-main/zhCN/CMFS/servers/pure/survival.html": {
    "href": "temp/docs-main/zhCN/CMFS/servers/pure/survival.html",
    "title": "CMFS Pure 原版群组-生存服 | Qomicex.Core API文档",
    "summary": "CMFS Pure 原版群组-生存服 ::: info 连接信息 地址：pure.craftmine.fun 备用：pure.cmfs.kami.su 游戏版本：原版1.20~1.21.5 服务器核心版本：Leaf/Paper, 1.21.4 群聊：805935004 ::: 其他更多信息，参见： 帮助：Pure 规则 不许开挂，不许恶意杀人，不许卡破坏性bug，不许卡服 玩家有权自行使用/co i进行查询 玩家可以借助木斧测距，但是没有其他建筑功能 禁止在历史问题遗留区域制造世吞等会造成连续爆炸和方块破坏的机械（区域：1752 6056; 1752 -312; 8384 -312; 8384 6056） 禁止其他违反公序良俗的行为 完整规则，参见：Pure生存服详细规则 玩法 轻微修改的原版生存！服务端恢复了无头活塞、刷线等轻生电必备的【特性】，并且加入了一些扩展性的玩法和细节： 你可以对怪物扔砖头！有真实伤害的！ 遇到险情？使用命令/sos广播呼救！ 组织你的聚落！带上你的伙伴→准备一个聚落名称和合适的头衔文字颜色→向管理员申请创建你的聚落，即可为聚落成员启用唯一的聊天区标识！ 彩色聊天文字！使用 /setchatcolor <颜色代码> (支持16进制颜色码) 为你的聊天文本应用颜色！ 新手（死亡不掉落、禁用PVP）保护！（累计游玩50游戏日将自动移除新手保护）~ 如果觉得自己不需要，可以关闭自己的新手保护：命令 /disable-my-protect后在聊天区发送y来关闭 游戏日查询和全服游戏日榜单（命令 /age） 日历系统！记录日期，看自己的聚落每天成长的一点一滴 可以手动用腐肉进行堆肥！ 试试用火矢点燃篝火！ 幻翼骑乘！建筑玩家狂喜2333 双主世界！我们将旧时代的CMFS原版生存服的主世界接入到了此服务器，去参观以前内部人员的建造吧！ 还有更多实用小命令等你尝试！/report、/joke、/logoff、/random-info... 相关阅读：Pure命令详解 | Pure玩法详解"
  },
  "temp/docs-main/zhCN/geula.html": {
    "href": "temp/docs-main/zhCN/geula.html",
    "title": "通用隐私政策和最终用户许可协议 | Qomicex.Core API文档",
    "summary": "@useFixer 通用隐私政策和最终用户许可协议 :::warning 由于目前提供的服务有限，这里会频繁地更新。当内容出现重大更新 (包括服务内容变更: 添加/删除/修改，向使用我们服务和产品的【用户】但是不包括优化遣词造句) 时候，我们才会通知您。 我们是用爱发电的团队，我们也懒得侵犯您的数据隐私。 本页面更新于 2025年5月3日，没有更新通知。试行。 ::: [[toc]] 1) 简而述之… 我们是一个用爱发电的团队，目前没有与任何一个第三方实体有任何利益往来。我们不记录也不追踪您的广告ID，我们也不在服务中植入动态广告。i 我们在为您提供在线服务的过程中，使用主流的加密方案传输和存储最基本的、能让我们在茫茫信息流之中认出您的信息: 包括且不限于您的IP地址，LauncherX收集清单中的信息 (若拒绝遥测则不会获取遥测部分的信息)，您主动提供的邮箱地址、您在使用LauncherX保存微软账户时提供的由微软验证并保护的密钥 (用于验证您微软账户的可用性，这关系到您能否使用微软账户来游玩Minecraft)、缓存的玩家皮肤(用于皮肤预览，这属于您与Mojang AB缔结的用户协议的一部分.); 以及在您登陆我们的在线服务时，产生的用户密钥和必要信息 (包括邮箱、登陆设备IP、在P2P服务器注册的房间记录等)。i 此外，在您使用CMFS服务时，正版验证服务器将会缓存您正版游戏账户的UUID、加密皮肤缓存、登陆设备IP以及服务器内聊天记录 (作为服务器运行日志保存)。i 可能我们活得气若游丝，但是我们想要活得清白。i 2) 在线存储、传输和用户隐私保障 总则 针对不同的在线服务需要，您的必要信息将会由您使用的客户端 (网页浏览器、游戏本体、由我们提供的客户端应用程序) 代为收集，并通过网络加密传输到我们处理信息所使用的服务器。这个服务器可能是由第三方提供服务 (比如，我们处理您的Minecraft在线账户必须通过Microsoft的验证。这部分服务协议在您注册微软账户时候应当已经同意.) 我们仅能保证和尽力维护您从运营商区域网络到达我们相关服务器的传输安全，在此之前在您必要经过的网络上出现的意外 (网络被劫持、被侵入、网络不可用等) 恕我们不能为此负责。i 您为了使用服务所必须提供的信息，除非另行说明或者明显是委托第三方的服务，否则均会由我们妥善加密保存，并仅供与此相关的由我们提供的在线服务所使用。i :::danger 请注意! 使用代理上网相当于把您的信息传输委托到了第三方。请确保此第三方可信任，出现的任何意外将不由我们承担责任。此外，部分我们的客户端 (比如LauncherX) 在不正确的代理设置下可能导致部分在线功能不可用。i ::: 同意协议和撤回同意 请注意，为了证明您同意或不同意，我们可能会需要通过各种合法方法来取得您作为用户（或曾为用户）的身份确认。i a) 同意 一般来说，使用我们提供的服务和/或产品本身没有繁杂的协议和弯弯绕。我们从用户的角度出发，收集我们维持程序运转的必要信息和非敏感的环境信息等。与此同时，若您访问和提交内容到CSKB / 仅浏览我们的网站内容，则不需要完全同意本协议。但是浏览期间，您的互联网协议地址（IP）无论是否通过代理都必然会被网络运营的各个部分获取，因为这是通过互联网传输信息的必要前提。i 对于我们分发的软件产品，您有权利在正式开始使用之前阅读有关条文协议，点击【同意】或等效按钮继续使用将被视为您同意了此协议及相关的其他协议（如果有），若您不同意则请立即停止使用。i 对于我们通过互联网提供的网站和服务，在合适的地方我们会提示您，您需要阅读有关条文协议，而继续访问服务的操作（比如，注册账户和登录操作）和/或其他明确表示同意的行为（比如，勾选 “我已同意…” ）将被视为同意协议。与此同时，网站可能会单独请求同意使用信息或通知您网站使用了特定技术。i 对于我们提供的公益性质游戏服务器，请参阅本站的CMFS部分（参见：欢迎来到 CMFS 指南 | 日冕知识库），以确认其附属的用户协议等内容。我们要求附属服务器的各个分管团队在您首次登入服务器的时候在游戏中推送给您，并且将在玩家群聊中以群公告的形式引导您阅读（如果有）。首次加入服务器游玩、注册玩家信息等产生玩家信息将被视为同意本协议有关CMFS的部分及附属的用户协议等内容。i 总而言之，表示【同意】的行为视提供和/或呈现此协议时附带的文字说明而定。它可以是“继续使用即为同意”，也可以是“勾选以同意”，也可以是“点击同意”。i b) 撤回 出于人与人之间最基本的信任，我们相信您在撤回同意生效期间不会直接或间接地再使用我们的任何产品和服务。在您停止使用或间接使用我们的产品和服务满30天后，或提供有效的撤回声明，即可视为撤回同意。但是，在撤回同意后的任意时段使用我们的产品和服务（除了CSKB）参照同意协议的行为，会被视为再次同意本协议。仅浏览我们提供的网站不被视作再次同意。i 与此同时，针对日冕账户（CSA），您若需要停止使用我们的服务并删除账户，视为撤回对我们储存和使用您提供的个人信息的同意；要删除账户，您可以登录到corona.studio后，在个人中心找到【注销并删除】账户的按钮。此操作不可逆，将会删除包括我们保存的必要用户数据、赞助记录、皮肤站信息（如有）之内的一切数据。i 资产 我们持有的资产包括声明的知识产权、持有的软件/内容仓库和数据库数据。您主动提供的数据被视为资产的一部分，将被我们存储至数据库，以用于向您提供服务。对于涉及您敏感信息的内容，我们将按需进行脱敏、加密保存。具体参见下文关于隐私收集和处理的部分。i 收集清单 以下是不同包含在线服务的产品的收集清单。 1. 日冕账户 这是访问我们绝大多数在线服务的前提。在需要使用其登陆时，我们会提示您。 收集项目 介绍 邮箱地址 用于标识您的账户并在后续向您发出通知。 加密后的密码 用于确认登陆账户的客体是不是您本人。 用户名 这是友好展示您个人资料的文字内容。 头像(若不上传则为随机图片) 这是友好展示您个人资料的图像内容。 2. LauncherX 详情: 官网 | 官网.min 标注[*]的项目为可选项目。您可以在初次启动配置时或随时在 [设置->高级: 数据采集和隐私政策] 中调整收集与否。 标注[+]的项目为匿名上传的，完全不与您的个人信息绑定。 收集项目 介绍 互联网协议地址(IP) 通过互联网传输信息的必要前提。 用户计算机硬件配置 这是识别这台计算机并形成唯一识别证据的必要信息。 仅在您使用预览版或绑定设备时上传并保存 计算机名称 用于友好地在设备列表中展示您的设备。 仅在您使用预览版或绑定设备时上传并保存 由LauncherX发起的网络活动+ 这将会帮助我们分析和优化。 启动器任务调度详情+ 这将用于分析启动器任务处理性能，并将帮助我们来优化相关功能。 启动器产生的日志+ 无论是否登陆了启动器账户，都会脱敏后加密上传日志和错误报告。 部分启动器操作事件 与我们在线服务器直接交互的操作。比如“绑定设备”、“解绑设备” 崩溃信息+ 更严重的错误信息会相比于日志而言收集更详细的环境信息，并将在崩溃时立刻发出。 系统语言和地区*+ 用于收集和分析不同国家区域、使用不同语言的用户的使用习惯。 需要反馈本地化问题? 请按照反馈格式向我们反馈。 操作系统版本*+ 用于辅助分析软件环境情况 游戏启动事件*+ 用于跟踪启动错误和分析错误、优化产品。 游戏时长*+ 用于辅助分析游戏崩溃原因。如果是玩太久导致的溢出等错误那就不是我们的问题。请适当娱乐。 使用时长*+ 用于辅助分析本体崩溃原因。 游戏启动参数*+ 用于辅助分析启动错误 有关游戏启动参数配置，您可以参阅: 启动参数配置指引 3. CS Official Site 详情: 官网 这项服务通过Cloudflare加速。少量信息(包括IP)可能会经由这些服务提供方。 收集项目 介绍 互联网协议地址(IP) 通过互联网传输信息的必要前提。 日冕账户(可选) 在您登陆后可用于管理账户和LauncherX绑定设备管理等。 由我们创建的SessionStorage 临时存储的登陆凭证。 隐私通知已阅与否 (存储在LocalStorage) 记录您是否已经“了解并关闭”了页面的隐私声明。 4. CS Official Site MIN 详情: 官网.MIN | 官网.MIN.another 这项服务通过Cloudflare加速，部署在vercel平台。少量信息(包括IP)可能会经由这些服务提供方。 MIN.another 部署在热铁盒网页托管。 收集项目 介绍 互联网协议地址(IP) 通过互联网传输信息的必要前提。 外观偏好(存储在LocalStorage) 暂存您选择的深色/浅色模式设定。 隐私通知已阅与否 (存储在LocalStorage) 记录您是否已经“了解并关闭”了页面的隐私声明。 5. CMFS 详情: 官网 | 官网.min CMFS附属的所有游戏服务器均可能会将您的游戏行为脱敏后通过遥测加密传输到服务端可能内置的bStats。我们在有需要的情况下会借助Spark进行在线性能分析。与此同时，您在游玩时必须遵守Mojang的Minecraft Eula.i 请参阅本站的CMFS部分（参见：欢迎来到 CMFS 指南 | 日冕知识库），以确认其附属的用户协议等内容。我们要求附属服务器的各个分管团队在您首次登入服务器的时候在游戏中推送给您，并且将在玩家群聊中以群公告的形式引导您阅读（如果有）。i 收集项目 介绍 互联网协议地址(IP) 通过互联网传输信息的必要前提。 游戏客户端信息 用于反作弊和对接游戏行为。 玩家信息 (正版玩家和外置登陆玩家的UUID、皮肤) 用于识别玩家和展示游戏内名称和皮肤。 6. CSKB 详情: 日冕知识库 收集项目 介绍 互联网协议地址(IP) 通过互联网传输信息的必要前提。* ::: info 例外 日冕知识库是完全公益性质的。其内容使用MIT协议提供和分享、共建（除非引用文章有特别说明 —— 在直接引用CSKB文章时，不得引用包含特别许可证的文章，除非遵从其许可证或得到原作者许可）。日冕知识库的访问流量指向其托管平台和中间的网络服务提供商，我们仅管理和展示、提供内容。因此，CSKB在您访问时不会征求您同意本协议，与此同时，在撤回同意期间和之后使用CSKB的内容本身（阅览、提交贡献、引用）不被视为中止撤回同意或同意本协议。i 当前日冕知识库部署在 Github，即，Github 是CSKB 的托管平台，在访问时和访问期间，您的数据经由 Github、Github 选择的网络服务商、您的ISP、Cloudflare 加密传输。日冕工作室无法获取到您的信息，除非您通过托管平台提交内容。请自行保护自己的信息安全，并且您在提交内容时被视为已经同意了托管平台的有关政策。i Github 是 Github Inc. 的商标；Cloudflare 是 Cloudflare Inc. 的商标。 ::: 3) 免责声明 对于特定的情况和一切非因来自我们的错误导致的问题所造成的一切后果，我们概不负责。i 用户行为免责 由于您未按照提示操作导致的错误和损失，我们不负责。 由于您使用服务时使用的终端的环境问题导致的不可用，或是由于您个人主观意愿对服务在您终端本地运作环境制造的障碍导致的原因致使我们的服务出现错误，我们不负责。 其他环节原因免责 极个别地区出现的服务访问困难问题是我们难以解决的。我们会尝试解决，但是不保证可以解决。 因网络攻击、自然灾害等不可抗力、难以预料和防御的突发情况导致的问题，我们不负责任。但是我们会尽可能恢复我们预期的服务状态。 边缘情况免责 边缘情况是由我们提供的服务在极不常见的使用情况下出现错误导致的异常。 我们对一切符合边缘情况条件并且没有造成严重后果的故障不负责任，但是我们仍然会尝试修复这些错误。i 由于各种原因 (包括但不限于软件框架限制) 导致的边缘使用情况引起的非预期错误 (比如，LauncherX可能在极度快速切换界面时可能出现显示错误。) 由于硬件和/或软件环境差异导致的性能异常 (比如，在个别设备上LauncherX可能需要耗费十几秒时间启动自身，但是在 “与系统熟悉后” 却可以做到仅仅两三秒即可启动自身) 除此之外的问题请务必向我们反馈。i 4) 用户许可协议 关于您能如何使用我们产品的协议。在使用我们的产品和/或服务时，请严格遵守所在地的法律法规、中华人民共和国的相关法律法规，以及其他诸如开源项目许可证之类的附加项。我们希望您正常地使用一切工具，过好自己的生活。i 开源项目 请严格遵守项目对应的开源许可证. ::: tip 目前我们的开源项目均在Github可见 查看我们的Github主页: https://github.com/corona-studio 此处不再展示完整的开源项目及其许可证列表。 ::: ::: details CSKB 例外 CSKB 在原则上要求贡献者基于MIT许可证提交内容贡献。我们建议只提交使用同许可证或更宽松的许可证的内容。但是如果是转载文章且文章原作者并未授权更改许可证的转载，或是作者一定要使用更严格的许可证，则：i 其他人挪用CSKB内容时，必须将使用不兼容许可证的内容排除； 若要再转载使用更严格许可证的内容，必须征得原作者的允许或遵守对应的许可。 如若发现CSKB中有对您的内容的侵权行为，请通过 CSKB Issues 提交举报并举证，我们会尽快处理。 ::: 闭源项目 请展开来查看详细信息. ::: details LauncherX 您可以将LauncherX打包进您的懒人包/完整包中(无论是否使用LauncherX的打包功能)，但是您不能: 违反游戏版权方的用户协议 售卖打包成品 售卖LauncherX程序文件 将LauncherX署名/宣称为自己的作品 …其他会对LauncherX之存在造成负面影响的行为，我们将会自行认定和解释负面影响。 2019~当今，我们对LauncherX（由Corona Studio推出的游戏启动器）保留一切权利。 ::: 其他 ::: details 更新记录 2025年2月25日：添加了同意与撤回同意相关的描述，并且修正了一些符号错误，为本页引入扩展样式。 2025年2月27日：细化规则，细化适用场景，修改部分内容，删除开源项目列表（应该直接去Github查看） ::: 文档有效性 2025年2月27日：暂行/无效，因为尚未完成审核。"
  },
  "temp/docs-main/zhCN/guide/account.html": {
    "href": "temp/docs-main/zhCN/guide/account.html",
    "title": "日冕账户 CSA | Qomicex.Core API文档",
    "summary": "日冕账户 CSA 日冕账户(Corona Studio Account，CSA) 是对于绝大多数由我们提供在线服务可用的账户，用于识别唯一的用户。为了防止出现一些不必要的纠纷，请不要外借您的账户。 如需删除账户，请登录到corona.studio后，在个人中心找到注销账户的按钮。此操作不可逆，将会删除包括我们保存的必要用户数据、赞助记录、皮肤站信息（如有）之内的一切数据。"
  },
  "temp/docs-main/zhCN/guide/code_of_joining_application.html": {
    "href": "temp/docs-main/zhCN/guide/code_of_joining_application.html",
    "title": "新成员审核规则 | Qomicex.Core API文档",
    "summary": "新成员审核规则 编辑中，编辑完成后将会由llr复核然后公开."
  },
  "temp/docs-main/zhCN/guide/contact.html": {
    "href": "temp/docs-main/zhCN/guide/contact.html",
    "title": "指路官方 | Qomicex.Core API文档",
    "summary": "指路官方 与我们取得联系！ 更新于：2024年3月23日 平台 联系方式 QQ群（LauncherX 1） 589798569 QQ群（LauncherX 2） 772039197 QQ群（CMFS） 419902868 QQ群（ProjBobcat） 677872263 QQ群（新成员审核） 1040526762 ######### ######## Bilibili llr老腊肉 合作QQ频道(包含LauncherX支持) 「我的世界」 KOOK CoronaStudio 酷安 CoronaStudio MineBBS CoronaStudio ::: warning 部分联系方式可能不对所有地区的用户开放。 :::"
  },
  "temp/docs-main/zhCN/guide/general/check-system.html": {
    "href": "temp/docs-main/zhCN/guide/general/check-system.html",
    "title": "辨识计算机环境 | Qomicex.Core API文档",
    "summary": "辨识计算机环境 本文将简单介绍三类主流系统中判断系统版本和架构的方法。如果你确认你本来就知道，那就没必要看这篇文章。 [[toc]] Windows 首先，大致判断你的系统 根据winver.exe 按下组合键WIN + R 在弹出窗口里输入winver，然后点击运行 在弹出窗口中可以看到你的系统版本。根据版本选择 #1 或是 #2 继续操作。 根据外观 如果你的电脑系统开机后可看见 “欢迎使用”： 这是Windows XP，我们的软件不支持。 如果你的任务栏和窗口标题栏看起来很圆润，或是在开机时候底部可见【Windows 7 xx版】或【Windows Vista】： 这是Windows Vista或7，转到下文中的 #1 继续操作。 如果你的开始按钮不可见，或者开始按钮可见是一个斜面的四格图标，并且你的开始菜单是全屏的可以横向滚动的磁贴形式（全是大小不一的方块）： 这是Windows8或Windows8.1，转到下文中的 #1 继续操作。 如果你的开始按钮旁有一个圆环图标或搜索图标（除非它们被关闭了），且开始菜单存在一些磁贴（不全是磁贴，不一定全屏，除非你自己更改过默认开始菜单），并且系统图标看起来是扁平的（而不是圆润的）并且开机动画是几个点转圈，登陆进入系统时背景是你的锁屏壁纸： 这是Windows10。早期版本和后期红石更新有较大区别，但是八九不离十。下文中的 #1 和 #2 可能都适合你。 如果你的底部任务栏（除非你把它挪走了）上的开始按钮中可见【开始】字样，任务栏和窗口标题栏背景是灰色的，窗口是直角的，几乎不可见窗口动效动画： 这可能是Windows XP、Windows 7、Windows8/8.1（精简版），或者更早的Windows。你可以尝试通过 #1 的步骤进行确认。这样的外观往往是被手动设置过后，或是处于安全模式（Windows 7 +），或是出于其他情况。 如果你开机后能看到锁屏界面并且时钟居中显示，或任务栏上的开始按钮是略显圆润的正方形四格图标，并且你在一些系统界面里点击右键出现的菜单是等边距的圆润的菜单（往往包含简洁的图标）： 这是Windows 11。转到下文中的 #2 继续操作。 如果是这里没有提及的外观： 你的系统外观可能被大幅度篡改了，或者本文未能及时更新（最后更新：2025年1月16日），尝试使用上文winver.exe方法判断系统版本。 ::: info Windows Server 请注意，对于Windows Server，判断标准大致一致。 一般而言，Windows8及以后版本的Windows在UI风格上与WS2013及以后的Server版本一致，可以尝试找到设置后按#2方法操作，找不到设置则按#1方法。 对于更早版本的Windows Server，我们无法保证兼容性。 ::: 其次，依据大致的系统版本确认详细信息 较老的Windows （Vista/7/8/8.1/早期10） 在桌面的空白区域右键点击鼠标，选择【属性】 将会弹出一个来自控制面板的窗口。在这个窗口里可以查看系统的关键信息。 找寻关键词，然后参考文末的一般词对照表来确认你的电脑使用的系统具体版本和CPU架构。 较新的Windows（红石10/11） 打开系统设置（或使用组合键WIN + I） 搜索或找到： [系统 -> 系统信息] 或 [系统 -> 关于] 在这里可以查看系统信息。参考文末的一般词对照表来确认你的电脑使用的系统具体版本和CPU架构。 Linux Linux用户一般都知道自己的操作系统版本和类型以及处理器架构。如果不知道的话，参见下文中通用的方法。 请注意，我们的产品除非是命令行应用程序，否则需要一个桌面环境来运行。 参考文末的一般词对照表来确认你的电脑使用的系统具体版本和CPU架构。 macOS 一般而言，可以通过点击左上角的Apple图标后点击菜单中的【关于本机】来查看关键信息。 当然，如果你喜欢使用终端，除了使用下文通用的方法，还可以： 打开终端 按下 Command + 空格键，输入 “终端”，然后按回车键打开终端。 输入以下命令 sw_vers 查看输出结果 终端会显示类似以下的信息： ProductName: macOS ProductVersion: 13.0.1 BuildVersion: 22A400 其中，ProductVersion 表示 macOS 的版本号。 如果想要查看CPU架构： 在终端中输入以下命令： arch 查看输出结果： 如果结果是 arm64，说明你的系统当前运行在 Apple Silicon（ARM 架构）。 如果结果是 i386 或 x86_64，说明你的系统运行在 Intel 架构。 参考文末的一般词对照表来确认你的电脑使用的系统具体版本和CPU架构。 通用的方法（xxfetch） 对于上述系统的现代化版本（即，肉眼可见的能感受到系统它很新：Windows10+，macOS10.15+，Linux(内核版本5+)）一般都可以通过安装一种fetch工具来获取当前的关键系统信息。甚至可以拿来截图装X 以下介绍了各个系统如何安装和使用neofetch： 安装Neofetch Windows 在 Windows 系统上，可以通过在Powershell中可运行的包管理器 scoop 或者 choco 来安装 neofetch。 使用 Scoop： 确保已安装 Scoop（未安装请参考 Scoop 的安装指引 Quickstart片段）。 打开 PowerShell 或命令提示符，运行： scoop install neofetch 安装完成后，运行 neofetch。 使用 Chocolatey： :::warn 替代软件 在Chocolatey的默认源中，笔者没能找到neofetch，但类似的工具winfetch是可用的。 ::: 确保已安装 Chocolatey（未安装请参考 Chocolatey 的安装指引 ，运行第二步中可以复制并在Powershell中执行的命令）。 打开 PowerShell 或命令提示符（以管理员身份运行），执行： choco install winfetch 安装完成后，运行 winfetch。 macOS 在 macOS 上，可以通过 Homebrew 包管理器安装 neofetch。 使用 Homebrew： 确保已安装 Homebrew（未安装请参考 Homebrew安装指引）。 打开终端，执行以下命令安装 neofetch： brew install neofetch 安装完成后，运行 neofetch。 Linux 在 Linux 系统上，neofetch 通常可以通过系统的包管理器直接安装。以下是基于不同包管理器的安装步骤： 使用 pacman（Arch Linux 及其衍生发行版，如 Manjaro）： 打开终端，运行以下命令： sudo pacman -S neofetch 安装完成后，运行 neofetch。 使用 apt（Debian、Ubuntu 及其衍生发行版，如 Linux Mint）： 打开终端，运行以下命令： sudo apt update sudo apt install neofetch 安装完成后，运行 neofetch。 使用 dnf（Fedora 及其衍生发行版，如 RHEL 和 CentOS Stream）： 打开终端，运行以下命令： sudo dnf install neofetch 安装完成后，运行 neofetch。 使用Neofetch 运行neofetch命令后，应该会在终端里打印出这样的内容： 要确认系统版本和CPU架构，只需要看OS那一行即可。一般而言，那里会有两个部分表示本文中涉及的关键信息。请根据文末的一般词对照表来分析。 一般词对照表 类型 可能出现的词 解释 系统类型/系统名称/系统版本 Windows，Windows NT，NT (Windows); macOS，OS X，Mac OS X (macOS); Fedora，Ubuntu，Linux，Manjaro，Arch (Linux); 目前主流操作系统基本就是这三类。 Linux用户一般不会不知道自己的系统信息 （除非使用的是单位发的国产电脑—— 目前我们的产品基本未验证其兼容性。以及其他的边缘情况。） 系统版本往往作为数字出现在系统名称后面。 系统架构/CPU架构/指令集 x86_64，x86，64-bit，amd64，arm64，ARM，armv8，aarch (或类似形式的词) 如果你在设备上看到 x86_64、64-bit 或 amd64， 这些通常表示你的操作系统是 64 位的，或者你的 CPU 使用 64 位架构。我们通常将这一架构简称为 x64。 相对地，如果你看到的是 x32 或 x86，则表示设备使用的是 32 位架构。 需要注意的是，我们的软件通常 不再支持任何32位架构。除此之外的情况除非有特殊说明否则均不保证兼容。 CPU类型或CPU型号 Apple Silicon，M1，M1 Ultra，Snapdragon (ARM处理器); Ryzen，CORE，..。(现代常见x64处理器系列); 如果你看到的是 arm64（请注意，这与 amd64 完全不同，千万不要混淆！），或者单独出现了 ARM、aarch，亦或包含了这些词汇，则通常表示你的 CPU 是基于 ARM 架构 的。近年来，许多使用 ARM 处理器的设备（例如部分笔记本电脑或移动设备）都采用了 arm64 架构。"
  },
  "temp/docs-main/zhCN/guide/general/contribute-to-i18n.html": {
    "href": "temp/docs-main/zhCN/guide/general/contribute-to-i18n.html",
    "title": "提交本地化翻译贡献 | Qomicex.Core API文档",
    "summary": "提交本地化翻译贡献 ::: tip 感谢您的无私工作！ 本文将以LauncherX i18n提交为例，通过 Github Desktop 提交贡献内容。 简而述之，大体的步骤为：确认提交贡献的项目仓库-fork-提交修改-提交Pull Request-等待合并 ::: [[toc]] 准备工作 ::: info 先决条件 您持有一个Github账户， 且具备连接到Github的方法与能力 您当然可以是个Git新手。或许您可以去查看：协作处理拉取请求 - GitHub 文档 来了解一般的工作模式 您下载了Github Desktop并且在上面登陆了您的Github账户 ::: 与其他我们公开征集贡献的仓库一样，您需要先登陆好您的Github账户，然后打开Corona-Studio/LauncherX-i18n: The i18n project for LauncherX (github.com)，找到【fork】按键，点击它。 接下来可以按照默认的设置，直接点击【Create Fork】进行下一步。一切正常的话，您此时应该会被导航到您名下的fork仓库。您的提交都需要先暂存在这里。 开始操作 1) 提交到名下的fork 在您名下的fork仓库页面，点击【Code】按钮，它一般具有特别的颜色 点击【Open in Github Desktop】。如果浏览器询问您是否允许此网站打开Github Desktop，请允许 确保连接可用性，然后在您方便使用的路径下，点击【Clone】然后等待完成 完成后，您可以通过诸如Visual Studio Code之类的编辑器进行编辑。变更产生后，您将可以将内容提交到您的fork仓库。 左侧您可以看到作出更改的文件，左下方的第一个输入框是必填的，这里概述您此次提交做了什么；而第二个可用于对第一个输入框的补充说明。完成了这方面的填写，即可点击下方的【Commit to xxx】提交更改。 此时，如图中显示为 “Pull origin” 的按钮处会变为 “Push origin”，点击它将可以把本地仓库的变更同步到Github上托管的您名下的fork仓库。 2) 将名下的fork仓库内容提交到我们的上游仓库 在您的变更提交到您名下的fork仓库之后，还没完： 打开我们的上游仓库（在您名下的仓库会显示 “forked from xxx”，点击这个链接可以前往我们的上游仓库） 点击【Pull Requests】（这个按钮和Code、Issues等标签类按钮同级） 点击【New pull request】 点击【compare across forks】 点击切换【head repository: 】中的内容，切换到您名下的fork仓库，然后点击【Create pull request】 填写简要的说明[1]和详细的说明[2]（如有必要），然后点击【Create pull request】 等待我们进行审核、编辑和合并即可！在通过之后，您会收到邮件提醒（取决于您的Github设置） 3) 同步我们的上游仓库 我们的上游仓库时不时会有内容更新，这可能来自管理员，也可能来自其他贡献者。 a) 同步仓库 在浏览器中打开您名下的fork仓库 点击Sync with upstream（或其他文字链接，类似于此） 请注意：这可能导致您的未提交修改内容丢失。但是好在Git会保存您的历史记录。 在Github Desktop中，点击Fetch Origin以从Github获取仓库最新信息。如果有更新变更，此处会变为【Pull origin】按钮可供点击。 点击【Pull origin】以将仓库的新变更拉取到本地。 b) 处理冲突 来自各方的修改都可能引发冲突，即便绝大多数情况下冲突都由我们来辨识和处理解决。但是当您遇到冲突，请按照Github Desktop的提示和冲突检查器找到冲突的行。一般而言，冲突与原文可能以以下格式展示： >>>>>>>> 冲突，来自上游 ======== 原文，您的内容 <<<<<<<< // 请以实际情况为准 您需要自行确认哪些内容是您需要保留的。将不需要的内容包括冲突标识符（）一并删除后，在Github Desktop中mark as resolved（或等待它自行检查） 参考文章：在 GitHub 上解决合并冲突 - GitHub 文档 跋&注意事项 测试您的语言文档，参见：我想贡献多语言了！ | 日冕知识库 您可能在此期间遇到各种问题。欢迎来到我们任何一个交流群中就您遇到的问题提问，但是我们更希望您可以自己先去使用搜索引擎或聚合类AI查询相关的解决方法。 ::: warning 不要修改别人的内容 您应该专心于自己主要贡献的部分。如果您认为其他人的什么地方写的有问题，可以先通过issue提交您的意见和建议。 :::"
  },
  "temp/docs-main/zhCN/guide/general/donate.html": {
    "href": "temp/docs-main/zhCN/guide/general/donate.html",
    "title": "赞助我们！ | Qomicex.Core API文档",
    "summary": "赞助我们！ ::: info 本文包含一张白色居多的图片 如果您正在低环境光环境下使用本站的深色模式阅览，请做好准备。 ::: ::: tip 就像街头艺人？ 我们是一个用爱发电的组织，我们免费提供的软件离不开精神、更离不开物质上的支持。本文将介绍如何用最直接的方式向我们提供经济方面的物质支持。对于我们来说，哪怕是一次小小的赞助，都会被我们长久铭记。 如果您是未成年人，请不要继续阅读此文章或尝试给我们打赏赞助。 ::: 如前文所说，我们是一个用爱发电的组织，通过爱发电订单号，我们将得以把您和您的日冕账户（CSA）相绑定，并以此给您提供赞助者标识，授权您接受更敏捷、更快速相应的LauncherX测试版更新通道 等服务或权限。若您注销并删除CSA账户，该赞助记录也将失效并不再可用。向我们提交爱发电订单号将额外提供此订单号相关的有效性信息，这些信息仅用于验证，使用过程遵守爱发电使用条款，且与支付相关的纠纷处理应与爱发电进行交涉。 赞助和绑定订单记录的方法如下： 打开日冕工作室官网的赞助页面。如果没有登录，请登录；如果登录后没有跳转到赞助页面，可以回来再点一次这个链接或通过用户中心的【赞助】按钮。 点击下方卡片【前往爱发电赞助我们】的【前往】按钮以打开我们的爱发电页面。 任意选择一个金额和周期，完成支付。 成功支付后，回到您的爱发电的【管理】页面，在【订单-已支付】一栏可以找到最近的发电支付记录。找到最新的、被赞助人为【老腊肉】的卡片或条目，在靠下的地方可以找到【订单号】，其后有一个可供点击的【复制】文字按钮，点击以复制整个订单号。 如图所示： 回到我们的官网赞助页面，将刚才复制的订单号粘贴到输入框中并提交。 成功后将会有绿色框提示成功绑定，此时您就是我们的 “荣誉股东” 了！ 如果期间遇到问题（比如，自己的订单号被绑定），请联系我们，我们可能会需要您提供一些信息和/或通过更多渠道来帮助我们核实信息，比如： 您的日冕账户注册邮箱 包含订单号的订单记录截图 我们会保护您的隐私，但是请仅在我们向您索要的时候再提供对应的信息。 ::: warning 谨防诈骗 我们不会主动联系您来进行退款等操作。如果有人主动以相关理由与您联系，为确保安全，您可以通过爱发电站内私信功能等与我们核实。 ::: 双关了，欸嘿"
  },
  "temp/docs-main/zhCN/guide/general/index.html": {
    "href": "temp/docs-main/zhCN/guide/general/index.html",
    "title": "综合操作指导 | Qomicex.Core API文档",
    "summary": "综合操作指导 这里放了一些与我们工作室强相关的指导性文本，旨在介绍部分工作的一般操作流程等内容。"
  },
  "temp/docs-main/zhCN/guide/index.html": {
    "href": "temp/docs-main/zhCN/guide/index.html",
    "title": "欢迎来到日冕知识库（CSKB） | Qomicex.Core API文档",
    "summary": "欢迎来到日冕知识库（CSKB） 在这里您可以查阅到日冕工作室所属项目的部分技术文档、疑难解答，以及 Minecraft 相关的各种技术规范和样例"
  },
  "temp/docs-main/zhCN/guide/joinus.html": {
    "href": "temp/docs-main/zhCN/guide/joinus.html",
    "title": "加入我们吧! | Qomicex.Core API文档",
    "summary": "加入我们吧! ::: info 此招募文档描述了目前我们需要的人手类型和其他您可能想知道的东西。 更新日期: 2024/4/3 审核群号: 1040526762 审核规则见下页。(#) ::: 加入后可以得到什么… 首先，权利与义务是对等的。您若想享受加入后的权利，除了需要证明您有实力， 也需要履行作为成员的义务，才可以享受作为成员的对应权利。 加入我们后，您可以: 如果您参与开发工作，您将会： 获取源码控制的较高权限，按需访问团队在数年间积累下来的源代码和工具链。 有机会调用团队资源。 如果您参与游戏相关工作（如CMF群组服）、 和开发的工作（如质量控制），您将能够： 锻炼有关方面的能力，并积累实战经验。 不论如何，您都可以： 与组内菊苣深入交流，获得一些人生经验。 扩展人脉关系。 锻炼团队合作能力，提升团队合作意识。 在Minecraft社区中拥有获得认可的头街。 团队现在有什么需求? 自带项目的大佬： 我们欢迎任何人自带项目入群。如果您有一个想法却因没有人手或平台难以实现，那么加入我们吧！ C#、Avalonia开发： 熟悉C#的各类语法，对AvaloniaUI（至少WPF）以及MVVM有比较深刻的理解。对设计模式、算法优化、HTTP请求方面有开发经验。 Minecraft服务器相关人员： 包括服务器技术和建筑师等。对于运维人员，最好有Linux发行版系统终端的使用经验。 文职人员： 负责团队外宣、法律顾问等相关事宜，或对RPG服务器的故事编排为剧情，总之是偏向文科的文字工作。 美工，CG： 参与UI的设计和外宣图片等的绘制。CG人员主要负责服务器宣传片制作以及建筑渲染。如果有 Minecraft皮肤和材质等绘制能力那么也欢迎！ 吉祥物： 不需要什么技能，只要进管理群说说话就好。（如果可以的话，希望能够主动晋升为文职人员，或承担公众社交管理员的工作！） 如今的吉祥物必须承担社区管理工作或宣传工作。散发你的个人魅力，营造更有活力、更加健康的社区氛围！ 值得注意的是，我们并不要求在任何一方面拥有实战经验。本工作室提倡终身学习的精神，也希望成为一个实践的平台。 我可以! 如何加入? 首先，很高兴您能有与我们同行的自信！接下来您需要： 加入团队的审核群（企鹅：1040526762）并且注明您的意向。 根据群文件审核规则展示自己的能力，并接受团队成员提问。 等待团队成员讨论后向您发送通知。 搞定！流程大约时长：20min左右。 （内部人员人事处理可能耗时更久，我们的成员之间可能存在时差。） 其他信息… 其他常见问题，您或许会关心的。 Q：我会因为年龄、性别等原因受歧视吗？ A：当然不会！我们希望建立一个包容而有活力的群体，这也是我们没有年龄等自身因素限制的原因。 Q：我能从中获得经济利益吗？ A：如果您参与的项目有盈利性质，那么团队内部将按照贡献程度进行分成。 Q：如果我因为学业（中考、高考等）而不得不脱离团队工作，会被踢出吗？ A：当然不会。我们的理念之一就是终身学习，而学习的重中之重就是要以学校教学为先， 所以只要您在不得不脱离之前告知管理员即可，我们会为您留一年时间：若超过一年期限且没有返回报到，您或许会被要求停职并重新审核。您总共可以延长报到时限3次。 请注意，为了团队工作进度，在您告离期间，除了您领导的项目，我们会尝试让其他人接手您未完成的工作，直到您回来。 此外，我们希望您尽可能每日都能参与工作。但是如果受限于学业安排导致一周或一个月内能参与的时间有限 (且比较规律)，您完全只需要让我们知道一下，并且不需要暂停职位。具体安排需要视具体情况而定。"
  },
  "temp/docs-main/zhCN/guide/links.html": {
    "href": "temp/docs-main/zhCN/guide/links.html",
    "title": "友情链接… | Qomicex.Core API文档",
    "summary": "友情链接… import RelatedLink from './../../.vitepress/theme/RelatedLink.vue'; import {FriendLinks, Sponsors} from './../../.vitepress/friendLinks.ts'; 友链！ 此处展示的友情链接仅限同类的知识共享型站点。与此同时，还包含了一些参考较多的文档站（可能是单向友链） 如果你认为你的站点是与我们并肩的好伙伴，欢迎与我们交换友链！查看我们的联系方式 标注 * 的是单向，标注 ^ 的是因为各种特殊情况导致的暂时单向。 赞助商 这里列举大力赞助我们的好心人，他们有自己的生意。 如何在这里展示？ 首先当然是联系我们！ 然后，说明来意： 想要和 CSKB/官网 交换友链？让我们确认一下！只要我们互相是志同道合的，那么我们就可以交换友链。 希望长期向我们提供赞助？太好了！感谢您的物质支持，只要是我们受得起的长期赞助，我们当然乐意照单全收（被打） 然后请等待在下一次网站更新，只有在确认通过后的下一次网站更新才会将我们珍贵的「合作者信息」登上相应的页面。"
  },
  "temp/docs-main/zhCN/guide/standard/cmfs-stable-test-general-standard.html": {
    "href": "temp/docs-main/zhCN/guide/standard/cmfs-stable-test-general-standard.html",
    "title": "| Qomicex.Core API文档",
    "summary": "暂未编写"
  },
  "temp/docs-main/zhCN/guide/standard/code-of-open-groups.html": {
    "href": "temp/docs-main/zhCN/guide/standard/code-of-open-groups.html",
    "title": "Corona Studio公开交流群管理规定和条款 | Qomicex.Core API文档",
    "summary": "Corona Studio公开交流群管理规定和条款 违反本条款的行为将按情节予以“移出群聊”，“禁言”或”警告“处理，请全体成员遵守 原则： 警告制度 管理员除非遇到下文【严重行为】中描述的特别恶劣的情况可以立即适量执行之外，均采用“不再三”原则，即：【违反群规会被先警告，警告满第三次时由当时发出警告的管理员适量施加处罚，但事实违规情节严重者可不视警告次数直接执行】 管理员须在警告时适当保留证据 管理员自行决定是否警告并撤回信息 处罚涵盖 所有处罚手段允许数罪并罚 口头警告。用于制止可能存在的违规 警告。用于事实上的违规，但是违规群员的发言影响没必要被撤回。使用机器人计数 正式警告。用于事实上的违规，并且需要消除影响。使用机器人计数 禁言。需要在禁言前进行警告，使用机器人计数，并在警告后立刻禁言。实际禁言时长可以按影响程度、累计警告次数等因素而定，但是若群员违反的规则有定义最短时长，则必须长于该规定时长 移出群聊。原则上，仅在积累第二次“三次警告”（即警告积累6次）才可能移出群聊。具体视实际违反的规定而定。 移出群聊并全线拉黑。被如此处罚的人将无法加入任何日冕公开群聊。目前仅老腊肉和法棍有权执行 反对条款 管理员若发现有劣迹斑斑的人加入群聊，可以在群内列出该人的行为记录，然后由3名或以上的管理员讨论去留 一、严重行为（可被移出群聊） 违法行为 传播违法信息（政治敏感、暴力色情、诈骗赌博等） 讨论可能违法的敏感技术 传播病毒、钓鱼链接或血腥惊悚内容 严重涉黄行为 其他违反公序良俗行为 骚扰行为和破坏秩序 无故频繁@或戳戳他人或频繁给消息贴表情的 发布无关广告/引流信息 私下骚扰成员（经管理员观察确认或投诉核实） 未经允许拉其他群成员进入私人团体或长期骚扰群友 冒充他人发表言论 故意引战、煽动对立、寻衅滋事 顶撞、辱骂管理员或拒不配合处理，不知错不知改的 抹黑工作室劳动成果的 二、应禁言处理的行为 不当言论 无礼争执持续超5分钟（禁言12小时） 人身攻击/歧视/侮辱（禁言24小时） 刷屏式倾倒负能量（禁言1小时） （我们理解您想要发泄您自己的情绪，但是请不要在公共的网络空间内随意倾泻） 刷屏与滥用 表情刷屏（5个及以上）： 警告满后加禁言12小时及以上，情节极其严重者移出 恶意发许多未经脑子思考的无意义内容：禁言1天 管理员索取解决错误的线索但是超6小时未回复的（例外和详细条款见通用条款）：禁言一个月 广告违规 广告推广：警告满后撤回并禁言1-3天，情节特别严重者移出群聊 （日冕工作室成员及日冕工作室合作方发布的除外） 任何涉及其他不相关启动器或MC服务器的言论（除非由管理员或确认的日冕成员发起。对其他启动器的吹捧和诋毁均算在此类。）：禁言10分钟 附录：相关启动器：Fluent Launcher，Minecraft Launcher(官方)，XMCL， 一些广为人知的MC服务器不在此条限制范围内。比如：Hypixel 三、通用条款 进入本群我们即默认视为您已看过且同意本群管理条款，修订后以群公告为准 管理员有权依规灵活处置 对处理有异议者，须私聊群主或者指定管理员申诉，禁止群内争执 未列明但严重破坏群秩序的行为，管理员有权进行处置 若您提出有问题，但在6小时内未提供解决错误的信息，我们将给予一次警告处分 （若因为意外，比如返校、收手机等，则必须事先说明） 在群里提出问题前请您先查询日冕知识库 本文解释权归日冕工作室全体成员所有 管理员无义务处理当前群所相关问题之外的问题。请您在询问问题时提供必要的日志和信息等线索，并且配合有意帮助的群成员或管理员的线索要求。 一些简单的使用方法请您先前往CSKB查找，只有在无法访问/对应文档无效/无对应文档才能就功能相关的问题提问。 请共同维护友善，和谐，包容的社区环境。 简化版：适用于群规 简而言之，违规按情节处罚：警告/禁言/移出群聊。 一、核心原则 三次警告原则：违规先警告，满3次后处罚（情节严重者直接处罚） 处罚类型：警告（含口头/正式警告，机器人计数）、禁言（需先警告，时长≥规则下限）、移出群聊（警告累计6次或触犯红线）、全线拉黑 管理员有权：灵活处置、撤回消息、处理未列明但破坏秩序的行为 二、严重行为（可立即移出群聊） 违法内容：敏感政治、暴力色情、诈骗赌博、病毒/钓鱼链接、违反公序良俗 严重破坏：骚扰成员、广告引流、冒充他人、煽动对立、寻衅滋事 抗拒管理：辱骂管理员、拒不认错、抹黑工作室成果 三、禁言行为（附最低时长） 不当言论：人身攻击（24h）、无礼争执（12h）、刷屏负能量（1h） 刷屏滥用：表情刷屏（≥12h）、无意义刷屏（1天）、超6小时未回复线索（1个月） 违规广告：非合作方推广（1-3天），提及无关启动器/服务器（10分钟） （知名服务器和以下启动器：XMCL、Fluent Launcher 除外） 四、通用条款 进群即视为同意本规，修订以公告为准 申诉需私聊管理员，禁止群内争执 提问前：先查日冕知识库（CSKB），提问需提供必要日志线索 管理员仅处理当前群相关问题，无义务解答其他 请共同维护友善、和谐、包容的社区环境！（解释权归日冕工作室所有） 简化版 - 纯文字 简而言之，违规按情节处罚：警告/禁言/移出群聊 一、核心原则 1. 三次警告原则：违规先警告，满3次处罚（情节严重直接处罚） 2. 处罚类型：警告（含口头/正式警告，机器人计数）、禁言（需先警告，时长≥规则下限）、移出群聊（警告累计6次或触犯红线）、全线拉黑 3. 管理员有权：灵活处置、撤回消息、处理未列明但破坏秩序的行为 二、严重行为（可立即移出群聊） 1. 违法内容：敏感政治、暴力色情、诈骗赌博、病毒/钓鱼链接、违反公序良俗 2. 严重破坏：骚扰成员、广告引流、冒充他人、煽动对立、寻衅滋事 3. 抗拒管理：辱骂管理员、拒不认错、抹黑工作室成果 三、禁言行为（附最低时长） - 不当言论：人身攻击（24h）、无礼争执（12h）、刷屏负能量（1h） - 刷屏滥用：表情刷屏（≥12h）、无意义刷屏（1天）、超6小时未回复线索（1个月，特殊情况除外） - 违规广告：非合作方推广（1-3天），提及无关启动器/服务器（10分钟）（知名服务器和以下启动器：XMCL、Fluent Launcher 除外） 四、通用条款 1. 进群即视为同意本规，修订以公告为准 2. 申诉需私聊管理员，禁止群内争执 3. 提问前：先查日冕知识库（CSKB），提问需提供必要日志线索。管理员仅有义务处理当前群相关问题。 详见CSKB《标准和规则》，解释权归日冕工作室所有"
  },
  "temp/docs-main/zhCN/guide/standard/cskb-formula.html": {
    "href": "temp/docs-main/zhCN/guide/standard/cskb-formula.html",
    "title": "单元组件 | Qomicex.Core API文档",
    "summary": "@useFixer 单元组件 这里存放可以直接复制以供复用的组件。建议编辑人员遵守格式使用。 请尽可能跟随统一的全站风格！ 相关阅读：Markdown Extensions | VitePress [[toc]] 版权声明 ::: warning 我们对CSKB内容版权的管理 无论是转载还是原创，引起的版权纠纷均由该文章的上传者承担。 此外，如果引用内容受到跨域访问阻止，请自行解决。 ::: 转载他人文章 如果转载他人撰写的、并非首发于CSKB的文章，必须 在开头一级标题后附上此段。 模板中存在可选的内容。使用时，在可选段中 至少选择一个 并删除表示可选的?问号。 :::warning 转载文章 本文是转载文章，<修改状态>。如果你觉得这篇文章不错并想要引用或转载，请根据这些信息联系原作者。 原作者：作者在原文的署名 引用链接?：页面标题 引用文章?：<参考文献格式的简短信息> 许可证：<许可证> 转载信息上次更新于 <日期> ::: 解释： 修改状态：依据许可，在这里解释转载的文章未修改、有少量修改、有补充和修改。如果有修改或补充，建议将那一部分标记出来。 引用链接和引用文章：如果有引用链接，可以不写引用文章；如果有引用文章，引用链接可以不写，也可以标注原文所在书本的官方购买链接（非购物平台）、版权页面（实在没有就不写） 参考文献格式的简短信息：见引用内容和参考文献。 许可证：允许的许可证有多种 口头许可： 公开口头许可：如果原文页面存在评论区，可以在评论区询问作者是否允许搬运到CSKB，你必须说明你要搬运到CSKB，例如： 你好！这篇文章很棒，我能将它搬运/转载到知识库网站kb.corona.studio吗？ 在搬运的时候，要按照作者的要求进行搬运。此类许可证可以不标注在转载信息中。 非公开口头许可：请求许可的过程与公开口头许可一致，只是转为通过私信原作者、给原作者发邮件来进行沟通。请保存好这类许可的原本证据。在许可证这一栏应填写指向许可截图的链接。 公共许可证：无论是CC系列的共享许可证还是其他什么许可证，只需要在这里写明许可证的名称。当然也可以把许可证的公开链接附在名称上。 购买许可：请向原作者索取许可凭证，按需插入链接指向凭证链接或凭证的截图。可以参考上文中【口头许可-非公开口头许可】的方式。 日期：成文的日期。你的实际文章公开时间是可查询的，因为CSKB合并分支的时候会留下记录。 非成员的作者声明 如果提交文章者并非Corona Studio的成员，首先，非常感谢您的无私贡献！但是我们建议您额外进行一些操作以保护您的权利，比如在一级标题后添加以下内容作为版权声明。 如果您是从其他平台复制了这篇文章到CSKB，那么这段声明也适用。但是如果这篇文章并非您原创，而您却添加了这段标记，那么我们将会讨论对您的惩罚。请确保这篇文章为您的原创，并且妥善处理了一些可能引起版权纠纷的内容。 ::: info 原创文章 这篇文章由 <作者名称> 原创。<联系方式> 许可证：<许可证> 成文于：<日期> <其他内容> ::: 解释： 作者名称：您活跃在圈子里用的昵称，或者其他能代表您本人的名字。 联系方式：可选，如果您希望读者能与您联系，请在这里留下合适的联系方式，您当然可以选择不填。 许可证：您可以选择在这里填入CC系列共享许可证，或是其他能指向许可证的链接，或是禁止转载、未经许可禁止转载这类文字声明。 日期：写完这篇文章时候的日期 。 其他内容：可以在这里写一些其他补充文本。建议不多于100字。 警告 未能及时更新内容 如果对应的软件服务发生了更迭但是文章内对应的信息并未来得及修改，可以添加这个标记以警告读者。 ::: danger 内容过时 本文内涉及到的部分信息过时，可能与最新的情况不符。 <在这里可以写涉及的内容是哪些，或是一个文章内子标题列表> ::: 内容施工中 如果规划了一整篇文章但是碍于各种原因需要在部分内容未完成的情况下立刻部署提交大部分文章，务必添加类似如下的提示： ::: info WIP 内容施工中。 ::: 内容准确性存疑 如果认为文章内存在未被核实的内容或不确定的言论，可以在文章的 开头一级标题后 和 文章中任意位置 添加这个标记。 ::: warning 存疑 部分内容真实性或准确性存疑，但是为了表述文本，仍然展示了存疑的内容。 <有必要的话可以写免责声明> <这里可以将存疑的部分和疑点写下> ::: details 疑点 <如果内容太长可以写在折叠框里> ::: 引用、更新与勘误记录 此类记录类文本可以直接使用无序列表置于文末。如果太长，可以使用details块来收折。这里的内容仅供参考，你可以按照 “太长就收折，一个也不能少” 的原则自由发挥。 引用内容和参考文献 写在列表里的参考文献信息必然不能像写json似的写得很详细，所以建议使用这样的格式一行写完。 ::: warning Oops！ 由于在统一全站的句号和逗号期间半角逗号加空格的组合被替换为了全角逗号，请在书写参考文献内容时依照语言使用对应的标点符号。 ::: 文章，书名，作者，出版社（或平台），年份（或版次） 比如： Программирование на MySQL，«Программирование на MySQL»，Алексей Калинин，ДМК Пресс，2020 对于一段三行的引用列表，可以这样写： 【参考文献 二级标题】 Database Normalization Description，Microsoft Learn: Microsoft 365 troubleshooting by helenclu，simonxjx，venusmi，dariomws，MaryQiu1987; Microsoft，06.06.2024 (u) Программирование на MySQL，«Программирование на MySQL»，Алексей Калинин，ДМК Пресс，2020 MySQL数据库入门，《Introducing MySQL Database》by 传智播客，清华大学出版社，01.03.2015 也可以这样写： :::tip 参考文献 Database Normalization Description，Microsoft Learn: Microsoft 365 troubleshooting by helenclu，simonxjx，venusmi，dariomws，MaryQiu1987; Microsoft，06.06.2024 (u) Программирование на MySQL，«Программирование на MySQL»，Алексей Калинин，ДМК Пресс，2020 MySQL数据库入门，《Introducing MySQL Database》by 传智播客，清华大学出版社，01.03.2015 ::: 更新记录 如果一篇文章需要记录每一次更新的内容，建议将其收折。 比如： ::: details 更新记录 2025年1月14日：更新内容需要简短 2025年5月14日：也可以在更新内容中加入链接 2025年8月10日：用于指向CSKB分支的提交记录 ::: 勘误 勘误同样建议收折，但是如果前期内容很少，可以暂时不收折。 比如： ::: details 勘误 codingEric 提出了在 标题 处关于xxx的错误 Feiron Iguista 提出了关于别的内容的错误 …… 感谢以上热心市民！ ::: 其他 为一个段落启用段前缩进 ::: danger 老腊肉不喜欢 由于老腊肉不喜欢段前缩进，所以不要滥用。 目前根据我们的规则，只有简体中文、繁体中文、日语、朝鲜语是有资格启用段前缩进的。 启用段前缩进，需要满足以下条件： ::: details 启用条件 只能出现在教程类文档中，或前后文段密集、无法分割、长度较长并且与标题粘合紧密。 在上下文中，只能依靠段前缩进平衡视觉感。 在版面中需要通过段前缩进来整合视觉条理。 在vitepress中，受制于布局和版面设计，为很短小的文段（大多数情况下不能占满一行的那种）启用段前缩进将会很丑。请在尝试使用后通过热重载预览来进行参考和比对，最终在提交前确认是否要启用。 必须是使用中文汉字、日文、朝鲜文这类语言文字的文档中才能启用。 ::: 如果要给个别段落启用段前缩进，首先要在文章上启用扩展功能。 在文档的最开头处添加：`@useFixer\\`（`@useFixer`）即可启用扩展。 然后，你需要在此文章内的段落的末尾添加一个任意内容的code块，比如： `@useFixer` 这只是一个很短的段落而已，对于它而言不需要段首缩进。但是如果整个段落很长很长很长的话，或许为了视觉友好考虑，或是为了规整文字的调性、平衡视觉，我们可以启用这样的段前缩进。只需要注意，保证`code`块处于末尾，这样的话它会隐藏，而段首的缩进就会出现。`i` 它的效果如下： 这只是一个很短的段落而已，对于它而言不需要段首缩进。但是如果整个段落很长很长很长的话，或许为了视觉友好考虑，或是为了规整文字的调性、平衡视觉，我们可以启用这样的段前缩进。只需要注意，保证code块处于末尾，这样的话它会隐藏，而段首的缩进就会出现。i 但是如果在这个code块后有其他文本内容，取消缩进将失效。比如： `@useFixer` 这只是一个很短的段落而已，对于它而言不需要段首缩进。但是如果整个段落很长很长很长的话，或许为了视觉友好考虑，或是为了规整文字的调性、平衡视觉，我们可以启用这样的段前缩进。只需要注意，保证`code`块处于末尾，这样的话它会隐藏，而段首的缩进就会出现。我们建议使用`i`作为标准的启用标签，这很合适，难道不是吗？ 它的效果如下： 这只是一个很短的段落而已，对于它而言不需要段首缩进。但是如果整个段落很长很长很长的话，或许为了视觉友好考虑，或是为了规整文字的调性、平衡视觉，我们可以启用这样的段前缩进。只需要注意，保证code块处于末尾，这样的话它会隐藏，而段首的缩进就会出现。我们建议使用i作为标准的启用标签，这很合适，难道不是吗？ 这意味着，正常的段落包含code块将不受影响。如果段末实在需要保留code块，请在段末添加一个标点符号。 ::: warning 即便如此… 为了方便排查问题，尤其是在使用实时渲染编辑器的情况下（比如Typora），尽管任意段落末尾的code块都会被视作启用此段的缩进，也请遵循语义化规范在块内书写类似于make-indent/indent/i这样的内容，便于辨别，而不要使用空格：在实时渲染编辑器中仅空格的code块可能难以辨认。 :::"
  },
  "temp/docs-main/zhCN/guide/standard/index.html": {
    "href": "temp/docs-main/zhCN/guide/standard/index.html",
    "title": "标准说明文档 | Qomicex.Core API文档",
    "summary": "标准说明文档 这里保存着公开的日冕产品测试标准等标准的说明文档."
  },
  "temp/docs-main/zhCN/guide/standard/lx-stable-test-standard.html": {
    "href": "temp/docs-main/zhCN/guide/standard/lx-stable-test-standard.html",
    "title": "LauncherX 稳定版构建许可测试标准 | Qomicex.Core API文档",
    "summary": "LauncherX 稳定版构建许可测试标准 为了确保稳定版和公众测试版的基本稳定性，制定此标准。在从上游构建分支向下合并时，最新的上游构建需要经过人为的此测试流程，并且满足此测试要求，方允许向下手动合并. 测试流程 在每月下旬，合并Higgs到Neutrino，以供在Neutrino开始评估版本。这是为了不影响Higgs分支的主线开发进程. 测试员需要在所有支持的操作系统平台上执行测试。为了确保基本可用性，在不同的操作系统需要作出不同的环境控制. Windows: 如果系统环境是测试员的日常工作环境，为了避免受到工作环境的影响，建议测试员开启新的Windows沙盒实例进行测试. macOS: 如果系统环境是测试员的日常工作环境，为了避免受到工作环境的影响，可以创建专用于测试的虚拟机，或新建用户账户来隔离测试环境. Linux: 建议测试员使用虚拟机准备测试环境。若有可能，应该创建全新的虚拟机。测试需要涵盖Ubuntu系列和Fedora系列，Arch系列可选. 从初次设置开始，对崭新启动的LauncherX进行功能测试。具体测试内容如下: 测试内容 从初次设置到启动器设置到具体游戏设置，按钮、输入框等需要依次测试并判断启动器行为是否符合预期. 测试个性化外观选项是否符合预期 测试游戏下载、安装、带游戏模组加载器的版本是否能正常安装 游戏是否能正常补全，补全游戏是否能正常启动 导入导出整合包是否正常工作 尝试触发崩溃，崩溃分析器和支持包生成是否正常工作 预期结果 所有输入框在编辑、清空、输入非预期内容后均不会导致启动器崩溃，所有按钮都可以正常唤起功能方法且不会引发崩溃 外观符合文字介绍的预期 游戏能正常下载安装 游戏能正常补全和启动 所有支持的整合包均正常可以导出和导入，导出的完整包内容可用 崩溃分析器按预期触发，支持包内容完整可用. 后续 以上测试内容全部通过，代表这个Neutrino版本可以向下合并到Proton，然后在每月(或每两个月)固定日期推送到Stable。一个阶段的稳定版审核通过，宣发人员开始在各平台更新启动器内容更新日志."
  },
  "temp/docs-main/zhCN/guide/team.html": {
    "href": "temp/docs-main/zhCN/guide/team.html",
    "title": "| Qomicex.Core API文档",
    "summary": "import { VPTeamPage, VPTeamPageTitle, VPTeamMembers } from 'vitepress/theme'; const members = [ { avatar: 'https://www.github.com/laolarou726.png', name: '老腊肉', title: '创建者', links: [ { icon: 'github', link: 'https://github.com/laolarou726' } ] }, { avatar: 'https://github.com/CodingEric.png', name: 'CodingEric', title: 'UI / UX', links: [ { icon: 'github', link: 'https://github.com/CodingEric' } ] }, { avatar: 'https://github.com/leon-o.png', name: 'Leon', title: 'UI、后端服务、运维', links: [ { icon: 'github', link: 'https://github.com/leon-o' } ] }, { avatar: 'https://github.com/komorebi64.png', name: 'Croteco', title: '后端服务、运维', links: [ { icon: 'github', link: 'https://github.com/komorebi64' } ] }, { avatar: 'https://github.com/fr1g.png', name: '法棍', title: '前端、MC 服务器运维', links: [ { icon: 'github', link: 'https://github.com/fr1g' } ] } ]; 我们的团队 Corona Studio（日冕工作室）是以 Minecraft 游戏第三方服务为业务核心的、由专业人士和爱好者组成的团队，前身是 CMFL 启动器开发组。"
  },
  "temp/docs-main/zhCN/index.html": {
    "href": "temp/docs-main/zhCN/index.html",
    "title": "| Qomicex.Core API文档",
    "summary": "其他Corona Studio链接 Corona Studio官网 Corona Studio MIN 查看友链 \uE724"
  },
  "temp/docs-main/zhCN/lxguide/faq.html": {
    "href": "temp/docs-main/zhCN/lxguide/faq.html",
    "title": "常见问题 | Qomicex.Core API文档",
    "summary": "常见问题 本文初次编成于 2025年8月10日。挺臭的说是。 [[toc]] 前言 如果遇到问题，日志将是确认问题的绝佳线索。这些CSKB链接将会让你知道如何搜集这些线索。 LauncherX本体相关问题：好好利用日志文件! | 日冕知识库 游戏异常启动问题：测试启动 | 日冕知识库 反馈问题，参见：报告异常&建言新策 | 日冕知识库。 附加日志的时候，可以在Github Issue中直接粘贴为代码块，或是使用mclo.gs来提供错误日志！ 运行相关 无法打开启动器 ::: warning 先决条件 LauncherX作为一个绿色软件，必须手动将程序本体解压到一个预先准备好的文件夹内才能运行。如果弹出Windows Defender的警告，请点击【显示更多/高级选项】，然后点击【仍要运行】。相关阅读：开始 (LauncherX) | 日冕知识库 关于Windows7相关的问题，参见：Windows 7 用户指南 | 日冕知识库 ::: A. 部分特定的Windows系统环境下启动器没有主窗口和前台进程 症状：双击解压后的启动器，仅会创建相关的文件夹和文件，并且任务管理器中有对应的后台任务，但是没有启动器窗口出现； 解决方法：从官方下载最新版本对应架构的VCRedist并安装（2015~2022合集版）。 常见于：Windows11家庭版，Windows10部分较老版本 :::warning 顺便一提 不要将LauncherX放在C盘根目录。我们建议在桌面或其他硬盘分区创建一个新文件夹然后将LauncherX放进去，这样可以避免很多问题。 ::: B. 对于部分早期版本Windows11和Windows10的“快速异常检测失败”错误 症状：在尝试运行启动器时出现弹窗【发生了快速异常检测失败。将不会调用异常处理数据，并且进程将立即中止】或无响应，在eventvwwr中提示上述弹窗中可能出现的文本或只出现和LauncherX相关的类型为1000的错误。 解决方法：有热心市民报告Windows更新包【KB5046714】可能解决该问题，但是我们建议直接进行系统更新。温馨提示：Windows10仍然可以接收到此修复更新，不必更新到Windows11。Windows10的官方支持很快将会结束。 常见于：部分早期版本Windows11和Windows10 参考信息不可考。感谢热心市民的反馈。 C. 部分未知的、无迹可寻的Windows下可能出现的双击无法运行，并没有相关文件和文件夹被创建 症状：与【A】类似但是没有文件被创建 解决方法：尝试使用powershell启动 常见于：未知 提示：此方法可能不能解决问题，并且有遇到此情况的个别用户在稍后报告双击启动器可以正常打开。 建议作为走近科学素材录制。 D. 在EventVwr中明确异常代码：0xc0000602 症状：与【A】可能类似，但是记录了明确的异常代码0xc0000602（仅在较新的系统和基于dotNET9的LauncherX中可能出现） 解决方法： 使用组合键 Windows + i 打开设置 → 点击【隐私和安全】→ 点击【Windows安全】→ 点击【打开Windows安全】（按钮文本可能因系统版本而有细微差异，使用任意方法打开Windows安全中心即可） 在边栏（如有）找到【应用程序和浏览控制】然后点击它 找到图标为【\uF8A6】的Exploit Protection（漏洞防护）点击位于其标题和描述下方的【可能与标题同名的链接】这个链接一般使用系统主题色，点击后可以进入对应的详细设置。 在Exploit Protection设置里，点击【程序设置】，然后点击【添加】，然后点击【添加使用程序名称】（?） 在弹出窗口输入LauncherX的文件名，默认状态应该是LauncherX.Avalonia.exe。该输入框不支持通配符。 点击添加以保存。然后对LauncherX进行安全设置：向下滚动找到【硬件强制实施的堆栈保护】，勾选上【替代系统设置】，然后确保其下方的开关保持为关闭状态，然后点击弹窗中下方的【应用】（保存）按钮。 重新尝试启动LauncherX 常见于：Windows11，可能是24H2+的系统 参考信息：启动器无法启动并在Windows日志中提示0xc0000602错误 · Issue #352 · Corona-Studio/LXIT。感谢热心市民的反馈。 E. macOS启动闪退 症状：在第一次使用后再次打开LauncherX，弹出系统的程序崩溃弹窗 解决方法：前往macOS的【设置-(搜索)通知】，找到管理应用程序通知权限的列表，在其中找到LauncherX.Avalonia.app，为其赋予通知权限。 常见于：所有macOS 功能相关 下载相关：通用错误排除指南 如果在下载游戏或进行资源补全的时候频繁遇到错误、重试后仍然遇到错误，请尝试按照以下保守方案调整设置（选其一有效即可）： ::: info 需要重新发起有关下载任务 可能需要重新发起下载任务才能看到下载设置生效。 ::: 在网络设置中，保持开启多重源补全，降低下载线程到32； 在全局设置-启动器行为中，把重试次数调到最高 - 在网络设置中，关闭多重源补全，降低下载线程到16（多次尝试均无法解决问题则调到1），切换下载服务器到Bangbang93的下载服务器； 在全局设置-启动器行为中，把重试次数调到最高 - 在网络设置中，关闭多重源补全，降低下载线程到5，切换下载服务器到官方； 在全局设置-启动器行为中，把重试次数调到最高（有条件的话可以在这个的基础上打开游戏加速器加速Minecraft国际服） 尝试切换网络到手机热点 尝试使用代理优化网络环境（游戏加速器，必须加速Minecraft国际服，且使用路由模式而非进程模式 (举例：小黑盒加速器的路由模式为模式2。其他加速器请参考对应的官方说明手册等文档)） ::: warning 必须要有理有据 所有用户的网络环境都可能受到不同的因素影响：可能是系统软件原因，也可能是电脑硬件原因，甚至可能是路由器设置、运营商、有关部门的行为影响，或是尝试访问的服务的服务器出现了各种问题。LauncherX的下载功能经过了成百上千次的测试和实际数据保证功能的健壮性。除非有充分的证据证明下载时的问题是由启动器造成的，否则开发组没有义务来解决用户自己的问题（甚至可能压根就不是用户或开发者的问题）。 辨认网络问题需要自行在弹窗或任务中心中查看错误信息。 关键词：SSL、TooManyRequests、远程主机关闭了连接、Connection reset by peer、补全游戏资源失败 ::: 基于ConnectX的联机 A. 无法加入联机房间/联机游戏 可能性1：没有在系统防火墙中放行 症状：点击【连接到服务】等待太久 解决方法：根据网络上提供的适合你的系统的方法，为LauncherX通过防火墙放行 可能性2：当前网络安全等级过高 症状：用户能加入ConnectX的游戏房间，但是看不到游戏世界 解决方法：在Windows的网络设置中，设置当前网络为专用网络。为了你的设备安全，不要在你不熟悉的网络环境启用专用网络。 可能性3：当前NAT级别过高 症状：直连模式下，无法稳定保持连接，或完全无法加入ConnectX房间 解决方法：改用更宽松NAT环境的网络，或在创建房间时启用中继连接。中继连接使用我们的免费中继服务，这其中包含我们自己租赁的云服务器，也接纳中继节点赞助。请考虑通过爱发电赞助来维持所有人使用中继连接！ 可能性4：游戏使用不同的IP协议 症状：在游戏中看不到游戏世界 解决方法：（所有人）尝试在LauncherX设置【全局-启动器行为】确认打开【强制使用IPv4堆栈】，然后重启游戏。打开这个开关将会导致游戏无法连接到IPv6的服务器。 常见于：Forge修改后的游戏 可能性5：Mod导致的联机异常 症状：进行整合包联机时，出现异常。 解决方法：自行排查导致异常的mod。 可能性6：网络环境太差 请联系运营商或网络管理员。这常见于受管制的公司网络或学校网络。 可能性7：游戏开放的局域网世界绑定在异常网卡/IP段 症状：找不到游戏世界。且有玩家的本地网络IP段与其他玩家不同（通过电脑上启动两个游戏并在其中一个开放本地世界，在另一个游戏的多人游戏中找到的局域网游戏入口处可以看到实际的本地IP） 解决方法：IP段与其他玩家不同的玩家需要自行尝试调整网络设置，或使用其他网卡作为联网首选。 B. 提示缺失组件 症状：在点击联机按钮后，弹窗内提示缺失VCRedist 解决方法：自行下载安装VCRedist完整版本。 整合包相关 A. 无法拖入安装资源/整合包 症状：拖入任何文件均无反应 解决方法：不要使用管理员模式启动LauncherX 常见于：Windows ::: info 文章信息 上次更新：2025年9月15日 本文维护者：@fr1g, ... // 本文维护者在首次更新本文时应该在此接上自己在Github的用户名 :::"
  },
  "temp/docs-main/zhCN/lxguide/features/dashboard.html": {
    "href": "temp/docs-main/zhCN/lxguide/features/dashboard.html",
    "title": "仪表板 | Qomicex.Core API文档",
    "summary": "仪表板 :::info TIP 这个功能只在登陆后显示。为此您需要登陆日冕账户。详情参见: 启动器账户 ::: 仪表板是一个信息聚合的场所。在这里整合了一个全局搜索组件(WIP) 和当前Minecraft版本追踪组件，关于您系统资源和游戏时长的图表，以及来自官方的新闻瀑布流。 全局搜索和版本追踪 全局搜索 :::warning 笔者相信，这个功能仍然有很大的发展空间。您倘若有相关建议，请先参考反馈帮助。感谢热心市民的帮助! ::: 这个搜索组件目前可以调用您的默认浏览器的默认搜索引擎搜索您输入的内容. 版本追踪 这个组件追踪了Minecraft自发售至今已经度过的昼夜，以及已经发布的版本数量。另一侧展示目前最新的正式版和快照版本号。 系统信息 左侧图表展示您电脑目前已经使用的运行内存量追踪; 右侧图表展示您电脑目前的CPU用量追踪. 游戏信息 两侧的图表均展示了游玩的游戏已经追踪的时长. 新闻 来自Minecraft官方和其他信息源的新闻，以瀑布流的形式展示."
  },
  "temp/docs-main/zhCN/lxguide/features/dashboard/index.html": {
    "href": "temp/docs-main/zhCN/lxguide/features/dashboard/index.html",
    "title": "在这里你可以看到有关仪表盘组件的一些帮助知识 | Qomicex.Core API文档",
    "summary": "在这里你可以看到有关仪表盘组件的一些帮助知识"
  },
  "temp/docs-main/zhCN/lxguide/features/dashboard/search.html": {
    "href": "temp/docs-main/zhCN/lxguide/features/dashboard/search.html",
    "title": "如何使用仪表盘搜索 | Qomicex.Core API文档",
    "summary": "如何使用仪表盘搜索 您可以在聚合搜索输入框中输入任何您想要查找的内容。在您输入内容后，下方会弹出智能提示来帮助您快速的导航到搜索结果页面 使用指定的搜索引擎来查找内容 在默认情况下，LauncherX 会使用 必应（Bing）来查找您的搜索内容。 如果您想指定聚合搜索使用的搜索引擎，您可以在您的搜索内容前加入下面的前缀： 搜索引擎 值 百度 bd: 谷歌 g: 必应 b: 样例 使用百度搜索 “1.16.5材质包”：bd:1.16.5材质包 使用谷歌搜索 “1.16.5材质包”：g:1.16.5材质包 使用必应搜索 “1.16.5材质包”：b:1.16.5材质包"
  },
  "temp/docs-main/zhCN/lxguide/features/game-assets.html": {
    "href": "temp/docs-main/zhCN/lxguide/features/game-assets.html",
    "title": "| Qomicex.Core API文档",
    "summary": ""
  },
  "temp/docs-main/zhCN/lxguide/features/gamelist.html": {
    "href": "temp/docs-main/zhCN/lxguide/features/gamelist.html",
    "title": "游戏列表 | Qomicex.Core API文档",
    "summary": "游戏列表 本文介绍了LauncherX游戏列表和管理机制 ::: warning 只支持常见的版本隔离 LauncherX强制启用版本隔离，并且只支持版本隔离。这意味着官方游戏目录和MultiMC类游戏目录均不能直接供LauncherX使用。 在有关的游戏目录转换工具出现后，将会更新此文章并附加使用说明。 ::: [[toc]] 基本功能 LauncherX的游戏列表提供了最基本的已安装游戏的展示功能。 首先，如果没有游戏被安装，此处将显示为：【\uF133 无】。 当当前游戏目录存在游戏时，将会展示一个类似表格列表的界面。 表头 表头由【更多】、【游戏名称搜索框】、【版本】、【游戏时长】、【操作】四栏组成。其中，【更多】是可以点击的菜单按钮；【游戏名称搜索框】可以键入文字，以在游戏列表中搜索已安装的游戏，并且点击靠右的部分可以变更以游戏名称为维度的正逆排序；【版本】亦可以点击以从游戏版本号为维度对游戏进行排序；除此之外的项目不可排序。 ::: warning 已知问题 已知当前按游戏名称排序的实际点击位置处于输入框右侧，但是不在表示排序方向的图标上。目前暂时可以先选中搜索框以确认其范围，然后点击靠右的空白区域尝试切换排序。为此给各位用户带来的不便，我们十分抱歉。 ::: 列表本身 在游戏列表中存在以下两个状态的条目： 游戏。在每一行（项）开头有可供固定游戏到主界面的图钉按钮\uE840，末尾有【游戏设置 \uE713】按钮和【启动游戏】按钮。 ::: details 详细信息 双击此行游戏条目可以快捷打开游戏设置； 点击游戏设置按钮可以打开游戏设置； 右键点击将弹出右键菜单： 生成导出配置 如果已经存在FOLDERRULES，将询问是否需要覆盖以重新生成 编辑导出配置 当存在导出配置文件FOLDERRULES时用于打开文件并编辑 检查游戏文件 将会启动游戏资源检查，如果有文件缺失将会进行资源补全。 删除（存在二次确认） 删除这个游戏。 二级菜单：打开 使用系统默认文件管理器打开与此游戏相关的常用文件夹。 版本根目录 日志 存档 游戏截图 资源包 模组 光影包 二级菜单：导出为 将该游戏通过多种方式导出为整合包。 发布为完整包 CurseForge整合包 Modrinth整合包 点击启动游戏将按当前设置启动游戏： 如果启用了【固定账户】（全局游戏设置 # 在账户页面固定账户 | 日冕知识库），则将会使用选中固定的账户启动游戏； 否则，将会在点击后询问使用哪个账户。 ::: 无效目录。在每一行（项）开头有一个无视主题颜色的红色警告标志 \uE7BA，并且末尾有一个红色的badge，描述了无法识别的原因。 ::: details 详细信息 这种游戏条目无法被作为游戏启动。右键点击后有对应的右键菜单。 这种条目之所以出现，是因为可能有一个游戏的文件出现了损坏，或是有一个新游戏尚未完成安装，抑或是用户自己在versions里创建了一个并非游戏的文件夹。如果是一个正在安装的游戏的话，在游戏安装完成后刷新游戏列表，该条目将会恢复正常。 刷新 点击后将刷新整个游戏列表。 删除（存在二次确认） 删除这个目录。 二级菜单：打开 使用系统默认文件管理器打开与此游戏相关的常用文件夹。 版本根目录 日志 存档 游戏截图 资源包 模组 光影包 ::: 游戏设置 目前（2025年2月10日）LauncherX允许游戏存在部分独立的设置。独立设置将覆盖全局游戏设置。 游戏名称：在游戏列表中展示的友好名称 游戏路径 \uE7BA不要擅自轻易修改！ 图标：在官方启动器可以展示的游戏图标 内存大小：此游戏启动时分配的内存大小 Java路径：指定游戏使用的Java环境（参考阅读：在完整包中包含默认选中的Java | 日冕知识库） 额外参数：指定此游戏启动时的附加参数 游戏窗口大小：游戏的窗口 宽 × 高 全屏：是否启动即开启全屏模式 ::: info 这里不存在游戏窗口标题设置。如果想要让标题显示游戏名称，参考：全局游戏设置#游戏窗口设置-组合设置 | 日冕知识库 为全局启用标题栏占位符。 这里也不存在单独的启动后加入服务器管理。目前我们规划了一种更独特的管理方法，敬请期待。 ::: 此外，游戏设置中提供模组管理，可以在其中检视模组、禁用模组、删除模组；可以预览此游戏的截图；可以预览资源包和光影信息。 ::: tip 你知道吗？ 在游戏设置的大界面里，如果模组、截图、资源、光影的文件夹存在，鼠标悬浮在标签按钮上时会出现一个打开文件夹的图标 \uE8DE，点击这个图标即可打开对应的文件夹。 ::: 重要提示 LauncherX可以发现手动粘贴到游戏列表目录versions文件夹中的游戏版本文件夹。 对于一些在安装过程中涉及释放基础库的游戏，可能并不适用#1中的游戏安装方法。比如：Forge 对于非默认的游戏主目录（LauncherX工作目录中的.minecraft文件夹），LauncherX无法实时监控内容变更。如果发现实际情况和游戏列表内显示的不一致，请手动点击刷新。"
  },
  "temp/docs-main/zhCN/lxguide/features/icon.html": {
    "href": "temp/docs-main/zhCN/lxguide/features/icon.html",
    "title": "自定义游戏图标 | Qomicex.Core API文档",
    "summary": "自定义游戏图标 ::: warning 差异 截止至2025年3月15日，游戏设置中的【图标】设置项与此功能无关。 ::: 使用LauncherX的自定义图标特性可以让特别的游戏在游戏列表中更有辨识度。 如图所示，由于Cobblemon官方导出的整合包中存在一个icon.png于游戏的根目录之下，其被LauncherX作为游戏图标展示在了游戏列表中。 操作指南 如果要为游戏应用一个图标，需先自行准备好图片文件。我们建议使用长宽比为1:1的，并且带有透明背景的PNG格式图片。 准备好图片。它可以是你的整合包Logo。 如有需要，使用Photopea或AI抠图功能，仅保留图标主体。 将图片保存为icon.png并放置在~/<游戏目录>/versions/<你的游戏版本>/下。 打开LauncherX的游戏列表。刷新后将可看到LauncherX取用了此图片为游戏图标。 如果没有生效，请确保LauncherX是最新版本。 LauncherX仅接受特定命名以自动选为图标。如果最终图标不是正方形（长宽比1:1），那么图标会仅展示始于中心点的最大的正方形部分。 ::: info 与整合包导出的兼容性 LauncherX在导出整合包时，如果存在icon.png，将会将其包含在整合包中。 :::"
  },
  "temp/docs-main/zhCN/lxguide/features/index.html": {
    "href": "temp/docs-main/zhCN/lxguide/features/index.html",
    "title": "LauncherX有趣的功能 | Qomicex.Core API文档",
    "summary": "LauncherX有趣的功能 这里主要介绍了一些内置于LauncherX的独特功能。由许多实用、有趣、方便的功能点缀的启动器将能极大地提升您的体验。这一系列说明将帮助您更快地上手使用. :::warning 这里的功能介绍可能随时出现细微变动。恕无法另行通知. 此外，这里还有一些使用LauncherX时候的“奇技淫巧”。 奇技具有以下特征： 通过有技巧性的操作实现原本LauncherX本不明确支持的功能 在原理上并未利用bug 如果你发现了什么新的奇技，可以和我们分享。我们或许会在整理后发布在这里。"
  },
  "temp/docs-main/zhCN/lxguide/features/installing-games.html": {
    "href": "temp/docs-main/zhCN/lxguide/features/installing-games.html",
    "title": "安装游戏 | Qomicex.Core API文档",
    "summary": "安装游戏 LauncherX提供多种游戏安装方式。 [[toc]] 通过下载 通过内置的游戏下载，可以下载包括可选扩展组件（比如Forge、Fabric）在内的许多游戏。操作步骤如下： 点击导航栏上的【下载】 在列表中寻找或搜索想要下载的游戏版本，点击对应的下载按钮 在弹出的 “安装” 弹窗中，至少选择一项以继续安装。 如果要安装原版游戏，直接让列表中第一项保持选中，然后点击【安装】 如果要安装带有附属组件的游戏，选中它并选择一个具体的版本，然后点击【安装】 ::: tip 关键信息 得益于LauncherX强大的任务队列管理系统，你可以一次性选中多个游戏进行安装。 但是请注意，如果在对应的原版游戏未被安装的情况下安装了附属组件，那么该游戏将无法启动。 你可以在安装界面的每一个输入框更改对应游戏的名称。 ::: 等待下载安装完成。若在任务中心发现安装失败，请先确认自己的网络连接正常。参考：管理账户 | 日冕知识库 安装整合包 LauncherX支持 Modrinth格式 和 Curseforge格式 的整合包。只需要将这类整合包拖入LauncherX窗口（或在【游戏列表】中使用【更多-添加游戏资源-整合包】选择将安装的整合包）即可开始安装。了解更多：LauncherX的整合包支持 | 日冕知识库 迁移游戏 LauncherX可以使用其他目录作为游戏目录，如果想要LauncherX正确识别一个已有游戏的目录，这个目录必须是启用了一般版本隔离的（并非MultiMC类的版本隔离）。或者直接将包含 已版本隔离的游戏版本根目录（在.minecraft/versions/下的文件夹）粘贴到LauncherX当前选中的游戏目录的versions文件夹中。但是后者并不一定总是有效，具体取决于游戏类型，参考：游戏列表 | 日冕知识库"
  },
  "temp/docs-main/zhCN/lxguide/features/launch-test.html": {
    "href": "temp/docs-main/zhCN/lxguide/features/launch-test.html",
    "title": "测试启动 | Qomicex.Core API文档",
    "summary": "测试启动 ::: warning 兼容性问题 我们注意到，截止至2025年5月1日，Linux多数发行版无法使用此功能。 ::: [[toc]] 功能简述 这个功能可以通过系统终端/控制台来展示包括JVM错误在内的完整日志以供排除错误。 使用说明 在游戏列表中找到需要调试的游戏 点击游戏的设置按钮（\uE713）或双击游戏以打开游戏设置 找到靠近窗口右上角的启动按钮（\uE768，往往带有一个红色的点状星号）并点击 等待命令行窗口弹出 若是需要提供反馈信息，请等待命令行完成运行停止滚动（对于游戏意外崩溃问题）并提供截图。后续如有需要请继续提供更多相关截图，故建议不要过早关闭该窗口。"
  },
  "temp/docs-main/zhCN/lxguide/features/log-window.html": {
    "href": "temp/docs-main/zhCN/lxguide/features/log-window.html",
    "title": "游戏实时日志窗口 | Qomicex.Core API文档",
    "summary": "游戏实时日志窗口"
  },
  "temp/docs-main/zhCN/lxguide/features/manage-server.html": {
    "href": "temp/docs-main/zhCN/lxguide/features/manage-server.html",
    "title": "游戏服务器管理 | Qomicex.Core API文档",
    "summary": "游戏服务器管理 :::warning 根据老腊肉的说法，这个功能是面向服务器整合包制作者的，因而暂未打算允许为每个单独的游戏作适配。如果对单独游戏单独的服务器管理的功能需求较高，则会考虑制作此功能。请通过这里的方式 让我们知道! 更新日期: 2024年3月4日 ::: 介绍 当您在设置中选择了一个已经添加的服务器，那么每次启动游戏都会在游戏启动后自动尝试加入该服务器。 步骤 若要设置和管理服务器，请按照下述顺序寻找入口按钮: 点击导航栏的“设置” 在“全局游戏设置”中向下滚动以寻找: “启动后加入服务器 + [管理服务器(按钮)]” 点击按钮“管理服务器” 点击右上角的“添加” 在弹出窗口中输入目标服务器的信息。如果您找不到弹出窗口的“添加”按钮，请耐心等待LauncherX获取协议版本信息。在确认您的协议版本选择无误后(一般也不需要修改)，点击添加。 您可以添加多个服务器。在完成添加后，点选一个服务器，然后点击左上角的“返回”，即可保存已选择的服务器。继而，您可以在“设置”中该设置的入口处确认是否已经选中您想要选择的服务器. :::tip 一般而言，此刻启动游戏将可以直接加入到目标服务器。如果没有，请尝试换一个对应的协议版本并重新添加，然后选中. :::"
  },
  "temp/docs-main/zhCN/lxguide/features/modpack-support.html": {
    "href": "temp/docs-main/zhCN/lxguide/features/modpack-support.html",
    "title": "LauncherX的整合包支持 | Qomicex.Core API文档",
    "summary": "LauncherX的整合包支持 LauncherX对curseforge、modrinth格式整合包做出了相应的导入和导出支持。面对完整包分享者，LauncherX提供了可包含一个稳定版LauncherX、有许多附加导出选项可选的完整包打包功能。与此同时，LauncherX几乎没有对游戏目录作出魔改，确保了最高的兼容性. [[toc]] 导入 一般导入 :::warning LauncherX对较为主流的整合包格式做出了适配。但是，请注意，虽然MCBBS格式是基于Curseforge格式的，并且相关人员声称其与Curseforge格式相兼容，但是经过测试，LauncherX无法直接导入MCBBS格式整合包. 目前，LauncherX仅能识别 .zip 文件和 .mrpack 文件，且都必须为有效的Curseforge整合包或Modrinth整合包. ::: 您可以直接用“拖入”的方式来触发LauncherX的文件导入。准备好需要导入的文件，然后将其直接拖入到LauncherX窗体中。 倘若 没有触发导入提示框，则可能是您的系统或用户界面不支持拖入功能。无论如何，您都可以使用手动选择导入的方式来安装整合包。步骤如下: 点击“游戏列表” 点击左上角的“更多” 将鼠标移到“添加游戏资源”上方 点击扩展菜单中的“整合包” 在弹出窗口中选中需要导入的整合包并确认 此时您可以进行进行下一步操作了! 在LauncherX窗口中确认即将安装的整合包信息，然后点击安装，LauncherX将会完成后续操作. :::info 如果系统存在x64兼容层，LauncherX会在ARM设备尝试打开x64构建时发出警告。在兼容层中运行将会带来巨大的性能损失，使用达成同等效果却功耗更大的方式运行程序将不利于减少能耗和碳排放. ::: 意外情况 :::warning 导入可能出现问题。下面解释了部分问题及其解决方法. ::: 拖入/导入后界面中没有文字: 请尝试再次导入。如果仍然出现此问题，可能是包文件损坏. 导入时间过久或任务中心里出现任务错误: 请检查网络连接，或更换下载服务器。因为部分整合包可能为了压缩体积而不包含mod本身，而是使用了指向本平台的下载链接，在导入时直接下载mod。相关阅读: 专题: 检测网络 其他: 请依次尝试上述方法。如果无法解决，请保留错误报告、启动器日志，并通过这里的反馈方法向我们反馈. 导出 :::warning 请注意， LauncherX仅提供打包功能，对打包成品中引发的任何版权问题概不负责. ::: 要开始导出整合包，请先进入“游戏列表”，右键点击某一个具体的游戏，然后选中“导出为-” 并在接下来显示的次级菜单中点选您希望导出的格式. 导出完整包 LauncherX让您可以便捷地通过在游戏列表中右键点击游戏来将整个游戏版本导出为一个包含当前最新版本的LauncherX稳定版构建的完整包，并可选保留LauncherX的部分设置和游戏的部分内容。这使得发布包含完整启动环境的整合包更加便捷. 使用完整包导出引起的一切内容授权侵权纠纷均不由我们负责. 点击“导出为 - 完整包”后，将会弹出如图所示的窗口。接下来将解释导出前三个设置部分. · 发布平台 这里可选择导出包中包含哪些版本的LauncherX。勾选对应的构建可以让玩家在解压后立刻能够使用内含的LauncherX打开游戏而无需另外寻找和下载兼容的启动器. 请注意，勾选的这些构建将在确认导出后开始下载并打包入压缩包，选择越多的构建将会使包体变大。如果一个也不选的话导出包将不包含任何LauncherX构建. 一般而言，首要推荐包含Windows x64，次要推荐包含macOS和Windows ARM。如果您的目标玩家有需要的话，选择性地包含其他构建. · 启动器设置 导出的设置仅适用于LauncherX，如果导出的包不使用LauncherX进行游戏启动，则导出的设置不会有效. 保存基础配置: 包括所有的「全局游戏设置」、「外观设置」以及「网络设置」。除此之外的「已保存的账户」、「启动器账户」等设置均不保留。导出后的LauncherX会重新要求用户运行初次启动设置，但是已经预留的设置将作为默认值使用. 保存壁纸: 将会保存已经导入到LauncherX的壁纸。您可以为自己的整合包准备一张壁纸并设为LauncherX的图片背景，在设置中事先选中那个壁纸并勾选此选项将可以使导出的包可以在一打开时就使用此壁纸。但是请注意，这将会让导出包的体积随着已添加的壁纸增加. · 游戏文件 保留配置: 是否保留当前游戏的设置。如果勾选此项，诸如按键绑定、视频设置、「OptiFine设置未验证」将会保留在导出的游戏目录中. 保留默认配置: 未验证 是否保留(大多数由模组生成的) 默认设置。默认设置是用于部分情况下恢复默认设置的类似备份的配置文件. 保留模组: 是否包含此游戏中的模组目录及其中的文件. 保留资源包: 是否包含此游戏中的材质包目录及其中的文件. 保留光影包: 是否包含此游戏中的光影文件存储目录及其中的文件. 这个部分的选项基本与平台格式导出选项一致. :::warning 关于「保留存档」 暂不支持「保留存档」。因为存档可能太大，请单独打包分享存档。 如果需要LauncherX读区和打包存档，请通过反馈方式 向我们反馈，我们将在分析需求量后决定是否追加此项功能支持. ::: danger 此信息可能过时 ::: · 额外选项 不允许玩家创建下列账户类型：可选【离线账户、第三方登录、Microsoft】 限制玩家所使用的第三方验证服务器：输入框，接受外置登录验证服务器的URL地址 ::: tip 关于上述两个选项 相关阅读见：限制客户端 | 日冕知识库 ::: 通过第三方API压缩完整包体积：可选Modrinth和CurseForge，完成导出后，玩家将在初次启动启动器时安装游戏。 导出为平台格式 LauncherX目前对较为主流的整合包格式做出了导出适配. 导出为Modrinth :::tip Modrinth格式的整合包导出后后缀名为 .mrpack。 ::: LauncherX支持将具体的游戏打包为Modrinth格式。这是由mod发布平台Modrinth设计的全新整合包格式，易于共享. 打包步骤: 打开“游戏列表” 右键选中一个游戏 点击“” 点击“Modrinth整合包” 选择需要保留的项目。您可以仅将mod打包，或者包含您的材质包等. 选择保存路径 在点击确认后，打包导出任务将在后台进行。导出完成后您应该会收到通知，如果导出成功，您将可在您之前选择的保存路径中找到对应导出的整合包文件. 导出为Curseforge :::tip Curseforge格式的整合包导出后后缀名为 .zip。 ::: LauncherX同样支持将整合包导出为Curseforge格式。Curseforge格式是由Curseforge平台设计的可扩展的整合包格式，打包体积较小。 打包步骤: 打开“游戏列表” 右键选中一个游戏 点击“” 点击“CurseForge整合包” 选择需要保留的项目。您可以仅将mod打包，或者包含您的材质包等. 选择保存路径 在点击确认后，打包导出任务将在后台进行。导出完成后您应该会收到通知，如果导出成功，您将可在您之前选择的保存路径中找到对应导出的整合包文件. 目录规则 目录规则是LauncherX自有的一套规则，旨在将游戏目录中需要的文件夹包括进整合包，或阻止绝对不需要的文件夹被打包进整合包。 目录规则的文件名是FOLDER_RULES，你可以右键点击游戏列表中的任意游戏条目然后点击 “生成导出配置” 来生成新的模板配置文件或覆盖已有的配置文件，或点击 “编辑导出配置” 来让操作系统打开现有的配置文件（如果有）。 规则配置文件的格式如下： # FOLDER_RULES # 这个文件是用于控制 LauncherX 导出整合包时，哪些文件夹会被包含在内的。 # 如果想包含某个文件夹，则将其前面加上 + 号。 # 如果不想包含某个文件夹，则将其前面加上 - 号。 # '#' 开头的行会被视为注释。 # 任何不是以 '+' 或 '-' 开头的条目都不会被视为有效的规则 # 请在 '+'/'-' 后紧跟文件夹的名字，不要使用空格分割 # 示例： +tacz # 将包含tacz // [!code ++] -schematics # 排除掉默认规则会包含的schematics // [!code --] ::: details 默认规则 下面的规则是默认规则，除非你覆盖了它们，否则它们会被应用。 packmenu craftpresence patchouli_books armourers_workshop structures tacz modernfix scripts potionblender menu fancymenu_setups fancymenu_data global_packs oresources configureddefaults fontfiles worldshape resources kubejs tlm_custom_pack openloader CustomSkinLoader journeymap minemenu paintings schematics ::: 导出为任意包均可通过选中【使用FOLDER_RULES规则】来启用自定义的规则，除非文件夹本身是空的或不存在，否则导出的整合包将包含需要包含的文件夹。 完整包使用方法 :::info 下文引用了打包后压缩包内的说明文件并进行了细化. ::: 免责声明 此整合包由LauncherX生成，且由分享者选择了指定的LauncherX构建。LauncherX仅提供完整整合包打包功能，对打包内容不负侵权等法律责任，亦不对打包内容的安全性作出保证。 使用说明 您需要先为这个整合包准备一个新的文件夹。然后，将此压缩包中全部内容解压到这个新的文件夹中。 包内目录结构说明： .minecraft是包内包含的游戏本体的存储目录（macOS用户和Linux用户可能无法直接看到它）； LauncherX文件夹是LauncherX可携带运行文件存储的目录（如果存在）； [LauncherX]_Please_Decompress_This_File.zip 压缩包 是由分享者选择的LauncherX稳定版构建，即启动器程序本体。请打开它并按照您的操作系统和架构选择具体的主程序。 LauncherX.json 是LauncherX被导出时的设置（如果存在）； 一个readme.txt文件，是本页面内容的精简版，包含汉英双语版本. 接下来，倘若您是Windows用户，那么打开LauncherX.Avalonia.exe，即可开始体验这个完整包。（LauncherX可能会要求您进行初次设置，但是具体情况可能视分享者的导出配置而定。）; 但 如果您是macOS或Linux用户并且整合包内存在 “LauncherX的配置文件（LauncherX.json）和LauncherX文件夹” ，那么您需要将这两个项目保持同级地复制到指定的目录下： macOS = \"~/documents/Library/Application Support/LauncherX/\" // 两个项目均存放在这个路径中 // (~是您用户文件夹的起始点。一般会在Finder中显示一个小房子的图标； // Library可能会显示为其本地化名称“资源库”，而documents可能本地化叫做“文档”) Linux = \"~/documents/LauncherX/\" // 两个项目均存放在这个路径中 然后，(方法一) ​ ~您可以把.minecraft文件夹保留在解压后的原地（或者您如果看不见它的话，它就在原地），然后手动将这个文件夹作为新的游戏目录添加到LauncherX（在LauncherX的”游戏列表->[左上角的]更多->基础设置“中，点击添加。如果您看不到.minecraft文件夹，选择它存在的上级目录，LauncherX将会自动选择到存在的.minecraft文件夹。【此功能要求LXIT issue #46移除Invalid并真正更新实装】）； 或者，(方法二) ​ ~将它复制或移动到指定的目录下： macOS: \"~/documents/Library/Application Support/\" // .minecraft/ 存放在这个路径下 // (~是您用户文件夹的起始点。一般会在Finder中显示一个小房子的图标； // Library可能会显示为其本地化名称“资源库”，而documents可能本地化叫做“文档”) Linux: \"~/documents/\" // .minecraft/ 存放在这个路径下 此目录是LauncherX和官方启动器都会使用的默认的游戏目录。如果您不希望整合包内容扰乱您的既有游戏目录，您应该使用第一个方法。"
  },
  "temp/docs-main/zhCN/lxguide/features/p2p.html": {
    "href": "temp/docs-main/zhCN/lxguide/features/p2p.html",
    "title": "P2P联机 | Qomicex.Core API文档",
    "summary": "P2P联机 经过三次重构，LauncherX的P2P联机现已就绪* ::: warning 版本差异 请确保LauncherX版本是在2025年4月1日后更新的。此前稳定版的P2P联机组件已被弃用，无法与最新版LauncherX联通。 实质上，联机组件ConnectX在LauncherX稳定版（Stable）实装后仍然处于公开测试状态。如果遇到问题请先参考：报告异常&建言新策 | 日冕知识库 ::: [[toc]] 操作指南 先决条件：必须先登录日冕账户。 加入或创建房间 打开【设置-多人游戏】 在【操作】部分，点击【连接到服务】 等待连接成功。连接过程可能需要数分钟。 ::: danger 如果电脑上启用了代理，请将其关闭。 如果您要作为房主，请点击【创建房间】； 如果您要加入其他人的游戏，点击【加入房间】 房间ID是识别唯一房间的凭据。截至2025年3月15日，分享房间的文本是这样的： 我使用 LauncherX 创建了一个联机房间 [喵喵喵] 快加入我的房间吧！#\uD83D\uDC24\uD83E\uDD50\uD83D\uDC3F\uD83E\uDD94\uD83E\uDDF8\uD83E\uDD59\uD83C\uDF6C\uD83D\uDC36\uD83D\uDC3C\uD83E\uDD65\uD83D\uDC36\uD83D\uDC2A#如果您无法复制 Emoji 串，可以试试这段 ID [FbQjuf6RMcRG]。您也可以复制整段文本来直接导入！ 复制此段文本后可以直接在加入房间时【从剪贴板导入】 连接质量和处理速度视您的网络环境而定。并且，联机并非只有这一种方法。参考：一起玩吗? 联机游戏指南 | 日冕知识库 更多关于此的设置界面信息，参见：多人游戏 | 日冕知识库 游玩 ::: tip LauncherX简化了许多操作 相比于其他工具，LauncherX自动完成了诸如端口定位、数据转发等操作，为您提供更省心的使用体验。 ::: 房主： 房主创建房间的步骤与使用内网穿透 较为一致。但是使用LauncherX P2P将节约创建隧道、更改端口号等操作。 启动游戏。记得和邀请一起游玩的大家声明游戏版本以及使用什么加载器。 进入要游玩的单人世界。点击暂停，然后像一起玩吗? 联机游戏指南 # 将局域网世界暴露到公网 | 日冕知识库所介绍的那样将世界对局域网开放 LauncherX将自动发现开放的端口和世界。接下来将你的房间分享出去等待其他人加入游戏吧！ 加入者： 先决条件：加入了一个联机房间。LauncherX将会把联机世界自动映射到内网，所以Minecraft将会在【多人游戏】中自动发现房主的世界。 启动房主使用的游戏，确保使用一样的游戏版本和Mod加载器与模组。 点击【多人游戏】，等待Minecraft自动发现房主的世界。 当出现文字内容类似如图所示的选项，双击它加入。 也就是说，这个项目中[ConnectX]开头的即是所加入房间中房主的世界。"
  },
  "temp/docs-main/zhCN/lxguide/features/test-launch.html": {
    "href": "temp/docs-main/zhCN/lxguide/features/test-launch.html",
    "title": "测试启动 | Qomicex.Core API文档",
    "summary": "测试启动"
  },
  "temp/docs-main/zhCN/lxguide/features/tricks/debug-lang-file.html": {
    "href": "temp/docs-main/zhCN/lxguide/features/tricks/debug-lang-file.html",
    "title": "我想贡献多语言了！ | Qomicex.Core API文档",
    "summary": "我想贡献多语言了！ ::: tip 太好了！ 感谢您，热心市民！贡献多语言的仓库在这里：Corona-Studio/LauncherX-i18n: The i18n project for LauncherX (github.com)。 关于提交，您若有不了解的地方，可以参考：提交本地化翻译贡献 | 日冕知识库 ::: 当LauncherX文件夹（与LauncherX.json同级的名为LauncherX的文件夹）中包含有一个External.axaml之后，启动LauncherX，就可以在LauncherX的设置-外观-文本中找到一个名为 [开发者]使用外部语言文档进行调试 的开关。打开它后，将会强制使用这个External.axaml作为当前的语言文件，并且伴有明显的水印注明这是测试模式。 为什么需要这个？ 实际上，LauncherX中许多文本块只是针对汉语汉字量身定制的。这意味着，如果使用其他语言表达，则或多或少会出现以下问题： 显示效果不佳 无法完整显示内容 文本使界面变形 ... 使用这个功能可以帮助翻译贡献者灵活确认表达方式，是否需要使用缩写？这样/那样写会不会导致表意不明？总之，需要找到一种 “ ‘信达雅’ 与 ‘合适’ 之间的平衡点”。 为什么崩溃？ 或许您在使用过程中，某次重启LauncherX时候遇到了崩溃，可能有以下原因： 标签、键名等出现重复 文件无效或损坏 标签或键名的尖括号或引号未闭合/或发生了意外的闭合 模板字符串的大括号（比如：{0} 需要使用 {1}）被破坏 文件内出现了非法的符号（有没有在标签之外的地方出现奇怪的符号？） ... 请在其中找到问题然后解决，然后再次尝试打开LauncherX。如果想要获得详细的崩溃原因，请参考：好好利用日志文件! | 日冕知识库"
  },
  "temp/docs-main/zhCN/lxguide/features/tricks/default-jre-for-pack.html": {
    "href": "temp/docs-main/zhCN/lxguide/features/tricks/default-jre-for-pack.html",
    "title": "在完整包中包含默认选中的Java | Qomicex.Core API文档",
    "summary": "在完整包中包含默认选中的Java ::: danger 请注意！可能违反协议 在您自行分发的游戏完整包中包含Java运行时的行为可能违反了该运行时构建的分发许可协议或其他等效法律文件。这是您的个人行为，我们建议您再三确认合理性再进行操作。 ::: 如果您希望让您导出的游戏默认使用您提供的Java，可以遵循以下指引操作来实现。 准备好您的游戏和JRE，在启动器工作目录中创建一个文件夹并在其中解压JRE 点击要导出的游戏的设置，假设刚才解压JRE的文件夹叫jre且打开这个文件夹就能看到bin文件夹： 在Java路径中输入./jre/bin/javaw.exe 非Windows或许应该输入./jre/bin/java 但是具体使用的是哪个Java二进制文件需要依照实际情况决定（java还是javaw） 点击保存，尝试启动（仅在上一步中输入的JRE和当前系统匹配时可以启动） 如果启动不成功，请检查路径输入是否有误。启动成功后，可以通过任务管理器右键游戏进程来打开其所在文件夹以核对是否正常调用了预期的Java（Windows） 右键点击要导出的游戏，按照您的预期，将其作为完整包导出。 ::: warning 请注意！ 目前通过这种方式导出的完整包 不能使用API压缩 ::: 导出后，打开导出的zip文件，将之前的jre文件夹拖入/加入到其根目录中 将zip完全解压到某地即可测试是否默认选中了附带的Java。 ::: warning 部分细节未经测试 暂时无法确认：在macOS/Linux下，保存JRE的文件夹应该跟随其他文件夹一起解压到Documents还是保持和启动器本身在一起。 :::"
  },
  "temp/docs-main/zhCN/lxguide/features/tricks/disable-animation.html": {
    "href": "temp/docs-main/zhCN/lxguide/features/tricks/disable-animation.html",
    "title": "禁用动画 | Qomicex.Core API文档",
    "summary": "禁用动画 虽然LauncherX提供性能更好的动画接口，但是此接口存在暂未解决的问题，故作为【实验性动画】提供。这个动画接口的问题包括但不限于： 动画可能出现抽搐 同一类的动画在LauncherX启动后需要触发一次之后才能正常渲染，否则将不显示动画触发后的内容 如果您确实能舍弃动画，我们提供一种手动禁用动画的方式。很简单。 关闭LauncherX（可选），前往LauncherX目录 （这个目录是和默认游戏目录和LauncherX.json同级的） 在其中新建文件，命名为REDUCE_ANI，不要给它留下后缀名，这个文件应该是个完全的空文件。 重新打开LauncherX，即可禁用动画。"
  },
  "temp/docs-main/zhCN/lxguide/features/tricks/env-vars.html": {
    "href": "temp/docs-main/zhCN/lxguide/features/tricks/env-vars.html",
    "title": "自定义环境变量 | Qomicex.Core API文档",
    "summary": "自定义环境变量 ::: info 这个功能最初是面向Linux用户的 LauncherX暂不支持包装（前置）命令。使用此功能达成一样的效果。 ::: [[toc]] 文件格式 这是一个需要手动创建的文件。只有在特定目录下创建的名为GAME_ENV文件会被识别，其内容将会逐行被识别为环境变量。 这个文件内部格式如下： VARIABLE_NAME=value OTHERVALUE=value 总而述之，其必须满足以下条件： 纯文本 每一行都是单独一个环境变量的定义 键值中间用等号连接 使用说明 对全局游戏启用 ::: info 全局设置 在没有设置环境变量的游戏中将会使用此处保存的环境变量来作为默认值 ::: 前往LauncherX的运行根目录（可以通过游戏列表中的【更多-打开启动器根目录】） 打开LauncherX目录，在其中新建GAME_ENV 根据上文的格式写入环境变量 保存，然后启动游戏观察是否有效。 对单个游戏启用 ::: info 覆盖全局 对单个游戏启用的环境变量设置将会对对应游戏启用可以覆盖上文提到的全局设置的环境变量设置。 ::: 前往需要更改的游戏的目录（可以通过右键点击列表游戏【打开-打开版本根目录】） 在游戏目录其中新建GAME_ENV 根据上文的格式写入环境变量 保存，然后启动游戏观察是否有效。"
  },
  "temp/docs-main/zhCN/lxguide/features/tricks/icons.html": {
    "href": "temp/docs-main/zhCN/lxguide/features/tricks/icons.html",
    "title": "更多LauncherX图标 | Qomicex.Core API文档",
    "summary": "更多LauncherX图标 ::: info 即将到来 我们将在合适的时间开始提供一些LauncherX图标下载，敬请期待！ ::: 预计将在地址 https://iconeks.kami.su/lx 提供一些预处理的多样图标可选。"
  },
  "temp/docs-main/zhCN/lxguide/features/tricks/index.html": {
    "href": "temp/docs-main/zhCN/lxguide/features/tricks/index.html",
    "title": "怎么做到的？好怪，再看一眼 | Qomicex.Core API文档",
    "summary": "怎么做到的？好怪，再看一眼 这里还有一些使用LauncherX时候的“奇技淫巧”。 奇技具有以下特征： 通过有技巧性的操作实现原本LauncherX本不明确支持的功能 在原理上并未利用bug 或许是隐藏功能 如果你发现了什么新的奇技，可以和我们分享。我们或许会在整理后发布在这里。"
  },
  "temp/docs-main/zhCN/lxguide/features/tricks/pack-folder-rules.html": {
    "href": "temp/docs-main/zhCN/lxguide/features/tricks/pack-folder-rules.html",
    "title": "| Qomicex.Core API文档",
    "summary": ""
  },
  "temp/docs-main/zhCN/lxguide/features/tricks/restricted-client.html": {
    "href": "temp/docs-main/zhCN/lxguide/features/tricks/restricted-client.html",
    "title": "限制客户端 | Qomicex.Core API文档",
    "summary": "限制客户端 ::: info 服主功能 此功能适合想要限制玩家登录方式的服主使用。这些设置可以在导出完整包时轻松地通过导出前配置完成，而无需直接影响当前正在使用的启动器。相关阅读：LauncherX的整合包支持 | 日冕知识库 ::: [[toc]] 限制账户登录 限制账户类型 LauncherX允许限制用户只能使用指定的游戏账户登录方式。此功能需要在LauncherX工作目录下的LauncherX文件夹内创建名为DISABLE_CREATE_ACCOUNT_TYPE的文件完成。 这个文件的内容逐行接受这些预期的文字：Offline /Microsoft /ThirdParty。LauncherX读取这个文件时是大小写敏感的。 举例，以下的写法将只允许玩家添加[微软登录、第三方验证]： Offline 也就是说，写在此flag文件的登录方式将被禁用。 ::: danger 不可以同时选择三个禁用。三个都禁用将被视为无效的flag文件。 ::: 限制特定的第三方登录 LauncherX允许限制特定的第三方认证的外置登录服务器。此功能需要在LauncherX工作目录下的LauncherX文件夹内创建名为LIMIT_THIRD_PARTY_LOGIN_API的文件完成。 这个功能可以和限制账户类型搭配使用。 文件的内容必须是一行URL，指向外置登录时的验证服务。比如： https://api.skin.org/yggdrasil 暂不支持限制“仅允许列表内的外置登录”，因此仅可以设置一个外置登录验证服务器。即便如下写了多行URL： https://api.skin.org/yggdrasil https://giganticskin.org/yggdrasil 也是无效的，只会使用第一个URL。"
  },
  "temp/docs-main/zhCN/lxguide/features/tricks/set-task-queue.html": {
    "href": "temp/docs-main/zhCN/lxguide/features/tricks/set-task-queue.html",
    "title": "任务中心队列机制 -- 为什么我不能同时跑三个以上的游戏？ | Qomicex.Core API文档",
    "summary": "任务中心队列机制 -- 为什么我不能同时跑三个以上的游戏？ LauncherX使用一套独特的并行任务管理机制，使得启动器在有完整的对游戏状态监控的同时，处理其他事务。 鉴于使用LauncherX的设备性能可能参差不齐，而同时运行大量任务可能带来卡顿，所以我们暂未在设置中留下任务并行数量的明确设置。这个设置的默认值为3。 如果您觉得自己的设备具备强大的并行能力，只需要遵循以下步骤，来按需调整并行量： 关闭LauncherX（可选），前往LauncherX目录 （这个目录是与默认游戏目录和LauncherX.json处于同一级目录的） 在其中新建文件，命名为SET_TASK_QUEUE_SIZE，不要给它留下后缀名 用喜欢的文本编辑器打开它，并且输入一个你需要的并行数量的阿拉伯数字，不得填入除了数字以外的任何其他字符 重新打开LauncherX，即可应用新指定的并行任务数量设置。"
  },
  "temp/docs-main/zhCN/lxguide/others/adjust-ram-gc-ja.html": {
    "href": "temp/docs-main/zhCN/lxguide/others/adjust-ram-gc-ja.html",
    "title": "合理分配游戏内存、选择GC、配置JavaAgent | Qomicex.Core API文档",
    "summary": "合理分配游戏内存、选择GC、配置JavaAgent 使用LauncherX启动，游戏即便不进行特殊配置也能通过一系列默认配置达到通常标准和环境下很优质的性能。但是，由于用户电脑环境变数过多，有时候您或许需要学会对您的游戏进行一些额外配置来让您尽可能地发挥电脑的性能. :::warning 本文可能有较多纰漏 希望热心市民能够找到后反馈到邮箱: frigeso@icloud.com ::: [[toc]] 分配内存 内存是程序运行的众多关键之一，分配足够的内存将有助于您的游戏流畅稳定地运行。此处介绍的内存分配仅包含计算机基本的运行内存，而不包括其他的缓存、虚拟内存或GPU内存(显存). 一般而言，内存分配与许多因素相关，比如: 游戏版本、资源包规格、JRE、模组和模组加载器。与此同时也受到一系列外部因素影响，比如: 硬件的装机内存量、启动游戏时尚在运行的程序的内存总用量、硬件内存性能等. 接下来将详细分析这些因素，希望能对您有所帮助. 游戏因素 1) 游戏版本 对于不同版本的原版游戏，基础建议内存各不相同.: < 1.15: 建议512MB或更高 1.15 ~ 1.17: 建议1024MB或更高 1.17 +: 建议2048MB或更高 2) 资源包规格 一般而言，根据贴图的分辨率不同(16x 32x 64x之类)，内存需求就会不同，因为贴图材质需要被加载到内存中，所以越大的材质加载到内存中，需要的分配的内存总量越大。光影包也是如此. 3) JRE 一般来说，来自不同组织/公司的不同JRE构建之间都有所差异，因为它们都是为了不同的应用环境优化的，但是整体差别并不会太大。(仍然可能存在JRE不同导致的兼容性问题，但是出现在mod客户端的可能性更大) 不同JRE可能提供不同的优化特性，这些特性里有的功能可能需要提高LauncherX权限(管理员或超级用户) 比如，OpenJ9 JRE使用OpenJ9 JVM，整体占用偏低，调度相对保守，因而游戏可能无法完全利用好已分配的大额内存。但是对于硬件性能较差的电脑，可能可以保证游戏稳定运行. Azul Zulu和Alibaba Dragonwell是面向云计算的JDK构建，因而在应对高并发任务时可以发挥相对更好的性能. 更详细的测试，参见: 蒸汽通量 在 知乎 的文章: 几张性能对比，让你明白高版本 Java 更适合 Minecraft 当然，如果您实在搞不明白自己需要选择什么样的JRE，以下是我们的建议: :::tip OpenJDK - OracleJDK(或Oracle官网下载的Java) - Azul Zulu 越靠左越稳定，越靠右性能优化越好。当然，这里列举的JRE都还挺稳定的，细微差别可能需要您亲自感受. 参考本站指南：下载合适的Java运行时 | 日冕知识库 ::: 4) 模组和加载器 a) 加载器 加载器，比如Forge、Fabric，在对游戏进程进行混入等操作时均会耗费内存。分配给游戏的内存越多，加载越流畅，直到达到加载的性能瓶颈。 与此同时，加载器维护的接口也大有不同，因此不同的加载器也有性能区别。一般认为，Fabric比Forge更加轻量级，占用也会相应更少. b) 内容模组 内容模组由于向游戏中添加了新内容，会占用更多内存。具体而言，应该视单个模组中会注册和创建的方块、物品、实体量而定。与此同时，模组越多，需要的内存越多. c) 优化模组 这是模组中的特例。有一些内存优化模组将会提高内存利用率或优化模组内存调度，但也可能带来一些意外的游戏行为，甚至可能与一些模组不兼容。 关于推荐的优化模组，参见此MC模组百科链接(搜索结果): MCMOD搜索: 内存优化 5) 其他 除此之外，游戏世界中的每个区块(包含方块的x&y轴16*16大小区域)、每个实体(生物、掉落物和其他有模型的存在)都是被实际写入到内存的。一般而言，可以通过调整渲染距离来减少一次加载的区块数量来降低游戏占用。(本地游戏中通过加载器特性进行加载的区块可能也会被写入到内存) 但是如果您的可用容量足够，应该为游戏尽可能提高内存量以满足更多的区块同时加载，并且也要为区块加载和卸载之间的阶段、垃圾回收器尚未工作的时刻预留好内存以供更流畅的区块加载。在内存中，一个区块占用的空间大约是40KB. 在较新版本中(大约是1.17)添加了模拟距离调整。模拟距离是控制玩家周围生物被触发的距离的参数。越大的模拟距离，会导致越远的加载区块中的生物被加载，从而消耗更多内存。请自行在游戏中感受和测试，因为对于不同的生物(之类的实体) 需要消耗的内存量不等。并且，生物AI还会额外消耗CPU资源. 外部因素 1) 硬件装机量 这是十分显而易见的! 您的电脑倘若只有少量的硬件内存，可分配给游戏的就不得不变少。倘若您的电脑只有4GB运行内存，那即便您在LauncherX设置为8GB也是没用的，还有可能导致崩溃、甚至是有资料丢失的风险. 2) 其他程序占用 在游戏进行的过程中，其他程序(包括LauncherX，但是LauncherX在后台占用极低.) 同样会占用您的硬件内存。这里面包括您的操作系统维持运行的必要消耗，也包括您打开的其他应用程序的消耗. 3) 硬件内存性能 可以通俗地理解为内存频率对需要分配的内存量之影响。粗略来看，内存规格代数会体现出系列内存速度不同，但是实际远比“频率”这一单一指标要复杂。对于游戏而言，内存条频率越高，读写速度越快，则在执行交换(比如卸载区块同时加载区块)的时候就能更快地完成内存回收。不过，这一切实际上影响很小。除非您的内存优化已经到了锱铢必较的地步，那么对于越低频率的内存，建议给游戏分配的内存越多，但也没多到哪去. 总结 玩得卡顿了就加内存，物理内存不够加就关闭一些其他无关程序，不然就多装几条内存吧. 或者，您希望了解更多关于垃圾回收的内容，以期进一步优化内存利用? 请接着往下看吧! 选择垃圾回收器(GC) 垃圾回收器(Garbage Collector，GC) 是专用于回收被占用内存的工具，依照不同的策略将不同类型的对象实例回收以释放内存资源。对于Minecraft来说，这是不可或缺的。一般而言，对于特定的游戏配置，需要尝试和调校来找出最合适的GC配置。并且，在JVM中运行的程序缺少可用内存情况下， GC 性能更为显著. 在LauncherX中可以通过选择框选择GC。目前可选的有: Disable，G1GC，SerialGC，ParallelGC，CmsGC，ZGC. 接下来将介绍这些选项，同时将其可能适合的场景列出. Disable: 禁用GC，非常不建议。这将会让游戏的内存回收机制回到最被动的阶段，可能导致您玩着玩着就卡死闪退。若您需要尝试没在此列出的GC(Shenandoah)，可以选择此项然后在Java虚拟机高级参数中填写对应参数. G1GC: [并行+并发] 以垃圾回收为首要任务的垃圾回收器默认选择的单核GC，对游戏而言适用性最广，不知道选哪个就选它. SerialGC: [串行] 单核GC。只建议在内存量较少的环境下使用，甚至可以说不建议用于1.6.4以后的版本? LauncherX的调用参数并非Serial Old 。 ParallelGC: [并行] 多核优化的GC。可以避免在运行垃圾回收时引发的游戏线程阻塞，但是可能需要分配较多内存. CmsGC: [并发] 全称Mostly Concurrenct Mark and Sweep Garbage Collector，在Java14开始被删除。它的优势是工作时运作过程短暂、延迟低，多核优化，在游戏期间对计算性能影响较小。但是回收可能不及时，建议搭配较大内存，可能更适合用于多mod客户端. ZGC: [?] 对于需要处理突发任务较多的场景(比如多人联机的房主或服务器端)，此GC可有更好的性能。但是，这个GC只在Java15或更高版本JRE可用(在Java11推出为实验功能)。其他方面与G1GC相似. 配置JavaAgent :::danger 危险! 您首先需要确保您即将使用的JavaAgent包来自可信任的源。比如，从可信任的团队官网通过加密链接下载的、已经由您亲自进行本地校对的软件包。您必须知道您这么做的后果，以及后果是否符合您的预期。一般而言，加载JavaAgent可能会被在线游戏服务器视为作弊，请确认您行为的合规性。除此之外，因加载JavaAgent导致的 [任何] 游戏行为异常、网络攻击或信息泄露等问题均不由我们负责，LauncherX不具备检测和拦截危险行为的能力。因此，若要通过JavaAgent来优化游戏，请 [一定要自行确保安全性]，否则不要使用JavaAgent! ::: 简介 JavaAgent本身是使用了用于更高级的Java虚拟机内调试的一套接口的软件包，本身是旨在便于在Java程序运行时进行调试，也可用于注入软件进程以进行篡改、优化、性能分析等一系列操作。简而言之，Java Agent可以理解为是一种特殊的Java程序，是在Java5以后Instrumentation接口的客户端。 在 [设置-全局游戏设置-启动设置(下半部分比较偏高级设置的部分)-JavaAgent设置]处，存在两个并列的输入框: 前者输入JavaAgent软件包的路径，后者输入JavaAgent的参数. 接下来，我们将结合Github项目: Minecraft Threadpool Agent 来介绍使用方法。但是请注意，并非是我们推荐使用它，任何使用JavaAgent的行为导致的意外均不由我们负责。 根据该项目的描述，这是一个用于扩大游戏可用线程池的JA，可用于客户端和服务器端，主要面对1.13之后发布的游戏版本的相关优化，用于减少CPU占用和提升启动性能、减少加载时间。根据介绍，它的作用在同时启动多个客户端/服务端时候最明显。作者表示，此JA目前 并未在单人游戏中测试，但是在多人游戏中测试无碍，且理论上不会对单人游戏造成负面影响 。详见该项目的README. 用法: 在此仓库的Release中下载构建 (或使用源码自行构建) 在LauncherX中: 在Java虚拟机高级参数中添加: -DminecraftThreadPoolSize=2 -DminecraftBootstrapThreadPoolSize=1 -DminecraftMainThreadPoolSize=2 在JavaAgent参数中添加: [第一个输入框] <您的下载路径目录>/minecraft-thread-pool-agent-1.0.0-shaded.jar ; [第二个输入框] 空 (仅在JavaAgent的提供者/开发者要求您添加额外参数时再在此填入内容) 请注意: 上文中的/是您的系统路径分隔符，视您的操作系统而定: 如果是Windows，且不是日语/韩语的环境/区域，您应该使用\\，否则您应该使用¥; 如果是macOS或Linux，使用/。对于较现代的Windows，可能接受/符号分隔，但是需要您保证 整个路径都使用同样的分隔符 . 确认LauncherX生成的拼接预览无误，启动游戏测试. 需要注意的是，您可以直接按照README中的提示将参数加入到Java虚拟机高级参数中，但是使用LauncherX拼接可以避免一些难以察觉的输入失误. :::warning 我们强烈反对一切作弊行为 ::: 勘误 暂无。 上次更新: 2024-03-17 参考资料 按引用顺序排列 cncounter，GC参考手册-Java版 | GC参考手册，cncounter，2020年6月23日，https://www.bookstack.cn/read/gc-handbook/ 壹氿，终于把CMS垃圾收集器搞懂了~ | :JVM，掘金，2021年10月28日，https://juejin.cn/post/7023935314703941663 “非著名程序员杨某”，一文讲透Java Agent是什么玩意？能干啥？怎么用？| : Java开发技巧系列，知乎，2023年6月17日，https://zhuanlan.zhihu.com/p/636603910 saharNooby，minecraft-thread-pool-agent | Java agent that allows to modify Minecraft client/server thread pool size，GitHub，Oct 1。2020，https://github.com/saharNooby/minecraft-thread-pool-agent"
  },
  "temp/docs-main/zhCN/lxguide/others/args.html": {
    "href": "temp/docs-main/zhCN/lxguide/others/args.html",
    "title": "其他 | Qomicex.Core API文档",
    "summary": "其他 这里存放着一些解释文字的文字，和一些特性说明等其他内容。"
  },
  "temp/docs-main/zhCN/lxguide/others/download-jre.html": {
    "href": "temp/docs-main/zhCN/lxguide/others/download-jre.html",
    "title": "下载合适的Java运行时 | Qomicex.Core API文档",
    "summary": "下载合适的Java运行时 下载Java运行时的方式有很多种。这里介绍两个使用LauncherX时最主要的方法。 [[toc]] ::: tip 前置知识 你需要确保你知道你的电脑当前运行的操作系统和CPU架构以确保获得最佳游戏体验。 相关阅读：辨识计算机环境 | 日冕知识库 ::: 使用其他构建 一般而言，我们建议使用来自 Azul Zulu 的JDK构建（根据部分反馈，不再推荐Alibaba Dragonwell，除非环境一定需要它）用于游戏。在LauncherX的“设置-全局游戏设置-启动设置-资源下载” 中提供了几个版本基于x64平台的JRE下载。这些下载是由Mojang选择的用于游戏的JRE，一般都是来自OpenJDK的构建。但是，目前(2024-03-17)为止，Mojang尚未为ARM平台选择JDK。因此，对于ARM平台用户或想要通过更换JRE来优化游戏的用户，我们建议使用Azul Zulu JDK，因为它是面向服务端优化的版本，应对高频内存I/O、高负载计算时能有更好的性能，且都有面向ARM平台(aarch)的构建可供下载。以下是这几种JDK的官方下载链接，您需要打开后选择需要的版本: Azul Zulu官方下载(英文): 提供各种版本的JDK构建，可选包含JavaFX运行时 Azul Zing官方下载(英文): 各种新版JDK构建，免费版可能略有不稳定的情况，但是性能更好（一般来说，大概） Oracle Java SE Runtime 下载(英文): Oracle的Java下载归档站 OpenJDK: 就是OpenJDK而已 接下来，我们以Azul Zulu为例展示如何下载，以及下载后应该如何让LauncherX找到. ::: warning 请注意 由于仅Windows版本的LauncherX支持深度搜索，且深度搜索获取结果较慢，故此接下来的教程中只使用一般搜索和手动添加. 并且这里只介绍下载打包为.zip的二进制文件的用法。如果Linux用户在下载后出现问题，请尝试下载.tar.gz，这个格式的归档保留了权限设置. ::: 访问官网的下载页面 访问 https://www.azul.com/downloads/#zulu ，找到下载区域。如图所示的是版本筛选框. 在 Operating System 处选择 Windows/macOS/Linux(请自行选择子版本/发行版)， 在 Architecture 处选择 x86 64-bit或ARM 64-bit (前者是一般的amd64/x86-64架构，后者是ARM架构。) 在Java Package选择「JRE」或「JDK」(如果有需要的话，可以选择带有FX字样的体积更大的选项。它附带JavaFX支持) 在Java Version选择您需要的版本(Java17/Java8)。如果右侧的Include Older Versions开关没有开启，这里则不会显示用于1.17的Java16，或其他非LTS版本. :::tip 请前往系统设置确认您的处理器架构，或借助LauncherX的判断: x64架构无法运行ARM架构版本LauncherX，而ARM架构LauncherX可能可以运行x64架构版本LauncherX，但是会有明显的警告. ::: 在您每一步的筛选器操作结束时，该页面的可用下载列表都会依据您的条件更新. 一般而言，建议您选择列表最开头的项目 (只要您严格地完成了系统和架构选择)。在您打算下载的项目右侧的 Download 按钮中选择 .zip 格式的运行时并点击，等待下载完成后将其解压到任意一处本地文件夹 (最好新创建一个). 随后在 LauncherX 中选择 搜索Java。如果搜索不到您新解压的JRE，请点击手动添加，并选择刚才解压的文件夹 bin/ 目录下的 java 可执行文件即可 (对于Windows，如果开启了显示已知文件扩展名 ，则您要选择的项目名为java.exe)。 使用LauncherX内置的下载 (Windows x64) ::: warning 正如前文所说... 「在LauncherX的“设置-全局游戏设置-启动设置-资源下载” 中提供了几个版本基于x64平台的JRE下载。这些下载是由Mojang选择的用于游戏的JRE，一般都是来自OpenJDK的构建。但是，目前(2024-03-17)为止，Mojang尚未为ARM平台选择JDK。因此，对于ARM平台用户或想要通过更换JRE来优化游戏的用户，我们建议使用Azul Zulu JDK，因为它是面向服务端优化的版本，应对高频内存I/O、高负载计算时能有更好的性能，且都有面向ARM平台(aarch)的构建可供下载。」 如果你的设备当前运行的操作系统并非Windows x64，请回到本文最开始的地方。这部分的内容不适合你的设备。 ::: 在LauncherX的【设置-全局游戏设置-Java虚拟机设定】中找到【资源下载-下载Java】按钮，点击它。 在弹出窗口中选择你要下载的Java，选中后，弹窗会提示你这个Java适合哪些版本的游戏。 点击【添加】，稍等片刻直到下载完成。 正常情况下，下载完成后的Java会被自动发现并添加到LauncherX的Java列表中并可供选择。如果不知道需要哪个版本的Java，可以试着启动游戏，如果确实缺失对应版本的Java，LauncherX会发出警告，在警告弹窗中可以看见需要的Java版本。 参考更多相关文章 来自NitWikit：选择、下载和安装 Java | 笨蛋 MC 开服教程 (yizhan.wiki)"
  },
  "temp/docs-main/zhCN/lxguide/others/general.html": {
    "href": "temp/docs-main/zhCN/lxguide/others/general.html",
    "title": "常见名词解释 | Qomicex.Core API文档",
    "summary": "常见名词解释 其他: 这里存放着一些解释文字的文字，和一些特性说明等其他内容. [[toc]] :::info 善用浏览器的页内搜索功能! 可以尝试组合键 Ctrl + F 或者 ⌘ + F。如果是在手机上浏览，请试着在浏览器的功能菜单里找一找有没有搜索功能. ::: 游戏类 与Minecraft游戏运行相关的名词解释 ::: 日志 在游戏尝试启动阶段、JRE(JVM)已启动的时候就会输出到游戏版本目录下logs文件夹中的.log文件或者.log.bz压缩包。如果LauncherX开启了游戏日志实时输出功能，那么将会在其中展示实时的日志，方便人类可以读懂“游戏现在在干什么”。这个词也可能是指由启动器产生的日志文件，请根据上下文判断。与此同时，存在名为“crash-report”的Forge崩溃报告与这个词有极大的联系，后者本质上也是一种日志，但是是用于分析Forge崩溃原因的。无论如何，请具体分析. 启动参数 在启动游戏时，附加给游戏的启动命令。本页中「环境类」类别有相同的词，可以结合另一个释义深入了解. 待补充 2024年3月13日 最后更新 环境类 :::info 与计算机软件环境相关的名词解释。但是一般而言，这里只会解释和Minecraft相关的环境的名词。 ::: 环境 计算机软件运行所需要的前置条件。您可以把Mod的前置也理解为一种环境(的一部分)，但是一般而言的环境的定义比前置更大. JRE 全称为「Java Runtime Environment」，Java运行时环境。这是运行Java软件必要的一套环境。一般而言，无论是一般的JRE还是JDK，其中都包含JRE，而JRE一般包含JVM(Java Virtual Machine，Java虚拟机)，这为Java的跨平台等特性提供了运行的框架。很温暖，像家一样… 启动参数 或使用更广泛范围下的说法: 「JVM参数/Java参数」。您需要将它和Java Agent作出区分，一般而言，要想优化游戏启动，只需要更改JVM参数。对于JavaAgent设置的解释将在晚些时候LauncherX设置说明完成了「JavaAgent设置」分段后补充。 - 这是在启动JVM时附加在启动指令末尾的一串以-开头、使用空格分隔的附加字符，一般而言是用于指定JVM运行行为的。所以如果使用得当，将会为您的Minecraft游戏带来更好的体验。比如，您可以通过附加-Xmx5G 来为Java程序设定最高使用5GB内存的限额(实际用量视设备可用内存和程序需要情况而不同。而指定内存已经由LauncherX在全局游戏设置 中提供了带有可视化提示的输入框可供直接使用.) - 由于「但凡是使用JVM的程序，都可以使用JVM参数指定行为」，所以您同样可以用这种方法来优化其他在JVM中运行的程序或游戏(比如Project Zomboid，您可以在游戏目录中的ProjectZomboid64.bat中通过将默认的-Xmx3072m改到更大来允许游戏使用更多的物理内存.) JA 为了节省空间而使用的 JavaAgent 的缩写. 待补充 2024年3月13日 最后更新 Corona Studio :::info 日冕工作室特色。 ::: %一切严格的按词分隔的“帕斯卡大小写”单词% 可能是Rider对单词拼写的要求太严格了，或者老腊肉对帕斯卡大写法有种奇怪的执着，总之像「Minecraft」这样的单词在LauncherX中可能会呈现为「MineCraft」… 吔! 这是个语气词! 但还是放进来了! 这是Corona Studio常有的! 发音和用法均同“耶!”! 待补充 2024年3月13日 最后更新 :::info 想起来了会更新的。催更请发邮件到 frigeso@icloud.com，告诉我您搞不明白哪个词。勘误也发到这个邮箱好了www :::"
  },
  "temp/docs-main/zhCN/lxguide/others/index.html": {
    "href": "temp/docs-main/zhCN/lxguide/others/index.html",
    "title": "其他 | Qomicex.Core API文档",
    "summary": "其他 这里存放着一些解释文字的文字，和一些特性说明等其他内容。"
  },
  "temp/docs-main/zhCN/lxguide/others/report-with-logs.html": {
    "href": "temp/docs-main/zhCN/lxguide/others/report-with-logs.html",
    "title": "好好利用日志文件! | Qomicex.Core API文档",
    "summary": "好好利用日志文件! 本文将介绍如何在参与测试时或遭遇自己无法解决的问题时使用程序日志来帮助解决问题。当然，这种信息对于我们排除问题也是十分有用的。部分内容不可避免地可能存在一些隐私痕迹，但请相信我们只是需要解决问题，并会帮您保护隐私. [[toc]] LauncherX日志 LauncherX日志存在于LauncherX目录下。在Windows中，该目录和LauncherX本体存在于一个文件夹里; 而对于macOS，它存在于 用户文件夹(小房子图标)/资源库(图书馆图标)/Application Support/之中 (可以在此目录中按下按键L来快速定位L开头的项目。如果您手足够快可以快速点击La); 而对于Linux，该目录存在于/home/documents/ 下。其中的LauncherLog文件夹中储存着启动器的日志，而如果启动过游戏则会产生GameLog以储存部分游戏日志。如下图所示: 如下图所示的是LauncherX的日志文件内容。您应该将距离错误发生时最新的那个文件用于问题分析. ... EventVwr日志(仅Windows) 什么是EventVwr? EventVwr，即Event Viewer 事件查看器。它存在于System32目录下，名称为eventvwr.exe，可以通过Win + R快捷键「运行」窗口直接打开。它会事无巨细地记录系统中的事件，包括作为应用程序的LauncherX的部分崩溃信息. 首先，使用上述快捷键，输入eventvwr并点击运行. 在新出现的事件查看器窗口里找到默认就在左侧的目录导航栏，如图选中 Windows日志 - 应用程序 在中间靠上的窗口中依次点击红色错误图标，且来源为「.NET Runtime」的项目 ，并在下方确认是否是来自LauncherX的项目. 调整下半部分的大小 (鼠标拖拽上下窗口的中间分界线) 确认是否如上图所示: Application: LauncherX.Avalonia.exe 并且包含许多「at」开头的错误信息。如果是，您可以将这些错误信息复制发给我们 (LXIT/邮箱等，详见: 向我们反馈) :::tip 请记好LauncherX发生错误时的时间，这有助于快速寻找对应的事件项目。 如若需要刷新事件管理器展示的列表，请点击左上角菜单栏的「操作-刷新」 ::: macOS日志 不是崩溃弹窗吗? 崩溃弹窗中的内容往往包含的是与系统内核深度相关的信息，一般对诊断LauncherX没有任何帮助. 如何获取LauncherX崩溃瞬间的日志 首先，请确认这个错误会稳定复现. 然后，打开终端，并找到您的LauncherX主文件 (一般应该放在应用程序文件夹，文件名称一般是LauncherX.Avalonia.app) 右键点击它并点击“显示包内容” 在包内容中，依次打开目录: Contents/MacOS/ 。这里面应该可以找到一个名为LauncherX.Avalonia的文件。这是LauncherX的入口. 将这个文件拖入终端并点击Enter，LauncherX就会伴随着终端窗口中的日志滚动而开始运行. 在这个状态下尝试复现导致崩溃的问题。如果确实崩溃了，终端窗口中应该会显示如图的内容: 请将这一段Unhandled Exception复制给我们作为线索. Linux日志 使用终端运行LauncherX将会显示完整的日志。请参考上文关于macOS日志的内容向我们提供线索! 游戏日志 游戏未按照预期运行？甚至使用官方启动器之类的都一切正常、唯独LauncherX在同样配置下出问题？游戏窗口一闪而过？“没有找到主类或路径编码不正确”？使用测试启动功能获取更多错误信息，或拿着这些信息来向我们反馈！参见：LauncherX 测试启动 与此相关的阅读: 了解更多关于日志窗口的信息"
  },
  "temp/docs-main/zhCN/lxguide/others/switch-channel.html": {
    "href": "temp/docs-main/zhCN/lxguide/others/switch-channel.html",
    "title": "切换更新通道 | Qomicex.Core API文档",
    "summary": "切换更新通道 LauncherX具备多个更新通道和发行分支。 ::: warning 现在还不是时候… 截至目前（2025年2月9日），LauncherX现在实际存在差异的通道只有2条：Stable和Higgs。 ::: [[toc]] 更新通道 LauncherX在设计时存在这些更新通道： Stable (Atom) - 最慢，最稳定，平均1到2个月更新一次。允许用户不登陆使用。 Proton - [暂不可用] 次慢，次稳定，平均每20天更新一次。必须登录使用，但是无需内测权限。 Neutrino - [暂不可用] 次快，不稳定，平均半个月更新一次。必须登录使用且需要内测权限。 Higgs - 最快，最不稳定，但是部署修复最快，高峰时期一天可能更新七八次。必须登录使用且需要内测权限。 如何切换 从官网下载的即是当前最新版本的稳定版。在稳定版中登录日冕账户，即可在【设置-启动器账户-先导版本体验设置】选择 更新通道 和 发行分支。在选择后，点击保存即可获取对应渠道最新版本的LauncherX以供更新。如果提示失败，请确认自己有对应的权限。前往官网主站 登录到服务即可查询，如果有【荣誉股东】标记则是有权限。 获取内测权限 LauncherX是一个以社区驱动为主的启动器，在启动核心、文档（CSKB）、语言本地化和资源翻译等领域接受来自社区的为爱发电。包括赞助在内，这些都是支持LauncherX及其他项目的表现，为此我们除了感激，只能报以在多方面与我们深入交流的内测权限等特别权利。这些接受贡献的项目由我们一起构建，我们一起将这些美观实用的趁手工具带到现实之中，感谢社区中每一位热心市民的贡献。 以下是可以获取内侧权限的方法（均需要登录状态正常的CSA日冕账户，可能需要提供账户对应邮箱）： 在LauncherX资源纠正计划 /「简明资源信息数据库」计划中累计成功贡献50次（提交50次通过审核的有效贡献），即可联系我们获取内测权限。 在我们的任意公开多语言仓库中贡献，维护完整的至少一门语言，即可联系我们，提供自己的日冕账户邮箱以获取内测权限。 向我们的公开项目仓库提交有效的Pull Request，在我们接受后即可联系我们获取内测权限。 加入我们，和我们一起构建，可以获取内测权限。 在稳定版率先发现重要bug（即，MineBBS平台上的更新日志中没有写在已知问题那一栏的问题）并反馈给我们并得到认可，即可索取内测权限。 向我们赞助任意可接受金额，即可获取内测权限（赞助需要登录到官网主站后通过赞助页面来完成。具体操作指引请参考：赞助我们！） 其他被我们认定是贡献行为的，我们会主动联系您以开通内测权限。 \uE7BA 谨防诈骗！ ::: warning 意外 很遗憾，目前（2025年2月10日）由于我们的服务器部署在海外，被支付平台屏蔽，所以我们不再接受微信/支付宝赞助。请直接通过爱发电和我们的官网进行赞助打赏和账户绑定，详见：赞助我们！| 如何绑定订单号 | CSKB 目前只有老腊肉有修改权限状态的能力。他可能与在中国大陆的各位存在时差。（2025年2月20日） ::: ::: danger 谨防诈骗！ \uE7BA 我们主动联系您开通权限时不会向您索取任何转账或验证码等信息！谨防诈骗！目前仅有老腊肉和法棍可能会主动联系用户开通权限，如果遇到信不过的人以给予权限为由和您联系，截屏并前往 LauncherX交流群 询问一下总是没错的。谨防诈骗！（相关阅读：通用隐私政策和最终用户许可协议#免责声明 | 日冕知识库 # 指路官方 | 日冕知识库 # 加入我们吧! | 日冕知识库 # 我们的团队 | 日冕知识库） :::"
  },
  "temp/docs-main/zhCN/lxguide/report-issue.html": {
    "href": "temp/docs-main/zhCN/lxguide/report-issue.html",
    "title": "报告异常&建言新策 | Qomicex.Core API文档",
    "summary": "@useFixer 报告异常&建言新策 创建日期 2023年11月27日，修改日期 2023年11月27日 作者：Feiron Iguista ::: info 再次感谢您选择使用LauncherX，并且还愿意来了解如何反馈问题和提出建议！ ::: [[toc]] 异常反馈 您有很多方法向我们反馈。一般来说，只要能与我们取得联系，那您就可以反馈问题。但是特定的方法有助于我们整理、记录和追踪问题，所以接下来我将依照我们推荐的顺序来列出一般可用的反馈方式。i 另外，您或许应该在反馈前阅读关于提供错误信息的指引：如何找到有效的错误信息和日志文件 我们仅有在有日志文件的情况下才能更好地定位问题！i 使用Github（推荐）或Gitee上的LauncherX Issue Tracker （LXIT） 这类代码托管平台一般都有完备的Issue系统（您如果不知道这是什么的话，可以理解为：一个用于归纳问题和建议的反馈系统），我们团队中负责LauncherX者都会在您于此处提交issue时收到邮件提醒。i 您提交的内容，首先必须满足以下两个条件： 不能和其中现有的项目重复。如果您想要提交的内容已经有他人提交并且您想作出一些补充，请直接在他人已提交的issue下作出补充。 不能是无意义的内容。我们有群聊供您大放异想天开之彩。 然后，希望您能够遵守以下约定，以让我们能有最高效的问题处理能力： ::: warning 翻译者请注意：这一段是援引自@CodingEric已经锁定的置顶issue：LXIT Submission Guidelines · Issue #1 · Corona-Studio/LXIT (github.com)。这些内容同样需要进行本地化。 ::: LXIT是LauncherX的问题追踪计划。请所有参与测试的人员务必严格遵循以下规程，否则您的请求可能不会受到回应。i 对于问题报告，需要： 系统信息 复现步骤 对于新功能请求，需要： 功能描述 引入原因 如果可能，绘制用户界面示意图或者程序流程图 我们不明确规定issue的格式，您也可以同时将多个问题/功能请求写入至同一个issue中。标题不重要，但最好能简明概括问题。i 以下issue不被允许： 没有实质性内容 使用过激语言等其他恶意行为 感谢您的参与！ // 结束 前往Issue Tracker： Github：Corona-Studio/LXIT: Issue tracker of LauncherX / LauncherX 议题追踪仓库 (github.com) Gitee(可能不会及时回应)：Issues · Feiron Iguista/LXIT - LauncherX Issue Tracker - Gitee.com 通过KOOK或Discord频道(暂未创建)反馈 您可以在很多地方找到我们更新的服务器邀请。一般而言，您在加入并通过验证之后，需要在频道的列表中寻找类似于：【反馈】LauncherX 的文字频道。i 但是！ 您必须遵守以下的格式进行反馈。与此同时，和上一条一样，无意义的、重复的内容不能提交。如果您想要补充说明已存在的问题，请找到它并点击回复。i 格式示范： 简述：界面动画卡顿 版本：（请在设置-关于 中找到出现问题的LauncherX版本。） 详细：在切换界面的时候动画总是一卡一卡的。 环境信息：macOS 13.1 arm（系统版本，系统架构。请注意：如果您在使用架构不正确的构建，则请不要发送这条反馈，除非正确的构建中也有这个问题。） | 开启了低电量模式（补充一些您觉得可能造成问题的情况，比如您当前的内存占用率？您是否在使用第三方杀毒软件？） 复现步骤：（请使用序号标注尽可能详细的导致问题再次出现的步骤。） 邀请链接： KOOK： KOOK (kookapp.cn) Discord： [暂无] (非常不推荐的方法) QQ私聊 > QQ群内反馈 > 发邮件 ::: warning 不是不行，但是整理起来真的很麻烦，而且有很大概率会忘记。并且，您的建言贡献不会被记录，而是随着时间与聊天记录流过而被遗忘。 ::: 在这些渠道进行反馈是效率十分低下的。虽然看起来好像能够获得我们第一时间的反应，但是整个流程是不清晰的。尤其是在群内反馈，单线程的消息流中随时可能会被其他人的闲聊扰乱，进而进一步对问题反馈带来干扰。不过无论如何，有格式的内容充足的反馈总是比混乱的反馈更好.i 奇怪的方法：加入我们，手动修复 您如果觉得您“一眼看出了问题所在” 并且确信自己“有能力修复”，而且打算“长期地与我们一起创造些什么”，您随时可以加入审核群！审核群的群号：1040526762 i 另外，哪些用于反馈的信息是有用的，该如何获取有用的信息? 一般而言，截图是非常直观的信息载体。但是倘若能包含错误信息，将会更好! 比如，在「任务中心」的错误，一般会包含被折叠的错误堆栈追踪。您应该将它展开然后进行截图，这样包含的信息是很全面的。i 我们可能会需要您提供复现步骤或者是在您那边的LauncherX行为 (或者说，症状)，这个时候或许需要您进行屏幕录制。对于Windows 10或更新版本的用户，如果您的系统没有被精简，可以使用 XBox Game Bar的录制窗口功能 (参见: Xbox: 了解 Windows 上的 Game Bar ) ; 否则，您可以使用QQ的屏幕录制。对于macOS用户，可以使用⌘ + ⇧ + 5 (command + shift + 5) 以进行屏幕录制。对于Linux用户或其他无法使用上述录屏工具的用户，可以下载OBS进行录制。(参见: 知乎: OBS录屏安装与简单使用方法)i 倘若游戏发生了致命错误并退出，仍然还有保留的日志窗口或错误分析窗口可供分析游戏错误。那假如LauncherX发生了崩溃，一般也只有macOS会有系统级别的错误报告弹窗了，在哪里寻找错误报告呢? 请阅读: 如何找到更全面的日志文件 i 一般而言，我们不强求一般用户向我们详细反馈问题。但是我们希望热心市民能够提供重要且充足的错误信息，一方面帮助我们改进LauncherX，另一方面我们可以帮助您解决问题。目前，发现并最先报告恶性bug的用户将有机会受邀加入内测 ! i 功能建议 实际上，您可以在标明“这是一条建议”的基础上，像反馈问题一样提交您的建议。i 一般而言，您需要： 尽可能详尽地描述您希望添加的内容 如果可能的话，请绘制示意图。可以在截屏的基础上圈圈点点，也可以制作框架图、甚至是原型设计（这样您或许会收到加入我们的邀请！） 阐述您为什么想要这些 最重要的：您需要在标题注明这是建议！比如：把“【建议】” 放在标题的开头。 ::: tip 再次感谢您对项目的付出！ :::"
  },
  "temp/docs-main/zhCN/lxguide/settings/index.html": {
    "href": "temp/docs-main/zhCN/lxguide/settings/index.html",
    "title": "对本类文档的解释：什么是“专题”，什么是“分类”： | Qomicex.Core API文档",
    "summary": "对本类文档的解释：什么是“专题”，什么是“分类”： 创建日期：2023年11月28日，修改日期：2023年11月28日，作者：Feiron Iguista 针对LauncherX的配置调整，我们提供了两种解释性文档：专题和分类。 一言以蔽之，专题相当于是特殊化的、可能连结多个设置分类的、着重于解释我们的特色功能的设置指引。 而分类是以LauncherX设置的不同选项卡为分类基础区分的，针对每一类中每一项设置的具体解释。 ::: warning 在文档的最初的编写阶段，标题中含有#的是未完成的项目。 ::: 专题 详细而言，专题会指引您完成比较曲折的操作。比如，调整启动器的整体外观到您中意的风格，或者结合“固定启动账户”和“游戏账户管理”来使您可以快速使用常用的账户启动游戏。 不过，想必您在阅读理解了分类板块之后，能够充分地发挥您的主观能动性并且玩出我们或许也未曾设想的花样。我们期待您能够深入地体验我们的产品！ 分类 这个板块会随着LauncherX的具体更新而更新，恕不另行通知。 致翻译贡献者：这个板块更新相对更加频繁。请合理安排提交. 详细而言，这里会指出LauncherX每一项具体的设置代表着什么。有些涉及启动原理的项目可能同样适用于其他启动器，但是我们当然更希望您能一直使用LauncherX. 我们将会在这里告诉您最具体的设置方法，比如：如何设置JVM高级启动参数？离线模式的本地皮肤是什么原理？如何合理配置GC（垃圾回收器）？诸如此类。 相信您在理解所有设置之后能够自行找出适合自己的最佳游戏体验。"
  },
  "temp/docs-main/zhCN/lxguide/settings/item/advanced.html": {
    "href": "temp/docs-main/zhCN/lxguide/settings/item/advanced.html",
    "title": "| Qomicex.Core API文档",
    "summary": ""
  },
  "temp/docs-main/zhCN/lxguide/settings/item/customize.html": {
    "href": "temp/docs-main/zhCN/lxguide/settings/item/customize.html",
    "title": "| Qomicex.Core API文档",
    "summary": ""
  },
  "temp/docs-main/zhCN/lxguide/settings/item/global.html": {
    "href": "temp/docs-main/zhCN/lxguide/settings/item/global.html",
    "title": "全局游戏设置 | Qomicex.Core API文档",
    "summary": "全局游戏设置 :::tip 这里是标签为「全局游戏设置」的分类下的设置项目。在这里您可以满足最基本的游戏启动设置需求，每一项设置在具体的游戏中若有特别的设置，将不会生效。详见: 版本隔离与独立设置 ::: [[toc]] Java虚拟机设定 选择全局使用的Java，下载、搜索、管理Java运行环境 在账户页面固定账户: 开关 | 默认:关闭. 开启此选项后，您在账户管理页面选中的账户将被视为固定的账户，并在您点击任意一个地方的启动按钮时作为默认的账户来启动，并不会询问选择哪个账户来完成启动。开启后,主界面固定游戏的启动按钮后会有一个标签显示当前固定的用户名; 而游戏列表中的启动按钮将会在您的鼠标悬浮在其上的时候显示为您固定的用户名. Java路径: 组合设置 包含: 展示路径的选择框、重新检查Java可用性按钮；重新搜索、深度搜索 (仅Windows)、手动添加按钮: 使用选择框来选择一个全局使用的JRE以供启动。每一条项目均为被搜索到的Java，并且依次显示了「LauncherX对该Java可用性的判断」、「Java版本」、「该Java的完整路径」。选中的Java将使用主题色高亮显示，其版本信息将在选择框收起的情况下于下方并排着的2或3个按钮的下方可见. 对于代表可用性的图标，有四种可能: \uE8FB : 代表这个Java是完整可用的，并且适合您的操作系统; \uE7BA : 代表这个Java存在问题，不建议使用它。通常可能是因为架构和当前系统不符(arm架构使用x64版本JRE、x64使用x32JRE都会使游戏体验大打折扣); \uE8BB : 代表这个Java已损坏，或者LauncherX无法识别这个Java(如果您为了启动1.7.0以前版本的游戏而使用Java7，则可以忽略LauncherX的判断)。您可以使用下方的下载Java按钮来下载一个Mojang官方选择的适用于amd64架构的JRE，或者自行下载安装一个新的JRE。 详见: [下载合适的JRE]; \uE895 : 代表正在或此时无法或暂时没有运行对该Java的检查。无论如何您都可以通过选择框右侧的按钮来发起检查; 无论何时您都可以无视LauncherX的判断，但是使用LauncherX不认可的JRE有可能严重破坏您的游戏体验。由于我们的Java运行时检测机制是通过 “搜索-执行” 模式工作以确认该运行时是否可用，所以在您启动LauncherX时候，可能会遇到来自Java的错误弹窗。——您完全可以直接将它关闭，因为这并不影响LauncherX运行；且如果您没有选择任何一个被LauncherX判断为有问题的JRE作为游戏启动所使用的Java，那么您的游戏启动几乎不可能受到受损JRE的影响。由于每次LauncherX启动都会检查搜索到的JRE是否可用，因此您应该将该受损的运行时移除，或者用自动化窗口关闭工具（比如 火绒弹窗拦截）对错误弹窗进行精准打击。 如果您需要LauncherX不再显示某个特定的JRE，请点开选择框，右键点击包含那个JRE路径的项目，点击「排除」。 :::info 对于非Windows用户，在手动添加Java时，您可能需要注意赋予LauncherX足够的权限。 不建议直接用管理员命令启动LauncherX。 macOS用户若不得不使用SUDO启动LauncherX，则请使用命令: sudo open <LauncherX.app的路径，可以拖入app包文件到终端窗口中来填充路径> “下载Java” 按钮、“查看CSKB文章” 按钮(仅在ARM架构系统中可见): 前者可以选择下载一个Mojang官方选择的适用于amd64架构的JRE，或者自行下载安装一个新的JRE。 详见: [下载合适的JRE] 在这个设置项下方有一串文字用于显示LauncherX对选中的运行时的判断。比如: 该Java运行时(17.0.1)匹配您的系统 :::warning 意外 如果那里显示了类似picked JAVA_OPTS=\"xxx\"的文字，请在环境变量中寻找名为JAVA_OPTS的环境变量并删除，然后注销或重启系统。这可能是其他启动器创建的临时项目. ::: 游戏通用设定 游戏内存大小、垃圾回收、窗口分辨率、JavaAgent参数、高级启动参数 内存大小: 正整数 | 默认: 1024 | 单位: MB 在这个设置项的下方有较为明了的内存占比图示。基于您选择的LauncherX主题色，较深色的代表您电脑未被使用的内存量，较浅色的代表您电脑已被包括LauncherX在内的其他程序占用的内存量。 剩余一部分则是您全局分配给游戏的内存量在装机内存的总量中的占比。请注意，如果您分配的内存超出了空闲内存量，那么横条下方空闲内存的实际数量将会显示为负数 (较新版本LauncherX将在内存超额的情况下使输入框的背景色呈淡红色)。 此外，针对不同版本的游戏，有不同的建议的内存大小。若内存分配量小于512(1.15.2更早版本游戏) 或小于1024 (1.15.2 ~ 1.17.x) 或小于1500 (1.18.x+)，都会带来游戏体验变差，甚至导致游戏无法启动。 ::: info 关注电脑内存用量 错误的内存分配也会带来未知错误。同时，针对Mod和材质、光影包，应适量针对性地增加内存分配。 相关阅读: 配置内存和GC、JavaAgent ::: 游戏窗口设置: 组合设置 游戏窗口标题：文本输入框 | 默认：空 用于修改游戏窗口的标题。 :::tip 可用占位符 通过使用这些占位符，可以在窗口标题中动态显示一些信息： %account%：当前游戏启动用户名 %launch_time%：启动时的时间 %game_name%：所启动的游戏名 ::: 窗口大小: 正整数 × 正整数 | 默认: 0 × 0 | 单位: ppi? 当此值为默认值 (即 0 × 0) 时，窗口大小将由游戏决定。 全屏: 开关 | 默认: 关 这决定了游戏是否在启动时就以占满全屏幕的形式展现。 请注意: 在游戏的全屏状态下 (而不是系统的全屏方案)，有些系统功能可能不可用 (比如Windows的系统截屏) 或出现异常表现 (如macOS可能出现退格键清除中文输入法候选时导致已输入内容被意外删除，或鼠标指针无法在游戏中隐藏)。 GC设置和高级参数设置: 组合设置 启用GC: 开关 | 默认: 开 | 控制垃圾回收器 (GarbageCollector) 启用与否 建议保持开启状态。 游戏在运行时候产生的不需要的内存借助GC进行清理和空间回收，籍由此来让内存利用更高效。除非您有开发者级别的必要的特殊需求，否则不建议关闭它. GC类型: 选择框 | 默认: G1GC LauncherX提供了几个常见的垃圾回收器可供选择。对于如何选择，参见: 配置内存和GC、JavaAgent Java虚拟机高级启动参数: 文本输入框 | 默认: [空] 额外的启动参数。您可以参考 [优化配置: 启动参数] 作为指引. JavaAgent设置: 文本输入框:路径 文本输入框:额外参数 | 默认: [空] [空] 一般用户基本用不上它。这是JVM提供的一系列调试接口。参见: 配置内存和GC、JavaAgent 启动后加入服务器: 设置 | 入口 点击“管理服务器”按钮 进入对应的管理界面。详见: 功能: 服务器管理 启动器行为 游戏资源检查、原生库替换策略(ARM)、启动后行为、日志记录 检查游戏文件: 开关 | 默认: 开 将在游戏启动的时候检查游戏的资源文件。如果您需要修改原版游戏的资源文件，相比于关闭此选项并直接修改assets，我们更建议您以资源包的形式覆盖。 资源补全最大重试次数: 正整数 | 默认：3 | 取值范围：1~10 拖动以修改值。 当资源补全遇到个别任务失败，允许重试的最多次数。在网络条件较差的环境下，越高的重试次数将会提升补全完成后资源绝对完整的可能性。重试补全将花费额外的时间。 使用快速资源检查: 开关 | 默认: 开 通过更激进的优化算法来节省启动前检查时间。 补全游戏文件时检查文件完整性: 开关 | 默认: 开 在补全游戏资源文件的时候检查文件完整性。如果网络可能存在波动，则这个功能可以很好地确保下载文件的完整性，并降低游戏时出现故障的概率. 原生库替换策略: 选择框 | 默认: LegacyOnly 这个设置仅在ARM设备上可见，用于控制LauncherX在ARM设备上优化游戏体验的行为。有以下可选值: LegacyOnly: 仅对较老的不携带ARM版游戏支持库的游戏进行库文件替换。 All: 对所有游戏使用原生库替换，即使游戏携带了ARM版支持库. Disabled: 对所有游戏都「不」使用原生库替换，即使是不携带ARM版支持库的游戏。(建议仅在替换后游戏出现问题的情况下使用此项目。) 较老版本的游戏不携带ARM版本运行库。为了尽可能发挥ARM设备的性能，可以使用支持ARM的游戏支持库 (LWJGL等) 游戏启动后启动器行为: 选择框 | 默认: 最小化 选择让LauncherX主窗口和其他窗口 (除了日志窗口) 在一个游戏启动后的行为: 是“保持原状”、“最小化” 还是 “直接退出LauncherX” 资源检查最大并行程度: 选择框 | 默认: 4 在执行资源检查时同时进行的检查数量。可选值: 1、2、4、8。更多的数量将会占用更多的CPU资源，请根据您的CPU参数配置进行调整. 启动游戏时显示输出日志: 开关 | 默认: 开 在启动游戏时是否显示游戏的日志窗口。详见: [日志窗口功能介绍] 启动器日志记录等级: 选择框 | 默认: Error 可选(整体详细程度从高到低): All(全部输出)，Unknown(未知来源)，Debug(调试信息)，Info(一般信息-包括游戏内聊天信息)，Warning(警告)，Error(错误)，Fatal(致命错误); Stacktrace(仅: 输出异常的完整溯源信息)，ExceptionMessage(仅: 输出异常的名称/和简单描述)(?) :::info 关于日志窗口 日志窗口展示的最低等级。越低的等级会显示得越详细. 了解更多关于日志窗口的信息 :::"
  },
  "temp/docs-main/zhCN/lxguide/settings/item/index.html": {
    "href": "temp/docs-main/zhCN/lxguide/settings/item/index.html",
    "title": "| Qomicex.Core API文档",
    "summary": "分类 这个板块会随着LauncherX的具体更新而更新，恕不另行通知。 详细而言，这里会指出LauncherX每一项具体的设置代表着什么。有些涉及启动原理的项目可能同样适用于其他启动器，但是我们当然更希望您能一直使用LauncherX。 我们将会在这里告诉您最具体的设置方法，比如：如何设置JVM高级启动参数？离线模式的本地皮肤是什么原理？如何合理选择GC（垃圾回收器）？诸如此类。 相信您在理解所有设置之后能够自行找出适合自己的最佳游戏体验。 ::: danger 需要帮助！ 由于各方面需要，【全局游戏设置】与【外观】两个设置大分类中被拆成了数个小分类，但是实际上部分设置并没有被放在最合适的分类之中，或是部分分类根本不合理。我们希望有社区的力量帮助我们进行重新分类！ 这属于反馈的范畴，高效率的反馈方式参见：报告异常&建言新策 | 日冕知识库 ::: ::: info 翻译者请注意：本分类中的所有项目的标题（包括侧边栏标题）必须完全符合LauncherX对应的本地化翻译。否则将会造成误解。 :::"
  },
  "temp/docs-main/zhCN/lxguide/settings/item/lx-account.html": {
    "href": "temp/docs-main/zhCN/lxguide/settings/item/lx-account.html",
    "title": "启动器账户 | Qomicex.Core API文档",
    "summary": "启动器账户 :::tip 通过一个日冕账号，您可以使用许多由我们提供的可拓展LauncherX体验的在线功能。有关账户管理策略，请查看我们的通用最终用户许可协议. ::: [[toc]] 未登录状态 操作 操作按钮: 登陆 :::info 点击登录以使用更多在线服务，比如P2P联机和其他好友在线功能. ::: 已登陆状态 操作 操作按钮组: 注销 | 保存 :::info 使用“注销”按钮将当前登陆的日冕账号登出。使用“保存”按钮来尝试使下方配置的账户设置生效 ::: 账户和启动器相关设置 用户基础设置: 用户状态: 选择框 | 默认: 在线 / <上次登陆时设置的状态> 先导版本体验设置: 更新通道: 选择框 | 默认: 稳定 / <上次登陆时设置的值> :::info 这里控制总体的更新渠道选择。可选值有: 稳定，预览。后者必须要保持日冕账户登陆，并且账户已经有有效的预览资格. ::: 发行分支: 选择框 | 默认: 稳定 / 空 :::info 三个预览更新通道分为Higgs(最快)、Neutrino(快)、Proton(较稳定，较慢)。请注意: “快”是指更新、修复问题、推出新功能的频率，并非直接影响LauncherX性能的选项. ::: 小窍门 您可以在登陆状态下在不修改当前账户设置的情况下点击“保存”按钮来让LauncherX检查更新."
  },
  "temp/docs-main/zhCN/lxguide/settings/item/multi-game.html": {
    "href": "temp/docs-main/zhCN/lxguide/settings/item/multi-game.html",
    "title": "多人游戏 | Qomicex.Core API文档",
    "summary": "多人游戏 ::: warning 随时更新 本文内容随时可能过时。此处暂时仅展示主要信息。 2025年3月15日 ::: 界面 点击【连接到服务】按钮后： 点击【创建房间】： 点击【加入房间】 相关信息 开源项目： ConnectX Hive.Framework 相关页面： P2P联机 | 日冕知识库"
  },
  "temp/docs-main/zhCN/lxguide/settings/item/network.html": {
    "href": "temp/docs-main/zhCN/lxguide/settings/item/network.html",
    "title": "网络设置 | Qomicex.Core API文档",
    "summary": "网络设置 [[toc]] 基础网络设置 资源下载服务器: 选择框 | 默认: Bangbang93的下载服务器 :::info 可选项: Bangbang93的下载服务器(BMCLAPI)，Mojang官方服务器。 如果您身处中国大陆地区，使用Bangbang93的下载服务器或许更好。仅在Bangbang93的下载服务器不可用或过于缓慢时使用Mojang官方服务器。(Bangbang93的下载服务器可能会因为线路过于拥挤而出现短暂的不可用状况。虽然貌似与我们关系不大，但是: 这个下载源是公益且免费的，如果您有能力且希望这个公益下载源可以变得更好，您可以通过爱发电平台向发起人进行赞助。赞助BMCLAPI) ::: :::warning 从2024年2月20日起的LauncherX移除了对mcbbs下载源的支持. ::: 下载线程数量: 拖动条(整数) | 默认: 160? | 单位: 个 :::info 控制下载或补全游戏资源时同时进行下载的线程数量。一般而言，宽带带宽越大，此时线程数量越多，整体下载速度越快、效率越高。 请注意，倘若选择了Mojang下载服务器，受制于API限制，不建议您选择大于5的线程数量，以避免大规模的下载失败。与此同时，实际下载速度受上游网络影响: 假如服务器方面出现拥堵，则整体下载速度同样会被拖慢. 因此，请酌情选择线程数量. ::: 自动决定下载方式: 开关 | 默认: 开 :::info 启用此项目来让LauncherX决定何时启用大文件分片下载. ::: 使用大文件分片下载: 开关 | 默认: 开 | 条件性开关 :::info 当上一个开关为启用状态时，此开关启用，并不允许切换其状态. 大文件分片下载可以在下载较大的游戏文件时将文件分成几部分进行多线程下载，从而最大化地利用网络资源，提升下载效率. ::: 分片数量: 选择框 | 默认: 16 :::info 可用的数量有: 1，2，4，8，16，32，64，128 使用分片下载时，对单一文件分片的数量。可以理解为这个文件在下载时会被分成多少份，所有分片下载完成后会合并成预期的目标文件。 此选项需要根据电脑性能酌情选择，因为无论是开启多线程下载还是下载完成后在后台合并都需要消耗本地硬件资源。(不过对于现代计算机来说，这些消耗貌似不足一提。) ::: 网络连接测试 :::tip 通过网络连接测试，您可以更好地了解您当前的网络状况，包括延迟，服务器状态等一些基础信息。同时也能帮您排除一些简单故障。 ::: 启动: 按钮 点击以启动网络测试. 关于网络测试的结果，参见: 专题: 检测网络"
  },
  "temp/docs-main/zhCN/lxguide/settings/item/others.html": {
    "href": "temp/docs-main/zhCN/lxguide/settings/item/others.html",
    "title": "其他设置标签页 | Qomicex.Core API文档",
    "summary": "其他设置标签页 :::tip 这里的内容相对而言没那么重要。更新日期: 2025年2月10日. ::: [[toc]] 关于 这里展示了直接参与LauncherX制作的人员名单、工作室简介和开源项目使用列表，以及LauncherX及其相关组件的版本号. 赞助者 :::warning 此条目编辑于2024年2月10日，在可预见的将来，此处的内容很有可能迎来改变。相关阅读: 切换更新通道 ::: 对于LauncherX项目的赞助，目前我们主要依赖爱发电平台。 此页将会展示最近24小时内最新提供赞助的赞助者 (约30位，排名不分先后) 您也可在官网登陆后于 赞助 - 日冕工作室 通过微信或支付宝来向我们打赏。但是您的赞助将会只被我们记在心里(x). 感谢每一位赞助者对LauncherX项目的支持! :::tip 网站中通过微信/支付宝赞助过后，您将自动被赋予使用LauncherX预览通道的资格。而爱发电用户需要在爱发电平台内联系老腊肉，然后提供您注册日冕账号的邮箱，等待他为您开启资格。如果他没回应，或是没有被自动赋予内测资格，您也可加群或向他发邮件来催促. :::"
  },
  "temp/docs-main/zhCN/lxguide/settings/special/check-network.html": {
    "href": "temp/docs-main/zhCN/lxguide/settings/special/check-network.html",
    "title": "检测网络： | Qomicex.Core API文档",
    "summary": "检测网络： 利用 LauncherX 的“网络–>网络连接测试”功能来判断您当前网络环境 LauncherX 在“网络–>网络连接测试”中准备了一套便捷的网络测试工具。您可以使用它并根据它的返回内容来判断游戏相关的网络服务在您当前的互联网环境中的可用性。 [[toc]] 使用 打开 LauncherX 的“设置”，在“网络”选项卡中滚动到页面靠底部的位置，您可以找到“网络连接测试”设置项。点击下方的“启动”按钮，您可以开始一次新的网络测试。 稍后，下列的每一项测试都会有一个结果被展示出来。 返回结果 本段介绍一切可能的返回结果，并解释背后部分可能的的原因。 如下所示，一般而言，每一项的检测结果会直接影响项目展现的颜色。 ::: info （服务稳定）延迟：???ms [超时或出错?次] 这意味着您可以正常访问该服务，但是具体效果仍然视网络性能而定。 ::: ::: warning 服务出现波动，可能会出现暂时性的服务中断，或是由于您本地的网络问题导致丢包严重。 这意味着您有可能会无法访问该服务。如果您无法进一步优化网络环境，则请多一些重试的耐心。 ::: ::: danger 服务出错，目前已停止提供服务，或是由于您本地网络的原因导致无法成功与服务器通讯。 在测试中许可的重试机会次数范围内没有一次是成功连接上该服务的，这意味着如果您必须使用该服务的话，您将必须为此优化您的网络连接。 ::: 测试条目 这里的内容随时可能会变更。一般会在 LauncherX 具体的内容出现更新后的第一时间内出现修改。 截止到2023年11月28日，LauncherX 会对以下服务进行测试，包括但不限于来自游戏官方的服务和我们的服务、第三方提供的服务等。 corona.studio：这是我们的官网。 api.corona.studio：这是我们的服务接口地址。它提供了这些服务：日冕账户登录、权限认证、联机建立、新闻信息获取（部分）、检查更新。 minecraft.net：这是 Minecraft 官网。它可能主动屏蔽了检测信号从而显示为“服务出错”。 session.minecraft.net：这是用于登陆验证的 account.mojang.com：这是提供 Mojang 账号管理的地址。在使用 Microsoft 账户登陆的今天显得没那么必要了。 authserver.mojang.com：这是 Mojang 用于正版登陆账号验证的服务。在尝试登入开启正版验证的服务器时，服务器会与之建立连接并查询您的登录信息。这意味着您首先得能与其建立连接并获取一个有效的会话。相关参考文章：解决“无效的会话”问题 sessionserver.mojang.com：同上，这是用于鉴定您是否是正版玩家的服务。 api.mojang.com：这里提供了一系列 Mojang 官方的服务，包括您的正版账户的UUID等信息。 textures.minecraft.net：这里保存着您正版账户的皮肤，用于我们 “游戏帐户管理” 中的 “皮肤预览” 和 “游戏帐户头像” 。 mojang.com：这是 Mojang 的官网。 resources.download.minecraft.net：这是 Minecraft 官方的资源下载服务，如果您无法访问该服务，请尝试在下载游戏资源时候让 LauncherX 自动选择下载服务器或选用另外两个镜像下载服务。相关参考文章：LauncherX设置 分类：“网络” libraries.minecraft.net：同上。 launchermeta.mojang.com：保存了一些启动器必须的游戏信息，在安装新游戏的时候会需要它。 bmclapi2.bangbang93.com：由 bangbang93 提供的游戏资源下载服务。如果您在中国大陆境外，则可能无法访问此服务。虽然与我们关系不大，但是您可以考虑为了这个公益性质的下载服务存活并变得更好而赞助BMCLAPI download.mcbbs.net：由MCBBS提供的游戏资源下载服务。他们貌似也默认屏蔽了除了中国大陆以外的所有连接。 addons-ecs.forgesvc.net：这是 CurseForge API，用于下载和安装 Mod（也用于CF格式的整合包安装）。相关参考文章：安装整合包到游戏目录 弃用的检测项 暂无 勘误 ::: details 暂无 :::"
  },
  "temp/docs-main/zhCN/lxguide/settings/special/customize-launcher.html": {
    "href": "temp/docs-main/zhCN/lxguide/settings/special/customize-launcher.html",
    "title": "关于个性化LauncherX外观的一些提示 | Qomicex.Core API文档",
    "summary": "关于个性化LauncherX外观的一些提示 ::: tip 遇到个性化问题了吗？ 背景图片换上之后，按钮难以看到？还是一通操作之后发现自己的个性化方案性能开销过大？这里将 就当前（2024年7月24日） LauncherX存在的一些个性化上可能有点难以理解的问题进行解答。 ::: [[toc]] 背景图片导致的问题 背景图片可能导致窗口内部分组件辨识度变差。您可以依照以下思路寻求最优解： 【设置-外观-基础设定】禁用 “在主界面隐藏底部导航条”：以确保导航条的内容的可见度 【设置-外观-基础设定】尝试更多 “主界面前景文字颜色” 的选择：不同颜色的文字可能在启用背景时有更好的效果，自动选择可能不总是最优选择。 【设置-外观-背景】启用 “通过渐进式模糊优化上层文字显示效果”：将会在图片上应用一种模糊效果，借助模糊来衬托文字和其他元素。 【设置-外观-背景】尝试更多 “渐进式模糊效果强度” 的选择：调整这项设置以期寻求最佳的背景图片与主界面元素之间的平衡。 【设置-外观-背景】启用 “显示上层文字阴影”：尝试启用或禁用此项来调整文字自身的显示效果 【在其他图片调整软件中】调整图片的饱和度、亮度、对比度等参数：从根本上解决问题。毕竟并不是所有图片在一开始都是适合作为背景的。 记得做好备份。 半透明类背景导致的问题 ::: warning 关于Mica材质背景 这种背景也算是一种半透明背景，但是仅在Windows11上可用。 ::: 半透明背景由于涉及实时计算，故可能存在以下问题： 可能需要有兼容的显卡驱动以供功能正常可用 如果频繁变更LauncherX窗口的位置或其背后的显示内容，将会额外增加不少的系统资源占用。 此外，在进行截图的时候，请留意半透明背景后方是否包含敏感信息。 渐进式模糊性能问题 1) 渐进式模糊不生效 前往【设置-外观-性能】，找到 “清理渐进式模糊缓存”，点击重置，然后尝试重启LauncherX 2) 渐进式模糊性能太差或模糊质量太低 前往【设置-外观-性能】，找到 “背景图片渐进式模糊质量”，选择更高或更低的选择，然后如有必要的话，重启LauncherX 透视效果和动画效果性能问题 若您的电脑在渲染动画时候较为吃力，可以依照现实情况尝试以下操作： 【在系统电源设置中】关闭省电模式：省电模式将会降低电脑的性能 【在电脑的固件设置中】尝试提升CPU和GPU的频率：通过 “超频” 行为，更高的频率会在一定程度上优化渲染效果和速度 ::: danger 危险！这么做的话，您应该知道您自己在做什么 超频行为可能会导致您的硬件保修失效，或是给电脑稳定性造成负面影响，甚至造成硬件损坏。这些都属于您的个人行为，您完全没必要这么做，因而您的个人行为造成的任何损失均不由我们负责。 ::: 【关闭动画】关闭动画：如果您不需要LauncherX动画可以将其关闭。参考：禁用动画 | 日冕知识库 【其他】尝试更新显卡驱动：可能新的显卡驱动包含动画渲染方面的优化 【其他】升级硬件配置：如果可以的话。"
  },
  "temp/docs-main/zhCN/lxguide/settings/special/independent-config.html": {
    "href": "temp/docs-main/zhCN/lxguide/settings/special/independent-config.html",
    "title": "版本隔离与独立设置 | Qomicex.Core API文档",
    "summary": "版本隔离与独立设置 :::warning LauncherX是强制版本隔离的，这意味着LauncherX不能直接地完整支持“非版本隔离”的游戏目录. ::: 您下载、导入或安装的每一个独立的游戏版本都可以被专门进行设置。比如指定其使用特定的JRE，或者指定特别的启动参数. 在「游戏列表」中，您可以点击列表中任意一个代表游戏的项目，LauncherX将在主窗口的右侧抽出对应的具体设置界面。您可以像在全局设置中一样设置仅对这个游戏生效的设置项。记得点右上角的保存。独立的设置将针对这个游戏覆盖默认的全局设置."
  },
  "temp/docs-main/zhCN/lxguide/settings/special/index.html": {
    "href": "temp/docs-main/zhCN/lxguide/settings/special/index.html",
    "title": "| Qomicex.Core API文档",
    "summary": "专题 详细而言，专题会指引您完成比较曲折的操作。比如，调整启动器的整体外观到您中意的风格，或者结合“固定启动账户”和“游戏账户管理”来使您可以快速使用常用的账户启动游戏。 不过，想必您在阅读理解了分类板块之后，能够充分地发挥您的主观能动性并且玩出我们或许也未曾设想的花样。我们期待您能够深入地体验我们的产品！"
  },
  "temp/docs-main/zhCN/lxguide/settings/special/linux-as-others.html": {
    "href": "temp/docs-main/zhCN/lxguide/settings/special/linux-as-others.html",
    "title": "Linux：干掉标题栏，还我一致感 | Qomicex.Core API文档",
    "summary": "Linux：干掉标题栏，还我一致感 不知道诸位Linux用户是否遇到过这样的烦人场景： 本来是希望LauncherX在Linux上也是简洁美观的，结果一打开发现窗口顶部有一个可憎的标题栏，盘踞在那里，破坏着LauncherX天生的和谐感？ 抑或是打开LauncherX发现没有最小化、最大化、关闭 这三个按钮？ 不要急！本文将给您一个“恢复LauncherX美貌”的方法。 [[toc]] ::: info 先决条件 您正在使用Wayland作为显示服务器。参见：针对 Linux 系统的特殊设置 | 日冕知识库 的最后一段 您已经将LauncherX更新到最新版本 ::: 接下来以Manjaro KDE Plasma Wayland为基础示范如何让Linux上的LauncherX看起来和其他平台（Windows，macOS）一样。 启动LauncherX，前往设置 -> 外观 -> 基础设定，找到主界面按钮组可见性 或 窗口按钮组可见性 设置项； 【自动】将根据系统环境来判断是否应该显示按钮组。这个功能较为实验性，您可以考虑将其设置为“可见”： 如果此时LauncherX存在系统给与的标题栏，请右键点击它，然后点击“配置特殊应用程序设置”： 不要点击“无标题栏和边框”，因为这个设置在重启后就不会再生效了。 按照下图进行配置： “外观和修正” 下方的 “无标题栏和边框” 需要先点击下方的 “添加属性” 来添加，然后如图配置。 点击底部的 “应用” 和 “确定”，如果需要的话，请重启LauncherX。 一切顺利的话，您的LauncherX将可以是这个样子： 开始享用吧！"
  },
  "temp/docs-main/zhCN/lxguide/settings/special/manage-accounts.html": {
    "href": "temp/docs-main/zhCN/lxguide/settings/special/manage-accounts.html",
    "title": "管理账户 | Qomicex.Core API文档",
    "summary": "管理账户 LauncherX提供一个完善的账户管理。 [[toc]] ::: tip 主页的管理账户入口 在主页，至少有一个一步前往“账户管理”界面的入口，就是在底部的导航栏上，一般显示着“本地账户管理”或“账户管理”，但是如果您登陆了日冕账户，此处将会显示您的日冕账户用户名。 ::: 游戏账户 您的游戏账户是启动游戏后在游戏中代表您的身份标识。可以认为这就是玩家名，或者称之为ID。 您在初次设置LauncherX的时候便会有一个提示您添加账户的地方。实际上，在完成初次设置后，点击【账户管理】按钮，仍然可以进行添加、预览皮肤、删除、刷新、固定（如果开启了账户固定）账户的操作。以下是以初次设置游戏账户的示例。 注意 在本段中,我们建议您优先使用来自微软官方的Microsoft帐户登录您的Minecraft。虽然官方并未明确其对离线模式等无正版验证的游戏的反对态度，但我们仍然建议您通过购买Minecraft来支持和维护知识产权. 本文将指导您使用LauncherX在初次使用和后续使用中添加 仅本地可用的 游戏账户，包括以下类型: Microsoft 账户 离线模式账户 AuthLib 帐户（原 Mojang 账户登录） 由于官方已经停止对 Mojang 帐户的支持并开始迁移 Mojang 帐户到 Microsoft 帐户，故 LauncherX 将不再支持 Mojang 帐户登录。详情: Mojang Java 版 Minecraft 帐户移动 | Minecraft 初次设置 初次使用 LauncherX 时，您会看到 LauncherX 在向您打招呼之后要求您进行一些使用 LauncherX 必要的初始设置。在到达“添加账户”这一步时，您可以选择以下一个操作进行。点击“添加”按钮来开始. =Microsoft帐户登录 点击弹出窗口中的“Microsoft帐户”按钮，LauncherX将会弹出一个包含验证链接、一次性验证代码和些许按钮的置顶窗口 ( 验证信息窗口 ). 整个流程大约10秒即可完成 (受网络性能和您的浏览器是否保存了您的微软账户登录信息影响，这可能会有些许延长)。 考虑到微软的隐私策略，我们建议您在 3 分钟内完成这个流程，以免一次性验证代码失效。若一次性代码失效，您需要关闭当前的验证信息窗口并重复添加微软账户的操作. 点击“复制代码”，即可把您本次登录所需要使用的一次性代码复制到剪贴板。 相关阅读：[Microsoft]Windows10+内置剪贴板提示 点击“打开验证页面”，将会通过您的默认浏览器打开微软账户的验证页面. 将您复制的一次性代码按网页提示粘贴到指定的位置。如果微软要求您登录，请先在网页中登录您的微软账户. 弹出此窗口后，您需要“同意”以继续添加账户的操作. 在 LauncherX 验证账户过程中，您可以继续进行下一步设置。 如果您认为验证过程太慢或失败，请考虑优化您当前的网络环境 (比如，使用针对 Xbox 登录的加速器或尝试离您的无线网络源近一些，如果您在使用的无线网络的话。) 意外情况: Edge浏览器弹出需要安全验证设备: 对于这种情况，您需要: 点击“取消” 在网页中点击“其他登录方法”,如图： 点击“使用我的密码”，或者选择任意您方便使用的登录方法 =离线模式 这可以说是最简单的账户添加方法。您可以用 LauncherX 为您的本地游戏开启自定义皮肤，这个功能只会对您的本地客户端生效。 参见: 游戏账户管理/皮肤预览 点击“离线账户” 输入任意您想要的玩家名。注意，有些版本 ( 尤其是较老的版本 ) 不支持中文 ID。 离线模式只能供您游玩本地游戏和支持离线登入的服务器。 =AuthLib（外置登录） 借助 AuthLib-Injector，使用特殊的登录验证服务。在选择这一项登录之前，您应该确认您有来自某一方的 AuthLib 外置登录服务。 为此，您需要准备: 外置登录验证电子邮箱 对应的密码 对应验证服务的 AuthLib 服务器地址 (这对于外置登录是必须的，因为 LauncherX 不知道您需要向谁的 Yggdrasil API 进行验证。通常，这个地址类似 “https://<服务提供商的域名>/api/yggdrasil”) ::: info 快捷填入内容 服务提供商或许会需要您将一个按钮拖入到启动器，LauncherX支持直接拖入到第三个输入框。 ::: 点击“外置登录（Mojang）”以开始。 弹出如图所示的窗口: 对应输入先前您应该准备好的信息（AuthLib服务器栏支持拖入链接） 保存账户。这些信息将加密后作为凭证，在您登录支持对应的AuthLib服务的服务器后用于验证。 后续添加 在完成初次设置后，您可以进入 设置-账户，添加更多的游戏账户。 点击“添加账户”之后，一切操作与您在初次设置 LauncherX 时候完全一致。我们建议您在添加了微软账户后对应的添加一个相同ID的离线账户，以避免部分游戏在联网或未联网情况下无法启动的问题。 日冕账户 日冕账户是我们（日冕工作室）在为您提供服务时对您进行识别的凭证。LauncherX的仪表板、联机、参与测试等功能均需要登陆日冕账户。 对账户绑定设备等具体管理，请访问：登录到服务 (corona.studio) 登陆后进行管理。"
  },
  "temp/docs-main/zhCN/lxguide/startup/index.html": {
    "href": "temp/docs-main/zhCN/lxguide/startup/index.html",
    "title": "开始 | Qomicex.Core API文档",
    "summary": "开始 欢迎使用LauncherX！我们不断致力于为您打造美观便捷的使用体验。 [[toc]] 本文创建日期：2023年7月14日，修改日期：2024年3月6日，作者：Feiron Iguista ::: warning 请注意：LauncherX不在任何一个平台上支持32位或更低的操作系统。 ::: 环境要求 基本上，对于所有的桌面环境，前置条件基本上是一致的。 首先，为了能够让LauncherX稳定地大展拳脚，您的电脑需要满足以下条件: 软件要求 Windows7及更新版本的64位操作系统、Windows 10 或更新版本的 for ARM 64位操作系统 或 macOS 12 及更新版本 (基于Intel芯片或Apple芯片) 或 带有Xfce/GNOME之类桌面环境的Linux 64位操作系统 (建议内核版本高于5). 硬件要求 CPU: 主频高于2.5GHz的至少4核心64位处理器 (amd64/ARM64/x86-64) 运行内存: 不少于4GB GPU: 建议性能高于: Intel UHD 770 (集成显卡) / 建议性能高于: Radeon RX560 存储空间: 预留100MB (Windows: ~30MB，Linux和macOS: ~60MB。预留更多空间以供下载等缓存使用。实际上安装游戏需要为游戏预留一定空间。) 下载LauncherX 接下来，该下载LauncherX了: 我们推荐优先使用包含运行时的独立版。请前往官网下载稳定版，或赞助我们以取得测试版； 或者在我们的配置助手发布后，使用配置助手来为您选择合适的LauncherX。这将是最适合普通用户的方案（敬请期待）。 下载LauncherX的一般流程如下： 打开官网 一般而言，网页会根据你的电脑来推荐下载的版本。你需要下载对应你电脑系统和CPU架构的版本，如果网页选择了和你电脑情况不一致的版本，请用下载按钮右侧的三角按钮（如果是MIN站 ，直接在网页上点击对应正确构建的按钮来开始下载）来选择正确对应你电脑的选项。如果你不知道如何确认你的电脑系统版本和CPU架构，参见：辨识计算机环境 | 日冕知识库 :::tip 截至目前，大多数用户使用的是Windows x64。 下载完毕后，将LauncherX解压并放置到一个合适的地方。 :::tip 关于存放位置 macOS建议放在【应用程序】(也就是说Applications) 目录下; Linux可以放在任何你常用于存放程序的地方，Windows同样，但是不要放在桌面或其他难以打理的地方，最好放在一个空文件夹里，因为Windows版LauncherX会在当前所在位置解压出自己的工作目录和默认的游戏文件夹。 Linux和macOS版本的LauncherX会在一个合适的地方存储LauncherX的配置文件和默认游戏目录，电脑上任意地方的LauncherX将共用该配置文件；Windows版本则会在每个LauncherX所在的位置创建独立的默认游戏目录和配置文件。 ::: 开始使用LauncherX 那么现在，无论是Windows，macOS还是Linux某个带桌面环境的发行版，也无论架构是x86-64，x86-S，amd64还是ARM64，您已经根据当前操作系统下载好了对应的LauncherX到您希望其所运行的文件夹中。那么您就可以像运行其他程序一样双击它的图标来运行了。 接下来，面对所有已知可能出现的问题，您都可以在此系列文档的【初次启动】部分 (按操作系统不同分成三篇) 找到说明并了解可能的解决方法。 ::: info 由于设备不同，您在初次启动时可能会遇到些小麻烦，为此我们感到十分抱歉。我们正在努力解决这些严重影响体验的问题，因而本文将会不定期发生变更，恕不另行通知。 如果需要提供反馈，请参考：报告异常&建言新策 | 日冕知识库 ::: 共有的问题 由于我们的Java运行时检测机制是通过 “搜索-执行” 模式工作以确认该运行时是否可用，所以在您启动LauncherX时候，可能会遇到来自Java的错误弹窗。您完全可以直接将它关闭，因为这并不影响LauncherX运行; 且如果您没有选择任何一个被LauncherX判断为有问题的JRE作为游戏启动所使用的Java，那么您的游戏启动几乎不可能受到受损JRE的影响。由于每次LauncherX启动都会检查搜索到的JRE是否可用，因此您应该将该受损的运行时移除，或者用自动化窗口关闭工具（比如 火绒弹窗拦截）对错误弹窗进行精准打击。 下一步 假设您的LauncherX现在能正常运行，但是您不知道接下来该做什么？参考：安装游戏 | 日冕知识库，下载并安装您的游戏。 在提问前应该先在本站查阅，对于一些常见问题，我们时常会更新这篇文章：常见问题 | 日冕知识库 已经加入了内部测试？参考：切换更新通道 | 日冕知识库"
  },
  "temp/docs-main/zhCN/lxguide/startup/others/Linux-Guide.html": {
    "href": "temp/docs-main/zhCN/lxguide/startup/others/Linux-Guide.html",
    "title": "Linux中LauncherX的配置指南 | Qomicex.Core API文档",
    "summary": "Linux中LauncherX的配置指南 LauncherX是一款新生的MC启动器 当它正式发布时，就成为了Linux上为数不多能愉快使用的MC启动器 不过别慌，本文章就是为了讲解如何配置LauncherX而生 接下来，让我们开始配置吧！ 如何下载？ 先更新系统 然后前往Corona Studios官方网址下载 下载完的文件应该叫\"net9.0-linux.linux-x64.zip\" 解压，你会获得一个名为“LauncherX.Avalonia\"的文件 如何打开？ 将LauncherX.Avalonia文件移动到你想要放置的地方 这里我建议放在/home下的一个不经常修改文件的文件夹，以便后面的工作易于进行，至于是什么嘛，猜去吧 然后在文件管理器中右键选择打开命令行，或者打开命令行并cd到lx的文件所在目录 输入： ./LauncherX.Avalonia 认为每次都要这么启动很麻烦？那快点往下看吧 当你看到如下页面时，说明你成功运行了LauncherX 如何配置？ 接下来，配置你需要的外观，登录你需要登录的账户，未登录不可进入 :red_circle:请注意: 目前Linux稳定版有一个右键点击账户就会闪退的Bug，内测版已经修复，但截止于2025.06.09前稳定版暂未修复 接下来就是要玩MC最重要的部分了： 配置JVM运行环境 在你登录好账户后，LauncherX会显示一个配置界面： 这里有两种下载Java并配置的方法 如果安装了Java，且LauncherX检测到了你的Java，那么可以跳过 一.使用包管理器安装 sudo pacman -Sy jdk-openjdk //Arch系，Pacman会为你配置好一切 sudo dnf install java-latest-openjdk.x86_64 //RPM系，需要配置环境变量 sudo apt install openjdk-21-jdk //Deb系，需要较新系统，较老的请使用第二种方法 这里我建议用较新版Java，如果想要游玩老版本MC，或想要稳定，请选择其他Jdk包 如若无法使用上面的命令下载，请使用第二种方法 RPM系和DEB系下载完后请看这里： 配置Java环境变量： 将下面的环境变量加入.bashrc或.zshrc等shell配置文件 export JAVA_HOME=/usr/lib/jvm/java-21-openjdk export PATH=$JAVA_HOME/bin:$PATH export JAVA_TOOL_OPTIONS=\"-Dfile.encoding=UTF-8\" 其中java-21-openjdk可修改为自己安装的JDK版本 然后重启电脑或在终端中运行： source ~/.bashrc //bash用户运行这个 source ~/.zshrc //zsh用户运行这个 二.使用LauncherX下载 在全局游戏设置界面，点击下载Java，选择你需要的版本，点击下载 LauncherX会用最快的速度为你下载并配置好Java 当你配置完JVM运行环境时，选择是否遥测之后，如果显示出如下界面，那你就就把基本准备工作做完了 Tips点不掉吗？重启启动器就消失了 现在就可以下载游戏啦 若在下载阶段出现问题，任务中心报错 那么点击设置，选择网络，将多重源补全关闭，将mojang官方服务器更换为TapXapi 刚才说的工作马上就来 创建.desktop文件（按需） 创建LauncherX.desktop文件，使用Kate或Vim等文本编辑软件编辑该文件，并把下面对应的部分粘贴进文件 （文件中的路径需要填写自己的LauncherX所在路径和图片文件所在路径） LauncherX启动器图标在这里，请自行下载（如不需要请将下面的Desktop中的Icon留空） 悠闲的Intel显卡和AMD显卡用户： [Desktop Entry] Name=LaucherX Version=1.0 Exec=/LauncherX所在路径/LauncherX.Avalonia Icon=/LauncherX的启动器图标所在路径/启动器图标文件 Type=Application Terminal=false Categories=Minecraft;Application; 被万恶的NVIDIA显卡毒害的用户（NVIDIA Fuck YOU！！）： [Desktop Entry] Name=LaucherX Version=1.0 __NV_PRIME_RENDER_OFFLOAD=1 __GLX_VENDOR_LIBRARY_NAME=nvidia Exec=/LauncherX所在路径/LauncherX.Avalonia Icon=/LauncherX的启动器图标所在路径/启动器图标文件 Type=Application Terminal=false Categories=Minecraft;Application; 保存，然后在文件管理器中右键选择打开命令行，或者打开命令行并cd到desktop文件的所在目录，然后输入： sudo mv LauncherX.desktop /usr/share/applications 温馨提醒：LauncherX在Linux系统下是手动覆盖更新的，请每次更新都放在同一个文件夹，不然会导致Desktop文件失效 这样，你就可以通过应用程序菜单进行打开LauncherX的操作了 到这里，你的LauncherX启动器已经可以正常使用了 在wayland中使用LauncherX，并需要使用输入法？ 如果配置了全局环境变量，请略过 创建完LauncherX.desktop文件后，在其中的Exec行加入 env XMODIFIERS=@im=fcitx //fcitx用户 env XMODIFIERS=@im=ibus //ibus用户 请务必加空格后再复制 使用AUR安装LauncherX（Arch Linux用户可选） 除了手动安装，你也可以选择AUR仓库进行安装 paru -Sy launcherx-bin （不过我本人并不建议使用AUR包，更新比官方更新稍慢，不易修复已知Bug） 结语 我个人觉得在Linux发行版中使用LauncherX十分容易 所以，愉快的去游戏吧！"
  },
  "temp/docs-main/zhCN/lxguide/startup/others/index.html": {
    "href": "temp/docs-main/zhCN/lxguide/startup/others/index.html",
    "title": "其他 | Qomicex.Core API文档",
    "summary": "其他 这部分存储了一些针对特殊问题的特殊声明..."
  },
  "temp/docs-main/zhCN/lxguide/startup/others/win7.html": {
    "href": "temp/docs-main/zhCN/lxguide/startup/others/win7.html",
    "title": "Windows 7 用户指南 | Qomicex.Core API文档",
    "summary": "Windows 7 用户指南 LauncherX宣称支持Windows7, 但是截至目前(2025年) Windows7已经是快要有20年历史的操作系统了. 随着LauncherX框架的不断迭代, 对Windows7的支持随时可能终止 (确认不再支持后, 这里将会有明显提示) ———— 接下来的操作指导是基于一个全新安装的Windows7 Ultimate探索而来. 部分需要手动下载和依赖的下载链接也可能随时失效. [[toc]] ::: warning 前置条件 LauncherX 仅支持64位操作系统, 因此你的Windows7 必须是64位 非简化版. ::: 做好准备 首先, 你的Windows7设备需要确保有网络连接, 然后准备下载一系列的资源. 以下是需要下载的内容清单和对应的链接. LauncherX 官网下载 下载Windows x64版本 VxKex Github Release 下载Assets部分展示的KexSetup_Release_<版本号>.exe Windows更新补丁 KB2670838 Microsoft Update Catalog 下载标明Windows7、x64的、文件大小为11.3MB的那一项, 点击那一行最右方的Download按钮. Windows更新补丁 KB2533623 Legacy Update 点击页面中的蓝色文字「Windows6.1-KB2533623-x64.msu」下载 Visual C++ 2015运行库 版本14.0.23026 MS VC REDIST 2015 14.0.23026 用于补全MSVCP140.dll. Visual C++ 2015运行库 版本14.42.34438 MS VC REDIST 2015 14.42.34438(下载) 用于补全MSVCP140.dll. (可选) .NET Desktop Runtime 9 (视LauncherX当时使用的.NET版本为准) .NET9 桌面运行时(下载) 开始安装 在进行此部分操作时, 建议关闭电脑上的一切杀毒软件. 为了避免在此期间电脑受到外来攻击, 可以考虑断网. 1) 准备环境容器 双击文件来安装刚才下载好的两个更新补丁. 安装过程不要求重启, 可以安装完全部的两个包后再重启. 重启后, 找到刚才下载好的VxKex安装包, 运行并安装. 执行默认的安装即可. 安装后会要求重启. 再次重启后, 环境容器准备完成. 可以随便找个.exe文件, 右键点击它查看其属性, 若属性选项卡中出现VxKex选项卡即为安装成功. 2) 补全依赖库 ::: info 可能存在重复的步骤 ::: 找到刚才下载的版本号为14.0.23026的VCRedist库, 双击安装; 完成上一步后, 找到另外一个VCRedist库, 双击安装; 刚才如果下载了.NET桌面运行时, 将其安装. 重启电脑. 3) 应用变更 接下来, 将LauncherX放在一个 非C盘根目录的, 且不是桌面的空文件夹中, 然后右键点击它, 点击属性, 然后点击VxKex选项卡, 勾选“Enable VxKex for this Program”, 然后点击应用并关闭属性窗口. 理论上, 此时已经可以正常使用95%的LauncherX功能了. 双击LauncherX, 尝试运行. 如果仍然有问题, 参阅: 如何反馈问题. 可能的问题 已知在Windows7中运行LauncherX会遇到以下问题: 卡在「正在自动登陆」: 这是未正确启用VxKex导致的, 实际错误是无法使用Windows7还不支持的Win32 API来初始化联网操作. 下载Java闪退: 暂时不明确哪部分不工作, 建议自行下载Azul Zulu以避开此问题. 参阅: 如何下载JRE 无法获取游戏列表: 请尝试切换到其他下载源并关闭混合源补全."
  },
  "temp/docs-main/zhCN/lxguide/startup/perOsSetup/linux.html": {
    "href": "temp/docs-main/zhCN/lxguide/startup/perOsSetup/linux.html",
    "title": "针对 Linux 系统的特殊设置 | Qomicex.Core API文档",
    "summary": "针对 Linux 系统的特殊设置 [[toc]] 对于基于 ARM64 架构的 Linux 发行版 ::: warning 由于 Mojang 官方还并未正式支持 ARM64 版本的 Linux 游戏。 因此，在使用 LauncherX 之前，您需要手动下载并安装 JRE 运行时。 ::: 下载并安装 JRE 运行时 在这里我们将使用 Azul JDK 来演示 JRE 的安装。 在 Azul JDK 官方网站 中，稍微下拉一点即可看到 JDK 版本筛选框： 在 Operating System 处选择 Linux，在 Architecture 处选择 ARM 64-bit 即可获取到所有可用的 JDK 版本。 在右侧的 Download 按钮中选择 .tar.gz 格式的 JDK 运行时，下载后将其解压到任意一处本地文件夹。 随后在 LauncherX 中选择 手动添加，并选择 JDK 文件夹 bin/ 目录下的 java 可执行文件即可。 有关于JRE的选择，参见: 配置内存和GC、JavaAgent 如果您无法启动 您需要尝试做出以下操作： 打开新的终端，或者使用刚才出现的终端 在其中键入 export LC_CTYPE=en_US.UTF-8，执行 （如果有必要的话，上述步骤可以使用管理员权限[sudo]） 再次尝试运行。如果失败，尝试重新登录。 如果再次失败，请务必依照 这里的方法 向我们反馈。 :::tip 这个问题可能已经在正式发布的稳定版中解决了. ::: 其他建议 若您需要其他更加详细的配置，或者纯小白用户，建议阅读：Linux配置指南 专项：Linux需要其他平台一样的UI外观！如何移除掉丑陋的标题栏并保持窗口按钮：Linux：干掉标题栏，还我一致感 | 日冕知识库"
  },
  "temp/docs-main/zhCN/lxguide/startup/perOsSetup/macOS.html": {
    "href": "temp/docs-main/zhCN/lxguide/startup/perOsSetup/macOS.html",
    "title": "针对 macOS 系统的特殊设置 | Qomicex.Core API文档",
    "summary": "针对 macOS 系统的特殊设置 一般问题 对于 macOS 用户，若您在打开 LauncherX 时候出现“已损坏”相关的错误弹窗，请执行以下操作： 打开 “终端.app” 打开您的访达窗口，并找您的LauncherX执行文件 (LauncherX.app 或 LauncherX.Avalonia.app) 在终端输入 sudo xattr -d com.apple.quarantine 或者 sudo xattr -cr (任选其一即可) 在上述指令末尾有一个空格的前提下，将您的 LauncherX APP 拖入到终端窗口 运行。终端将会要求您输入管理员账户的密码。请凭感觉如实输入，终端不会在显示区域呈现您任何的输入记录 在键入密码之后按下键盘上的 Enter 确认，执行成功不会有任何提示。 然后再次尝试启动 LauncherX，如果再次失败，请务必向我们反馈。 对于基于 ARM64 架构的macOS ::: warning 由于 Mojang 官方还并未正式支持 ARM64 版本的 macOS 游戏与对应的JRE下载， 因此，在使用 LauncherX 之前，您需要手动下载并安装 JRE 运行时。 ::: 下载并安装 JRE 运行时 在这里我们将使用 Azul JDK 来演示 JRE 的安装。 在 Azul JDK 官方网站 中，稍微下拉一点即可看到 JDK 版本筛选框： 在 Operating System 处选择 macOS，在 Architecture 处选择 ARM 64-bit 即可获取到所有可用的 JDK 版本。 在右侧的 Download 按钮中选择 .zip 格式的 JDK 运行时，下载后将其解压到任意一处本地文件夹。 随后在 LauncherX 中选择 手动添加，并选择 JDK 文件夹 bin/ 目录下的 java 可执行文件即可。 有关于JRE的选择，参见: 配置内存和GC、JavaAgent"
  },
  "temp/docs-main/zhCN/lxguide/startup/perOsSetup/windows.html": {
    "href": "temp/docs-main/zhCN/lxguide/startup/perOsSetup/windows.html",
    "title": "针对 Windows 系统的特殊设置 | Qomicex.Core API文档",
    "summary": "针对 Windows 系统的特殊设置 ::: warning 请注意， LauncherX 不支持 Windows7以下版本的操作系统，以及任意一个版本的Windows S。 对Windows7的支持可能随时终止. 如果您使用Windows7, 请尽早升级, 或阅读Windows7 安装指南... ::: 目前，您不需要进行任何额外配置即可使用 LauncherX 启动器的全部功能。 …但是您可能会遇到一些意外，如图所示： 类似于这样的弹窗——会要求您先在Microsoft Store下载安装“供任务执行的程序”，或者由 SmartScreen 弹出的“警示安全风险”的提示弹窗： 请将其关闭，并且执行以下步骤（或者, 对于SmartScreen的弹窗提示, 点击“更多选项”, 然后点击“继续运行”，跳过后续步骤并再次尝试启动 LauncherX）： 右键单击您的 LauncherX 可执行文件 点击“属性” 找到如图中标记出的勾选框并将其勾选: （图片中借用Everything刚从网上下载时的“属性”窗口为示范。） 点击“应用”，然后关闭“属性”窗口。 尝试启动 LauncherX 。如果仍然无法工作，请与我们取得联系 ::: warning 如果在尝试启动 LauncherX 时候出现了来自其他安全类软件的警告，那么您需要允许 LauncherX 运行以使用 LauncherX 。若您对 LauncherX 持有怀疑，可以前往VirusTotal这种权威的线上沙盒并将您下载的 LauncherX 副本上传检测。 ::: 对于Windows7 我们预计将在Windows10被微软结束支持后，原则上不再为新功能在Windows7的可用性作担保；同样的，在此发生的一年后，原则上不再为新功能在Windows8/8.1上的可用性作担保。但是理论上，只要系统框架允许，LauncherX将一直能在Windows7及更高版本的Windows中可用，只是可能不能完全按照预期工作，以及可能需要安装额外的支持性软件和运行时。 比如我们在测试过程中发现，LauncherX若需要在Windows10以前的系统上运行，可能需要自行安装一些支持库, 以及某个或某些特定的Windows更新包 (KB3118401)。 Windows7：查看环境安装引导 Windows8/8.1：Download Update for Windows 8.1 for x64-based Systems (KB3118401) from Official Microsoft Download Center 再次声明：LauncherX仅支持64位操作系统，因而在上方的链接里，所指向的均为适用于64位操作系统的更新安装包。 安装后，如果有必要的话，请尝试重启电脑以让更新内容完全生效。"
  },
  "temp/docs-main/zhCN/lxguide/ui-guide/0_interface.html": {
    "href": "temp/docs-main/zhCN/lxguide/ui-guide/0_interface.html",
    "title": "| Qomicex.Core API文档",
    "summary": ""
  },
  "temp/docs-main/zhCN/lxguide/ui-guide/1_gamelist.html": {
    "href": "temp/docs-main/zhCN/lxguide/ui-guide/1_gamelist.html",
    "title": "| Qomicex.Core API文档",
    "summary": ""
  },
  "temp/docs-main/zhCN/lxguide/ui-guide/2_download.html": {
    "href": "temp/docs-main/zhCN/lxguide/ui-guide/2_download.html",
    "title": "| Qomicex.Core API文档",
    "summary": ""
  },
  "temp/docs-main/zhCN/lxguide/ui-guide/3_settings_localAccounts.html": {
    "href": "temp/docs-main/zhCN/lxguide/ui-guide/3_settings_localAccounts.html",
    "title": "| Qomicex.Core API文档",
    "summary": ""
  },
  "temp/docs-main/zhCN/lxguide/ui-guide/index.html": {
    "href": "temp/docs-main/zhCN/lxguide/ui-guide/index.html",
    "title": "| Qomicex.Core API文档",
    "summary": "/"
  },
  "temp/docs-main/zhCN/mc-starter/advanced/analyze-exception/1_environment.html": {
    "href": "temp/docs-main/zhCN/mc-starter/advanced/analyze-exception/1_environment.html",
    "title": "Java Edition | 如何分析游戏崩溃问题 - 1: 游戏前检查 | Qomicex.Core API文档",
    "summary": "Java Edition | 如何分析游戏崩溃问题 - 1: 游戏前检查 :::warning 转载文章 本文是转载文章，经过CSKB编辑细微修改后发布于此。如果你觉得这篇文章不错并想要引用或转载，请根据这些信息联系原作者。 原作者：Kamihakuyie 引用链接：腾讯频道 - Kamihakuyie 的帖子 转载信息上次更新于 2025年1月14日 ::: [[toc]] //Preface - 前话 Minecraft Java Edition作为一个较大的Java依赖性软件，在进行游戏时，玩家们时常会碰到启动游戏时闪退、卡死等问题，而问题的形式种类繁多，有些问题解决起来极不容易。 对此，我根据自身理论知识以及部分解决游戏崩溃问题的实践经验逐步教会大家通过游戏前的检查以及对游戏崩溃日志的分析解决启动游戏时的问题，尽我所能帮助你成功启动游戏。 此外，由于本人专业知识有所不足，只提供力所能及的帮助以及建议方案，若碰到无法解决的问题烦请谅解！ //Body Part1 - 正文1：Java环境问题检查 ① 版本对应 我们已经知道Minecraft Java Edition依赖JAVA运行，而不同minecraft版本所选用的JAVA版本也有所不同，那么我们最开始要做的，便是检查系统中Java环境与minecraft版本是否对应，以下是各版本对应的JAVA版本(1)： 从1.12（17w13a） 开始，运行Minecraft的最低要求是Java 8 从1.17（21w19a） 开始，运行Minecraft的最低要求是Java 16 从1.18（1.18-pre2） 开始，运行Minecraft的最低要求是Java 17 从1.20.5（24w14a） 开始，运行Minecraft的最低要求是Java 21，且操作系统要求为64位 :::tip 搬运补充 如果你不知道你的操作系统和位数，参见：辨识计算机环境 | 日冕知识库 ::: ② 检查版本 那么我们如何检查电脑中的JAVA版本呢？一般采用以下方法： 1、Win+R键，输入cmd后回车 2、输入java --version （此处注意JAVA8以下的老版本用java -version否则报错） 3、出现以下界面即成功 可以看见我的Java为 JRE 1.8.0 Update341 对于Java8，作为长期支持的版本，其一直在更新。每个小更新都通过“1.8.0 Update xxx”来区分。在极端情况下，由于存在差异，不同小更新版本的Java8都可能引发不同的问题。 在pojav与FCL等手机Java启动器中，请借助启动器自行查询Java版本 :::tip 搬运补充 对于现代的启动器，当您电脑中存在对应版本的JRE文件，一般都能做到自动切换。对于LauncherX，我们的自动切换是在发现版本对应有问题时候询问您是继续强制启动或是使用LauncherX判断出最合适的版本。 与此同时，要想查看LauncherX当前选中的Java版本，只需打开【设置-Java虚拟机设定】即可查看。关于这段设置，参见：全局游戏设置 | 日冕知识库 ::: ③ JDK？JRE？ 关于Java，一般我们会碰到JDK与JRE两种 jdk是开发工具，jre则是运行环境，而开发工具自然包含了运行环境 所以实际上两者都能运行Minecraft，最大的差别在于jdk要稍微大些，但是 在JAVA 17 及以上版本中jre兼容性较差，建议使用jdk 此外，Java还存在不同公司的牌子，如Oracle、Bellsoft、Zulu等，但是实际上都差不多 （至少我现在没有分析因为Java牌子问题报错的） ④ 还是崩溃了！ 上述为游戏前检查Java环境，而如果Java环境存在问题导致崩溃，在崩溃日志中（游戏所在文件夹的logs里，或使用LauncherX右键点击游戏然后选择【打开-日志】，选择latest.log）你或许会发现以下内容： The requested compatibility level **JAVA_21 could not be set**。Level is not supported by the active JRE or ASM version (**Java 17.0**，ASM 9.6 (ASM10_EXPERIMENTAL)) 【 这是直接告诉你该用Java21而你用的是Java17 】 Error loading class: XXXXX (java.lang.IllegalArgumentException: **Class file major version 65** is not supported by active ASM (version 9.0 **supports class version 61**)，reading XXXXX) 【 这是由于ASM无法读取高版本Java导致的问题，需要切换到低版本Java 】 对于第二个问题，我们可以看到它提示了Class编译版本号，对于MC来说常见的与jdk版本对应如下(2)： Java 8 对应的class文件版本号是52 Java 16 对应的class文件版本号是60 Java 17 对应的class文件版本号是61 Java 21 对应的class文件版本号是65 ⑤ 借助启动器 LauncherX等现代的（反正，就是这几年内更新过的（包括Minecraft官方推出的启动器 —— 这是一定会帮你准备好Java的））Minecraft启动器会提示并帮助你自动下载Java（关于如何使用LauncherX内置的Java下载功能，参见：使用LauncherX下载JRE(仅限Windows)），但当自动下载失效时请手动下载Java，参见：如何手动下载Java环境 //Body Part2 - 正文2：mods及其前置检查 ::: warning 这节内容经过编辑修改 要想阅读原文，参见页首的引用信息。 ::: 一般来说，只有启用相应前置才能启动对应mods （不一般的情况：用sodium以及iris兼容optifine+OptiFabric光影 等）(5) 此外，在进行游戏前检索你所安装mods的冲突关系并且避免之也是一种解决启动问题的重要方式。在LauncherX中下载到游戏的Mod会自动下载依赖，并且你可以在游戏Mod管理和Mod下载界面看到Mod的依赖关系。 //Epilogue - 本篇结语 现在你已经对游戏前必要环境的检查了然于心了，你可以试着启动游戏，如果游戏与模组正常启动，那么恭喜你学会了基本教程。如果游戏依旧崩溃，那也没关系，我们将继续深入学习崩溃日志的阅读理解并解决问题。 此外，本文系我知识、经验与时间的结晶，请尊重他人成果，如有不足之处还烦请补充，十分感谢！ //References - 参考文献 (1) 社区团队 ，Minecraft wiki ， https://zh.minecraft.wiki/w/Java%E7%89%88 (2) lzhfdxhxm ， CSDN ， JDK version和class file version(Class编译版本号)对应关系-CSDN博客 (3) @杉狐， 频道帖子 ， https://pd.qq.com/s/cqw2bzlul?shareSource=5 (4) @SGfannr ， 频道帖子 ，https://pd.qq.com/s/47d19raiu?shareSource=5 (5) Iris Shaders 、Sodium开发团队 ， MC百科 ， github Iris Shaders - MC百科|最大的Minecraft中文MOD百科 (mcmod.cn) CaffeineMC/sodium-fabric: A Fabric mod designed to improve frame rates and reduce micro-stutter (github.com)"
  },
  "temp/docs-main/zhCN/mc-starter/advanced/analyze-exception/index.html": {
    "href": "temp/docs-main/zhCN/mc-starter/advanced/analyze-exception/index.html",
    "title": "专题：游戏崩溃/异常分析 | Qomicex.Core API文档",
    "summary": "专题：游戏崩溃/异常分析 游戏是计算机程序的一种。如果游戏出现了崩溃，那么你可能需要自行分析问题。你可能很会请求其他人的帮助，但是倘若只能靠自己，那么唯一的希望就是自己的能力了。所幸计算机的一切异常都是有迹可循的。手上拿着足够的线索，便能分析出异常的原因，从而解决问题。 本专题包含数篇转载和原创的文章，以及一系列的相关扩展阅读。只要你有激情，有着学习理解的能力，那么你便具备着克服一切困难的能力。 参见：什么是日志？ | 笨蛋 MC 开服教程 | 如何向大佬求助 | 笨蛋 MC 开服教程"
  },
  "temp/docs-main/zhCN/mc-starter/advanced/index.html": {
    "href": "temp/docs-main/zhCN/mc-starter/advanced/index.html",
    "title": "| Qomicex.Core API文档",
    "summary": ""
  },
  "temp/docs-main/zhCN/mc-starter/assets-and-mods.html": {
    "href": "temp/docs-main/zhCN/mc-starter/assets-and-mods.html",
    "title": "| Qomicex.Core API文档",
    "summary": ""
  },
  "temp/docs-main/zhCN/mc-starter/get-minecraft.html": {
    "href": "temp/docs-main/zhCN/mc-starter/get-minecraft.html",
    "title": "获取适合你的Minecraft | Qomicex.Core API文档",
    "summary": "获取适合你的Minecraft ::: info 这是写给完全第一次玩Minecraft的新手的玩家的文章 如果你真心想要了解这个游戏并在这个游戏里取得乐趣，那么请怀揣着一颗主动学习、举一反三的求知之心继续阅读吧! 本文将指引你开启Minecraft之路. 此外，官方也为你的游戏之旅准备了翔实的教程：Minecraft Game Guides | Minecraft Help，还有Minecraft Wiki：中文 Minecraft Wiki 可供查阅。 ::: 前言 由于Minecraft分为多个版本，且都不太一样，本文将指引你找到适合你玩的版本。本文不涉及游戏玩法、机制之类的内容，只是尽可能指引想玩的新手购买、安装、下载，并最终能够玩上Minecraft. 选择版本 那么，选哪个Minecraft可以满足自己的游玩需求呢？ 其实Minecraft有许多不同版本和衍生游戏可供选择。在当下(2024年5月22日)，一般而言，我们讨论的范围仅限于定义在「沙盒游戏」这个领域之内的Minecraft版本，现在仍在维护的仅有两个: Java版(Java Edition) 和 基岩版(Bedrock Edition)。除此之外还有一些同IP衍生游戏: Minecraft Legends、Minecraft Story Mode(故事模式) 、Minecraft Earth和 Minecraft Dungeons. 接下来将带你了解不同版本之间的区别，以及如何选择。如果你已经拥有一个Minecraft的许可 (即 你已经购买了Minecraft)，请使用本页面 右侧的 目录跳转到对应的章节. [[toc]] ::: warning 这里不提教育版… 一般来说，基岩版内包含了教育版的部分内容. ::: details 正版的教育版授权需要由满足以下条件的实体才能购买: 拥有Microsoft 365（原Office 365）教育版账户 教育者要取得购买资格，必须是学术机构的全职或兼职教员/职员，并且拥有一个由学校提供的学校电子邮箱，以接受附加电子邮件的用户。 区域或学校要取得购买资格，必须是一个素质教育用户，这个用户的定义是专门教育其注册学生为目的的机构组织。 公共图书馆要取得购买资格，必须为所有给定的社区、区域或地区免费提供普通图书馆服务。 公共博物馆要取得购买资格，必须是一个本质上以永久基础教育或以审美为目的，并利用专业人员定期向公众展示一个有形物体的机构或机构组织。 家庭教育项目要取得购买资格，必须提供向学生提供中小学教育或学生出具其属于由国家认可的家庭教育组织或被一个当地学区明确承认此为一种可接受的教育方式或者州立承认/任何的教育组织的书面证明。 ::: 1) 依据游玩设备 Minecraft可以运行在在很多不同的平台上。 a) 电脑 ::: info 可用的游戏 Minecraft Java Edition (Java版)，Minecraft Bedrock Edition (基岩版)，Minecraft Legends，Minecraft Dungeons，Minecraft Story Mode ::: 在电脑上可以游玩的Minecraft有很多种。如果“只是想玩玩”，那么可以自由从Java版和基岩版之中选择。我们强烈建议从微软官方购买游戏以游玩。 b) 手机 ::: info 可用的游戏 Minecraft Java Edition (Java版)，Minecraft Bedrock Edition (基岩版，含教育内容)，Minecraft Earth ::: 一般来说，在Google Play Store或App Store安装的Minecraft都是基岩版的范畴。同样的，由于基岩版和Java版使用不同的技术开发，其虽然尽可能地保持游戏规则、玩法和行为一致，但也存在一些不同之处。如果你只是想搭搭方块，进行自己的冒险，那么两个版本之间并无太大差别。——具体的差别体现在机制上: 红石、战斗，以及被戏称为「特性」的、可能在未来会被视为「非预期行为」的游戏BUG。就战斗机制举个例子，截止至目前，在基岩版中没有攻击冷却* 并且举盾需要在副手持盾的情况下蹲下; 而Java版存在攻击冷却，举盾需要在副手持盾的情况下按住鼠标右键. 但是，Java版在移动设备上的安装相比于安装基岩版要麻烦不少。虽然我们 (Corona Studio) 有制作移动端Java游戏启动器的想法，但是目前还是先看看其他优秀的现有产品吧: pojavLauncher: 支持iOS设备、Android设备. FCL: 支持Android设备。 有关于上述启动器的使用方法，你可以在Bilibili、MineBBS等地搜索到很多教程，以及软件相关的下载地址。以下是一些推荐的教程: c) 游戏机 (XBox之类的设备) ::: info 可用的游戏 Minecraft Legends，Minecraft Bedrock Edition (基岩版)，Minecraft Dungeons ::: 2) 依据想要玩的内容 一般来说，慕名前来游玩Minecraft的玩家一般都会选择定义为 「沙盒游戏」 的Minecraft，也就是 Java版(Java Edition) 或 基岩版(Bedrock Edition) 。 如何在这两种版本中做出选择，已经在上一段中介绍过了。 但是如果你想尝试不太一样的… a) 策略动作类Minecraft: Legends 这个游戏具备多人玩法. b) 肉鸽类Minecraft: Dungeons 这个游戏具备多人玩法. c) AR（增强现实）Minecraft：Earth 这个游戏可以让你在 “自己家里建造”：通过手机摄像头和增强现实计算来在当前摄像头里的 “现实环境” 中 “放置方块”。 d) 剧情冒险Minecraft: 故事模式 游戏的玩法是玩家可以收集物品，解决谜题，并通过对话树与非玩家角色进行对话，以了解故事并确定下一步要做什么. 玩家做出的决定会影响当前章节和后续章节中的事件。或许可以当作一种视觉小说来看. 这个游戏具备一种基于网页投票的多人玩法 (第二部)，很诡异，并且貌似现在不可用. 购买 购买Minecraft可以在很多平台上完成，但是部分不同的版本仅在不同的平台可供购买。一般而言，目前Mojang作为微软的一员，所有Minecraft相关游戏均可在微软商店购买(除了部分已下架的游戏)。截止目前(2024年5月22日)，微软商店支持使用支付宝进行免密支付. 截止至目前，不同版本对应可购买的平台如下: 括号中代表在不同平台的价格。比如，平台中的“minecraft.net”排在第一位，则价格“169(1，… )” 意味着「在minecraft.net上，游戏价格为169」 版本 平台 一般售价 (人民币元*) Minecraft Java版 minecraft.net (除中国大陆区域以外)，微软商店 89 (与基岩版捆绑销售) Minecraft 基岩版 (Windows) minecraft.net (除中国大陆区域以外)，微软商店 89 (与基岩版捆绑销售) Minecraft 基岩版 (iOS) App Store (除中国大陆区域以外) 6.99美元* Minecraft 基岩版 (Android) Google Play 6.99美元* Minecraft 基岩版 (其他平台) 未知 未知 Dungeons minecraft.net，微软商店，steam 69 (1，2) / 72 (3) Legends steam 59.5 故事模式 已下架 - Earth 已下架 - Java版 基本步骤 准备环境 确认你的游玩设备。本文只介绍在电脑上使用LauncherX游玩的步骤。 前往这里下载最新版LauncherX。下载LauncherX的教程在这里：开始 | 日冕知识库 完成启动器配置后，前往【下载-游戏本体】，选择一个具体的版本号进行下载。使用LauncherX下载安装游戏的最完整教程在这里：安装游戏 | 日冕知识库 完成下载后，有一部分额外的资源需要在启动前确保完整，如果不完整，LauncherX将会自动尝试进行下载。点击【启动游戏】将会自动检查资源完整性。 ::: tip 下载问题 如果出现下载失败，请尝试让LauncherX自动选择下载源（一般情况下这是默认被选择的），并且尝试在【设置-全局游戏设置-启动器行为-重试次数】中调大重试次数。 若下载失败一直出现，请检查自己的网络连接。检测网络 | 日冕知识库 ::: 点击启动游戏后，正常来说游戏将会启动。然后就可以开始游戏了！ ::: info 游戏启动失败了！ 如果游戏启动失败，请参考：游戏崩溃/异常分析专题 | 日冕知识库 和后续内容文章自行进行排查，或将崩溃检测器的支持包导出后交由有能力分析错误日志的人进行诊断。 ::: 基岩版 基本步骤 Legends / 故事模式 / Dungeons/… ::: info 这不是传统的Minecraft！ 参考前文以确认这是不是你要玩的Minecraft。 ::: 正如之前所说的，这些游戏有着与一般Minecraft完全不同的玩法。 如何购买和游玩? 依照上文**[关于购买]**的表格，在对应的游戏平台搜索 购买，根据平台的提示下载安装 完成! 现在打开游戏吧！ ::: tip Minecraft官方启动器和微软商店可以满足全部需求 要游玩这些游戏，可以直接在微软商店购买，然后通过微软商店/XBox/Minecraft启动器来游玩。也可以将游戏固定到开始菜单. ::: 设备要求 以下是这三款游戏的最低设备要求： Minecraft Dungeons 操作系统：Windows 10 (需要安装2019年11月以后的更新) 处理器：intel Core i5 2.8GHz或等效处理器 内存：8 GB 显卡：NVIDIA GeForce GTX 660或等效GPU，要求至少2GB VRAM 存储空间：至少6 GB可用空间 DirectX：DirectX 11 Minecraft Story Mode 操作系统：Windows XP SP 3 处理器：Core 2 Duo 2GHz或等效处理器 (2010年以后电脑基本都可以) 内存：3 GB 显卡：任意带有512 MB RAM的显卡 存储空间：至少3 GB可用空间 DirectX：9.0 Minecraft Legends 操作系统：Windows 10 (2020年5月更新或更高版本) 处理器：Core i5 2.8GHz或等效处理器 内存：8 GB 图形卡：NVIDIA GeForce GTX 780或等效的GPU 存储空间：至少24 GB可用空间 DirectX：12 其他更多 信息缺失，请根据应用商店提供的信息确认是否满足硬件要求。 关于网易代理的《中国版我的世界》 如果你只是想在完全受支持的环境下进行多人游戏并且可以负担内购、不打算操心太多扩展游戏玩法后调试相关的问题并且经常有游戏社交的需求，建议选择由网易代理的仅面向中国大陆用户的《我的世界》。网易公司代理了微软公司和Mojang AB在中国大陆地区包括游戏运营权在内的许多权利。 网易《我的世界》官方网站网址是：全新视界 探索无限 | 网易《我的世界》 跋 如果你真的很喜欢Minecraft这个IP，那么建议在购买正版Minecraft之余，建议根据玩法喜好也尝试一下衍生的Dungeon、Legends等。但是如果你只打算游玩最经典的玩法，请考虑使用LauncherX游玩Java版。绝大多数情况下，Java版是兼顾兼容性和扩展性的最佳选择。 一般而言，为了区分网易代理版，会将原来的Minecraft称为国际版，而网易版就称呼为网易版或中国版。在某些情况下，要想自由地游玩国际版，对学习能力的要求要更高一些（也没高多少，会理解记忆会提问题就好）对于国际版和中国版，都存在对应的Java版和基岩版的差别：也就是说，国际版有的Java版和基岩版游戏之分，中国版也有。与此同时，根据经验，中国版的版本更新平均比国际版晚一年。 做出你的选择吧！"
  },
  "temp/docs-main/zhCN/mc-starter/index.html": {
    "href": "temp/docs-main/zhCN/mc-starter/index.html",
    "title": "Minecraft新手上路! | Qomicex.Core API文档",
    "summary": "Minecraft新手上路! ::: tip 欢迎! 真好! 你选择步入Minecraft的世界. ::: —— 或许你以往并不了解Minecraft，只是偶然在某个博主的视频中看到了这尽是方块但充斥着无限可能的世界; 或者你曾经通过其他渠道接触过，但是如今想要真正开始深入，那么或许这一系列的文章将非常适合你。如果你真心想要了解这个游戏并在这个游戏里取得乐趣，那么请怀揣着一颗主动学习、举一反三的求知之心继续阅读吧! 资源和信息获取 在指引完你选择合适的Minecraft之后，本系列文章将仅介绍Minecraft Java Edition (Java版) 游戏上手的必要信息。此外，以下是「作为一个Minecraft玩家」可能用得上的获取资源和/或信息的网站. 名称 网址 做什么的? MineBBS https://minebbs.com 这是一个前期以基岩版资源分享和讨论为主的论坛。 如今这里有一些独特的游戏资源，并提供了一个交流讨论的环境。 MC百科 https://mcmod.cn 收录了许多高人气的游戏模组和其他资源， 主要提供模组下载、筛选服务，以及诸如「命令方块指令生成」之类的实用工具。 ZhMCWiki | 中文Minecraft Wiki https://zh.minecraft.wiki (源站) | https://wiki.biligame.com/mc/Minecraft_Wiki (Bilibili维护的镜像) 想必是最完整的Minecraft游戏维基 (可以理解为百科全书) 涵盖了最主要的两个版本(Java版&基岩版) 的从快照版到正式版的绝大多数更新内容和详细信息。 必应 https://bing.com 我们推荐使用必应搜索引擎检索信息。因为必应收录网站非常及时，且有很完备的高级搜索功能。 举个例子，使用带有搜索参数的搜索词「site:minebbs.com launcherx」可以更快地找到LauncherX在MineBBS的发布页面。 自食其力、自给自足 此外，还有一些值得一看的内容，或许在你所有的求知场景中都十分有用。推荐阅读. 少数派 - 如何在互联网高效搜索信息？关于搜索引擎的分享与总结 提问的智慧(进阶，请从链接所指的地方开始看)"
  },
  "temp/docs-main/zhCN/mc-starter/play-together.html": {
    "href": "temp/docs-main/zhCN/mc-starter/play-together.html",
    "title": "一起玩吗? 联机游戏指南 | Qomicex.Core API文档",
    "summary": "@useFixer 一起玩吗? 联机游戏指南 :::tip 本文将介绍几种常见的流行的联机方式。需要注意的是，由于实现原理不同，不同的方法有不同的特点，应用于游戏中可能造成不同的优劣势. ::: 或许你一个人在原野上漫步的时候听着Minecraft的背景音乐，感受到了一丝孤独? 此时或许会想，要是我能和我的好友——三年二班的李子明同学一起玩、一起建设装点这个世界就好了! 对于基岩版玩家，或许可以考虑使用XBox提供的好友联机，但是Java版目前 (2024-06-20) 并没有这种联机方式。如果你希望使用Java版进行多人游戏，或许需要费一番功夫了。 i [[toc]] 联机游戏一般能达成什么效果? 联机游戏，顾名思义就是“一起玩”，最终能够使得多个使用不同设备的玩家能够连接进入同一个 “世界” 。i 不同的联机方式以及对应的特点 局域网联机 ::: warning 保持世界开启 要保持大家都能玩，请保证： 不要退出世界，更不要退出游戏 不要断开网络连接 只有这个世界还在运转，大家才能在一起游玩。 ::: 通俗而言，多台电脑处于一个wifi或通过网线连接到同一台路由器，可以认为它们接入了同一个局域网。在同一局域网中，一台电脑进入一个单人世界后，可以在暂停菜单中选择「在LAN」，然后其他电脑就可以在「多人游戏」中找到这个世界了.i 这种方式需要一台电脑保持游戏运行、世界开放，当那台电脑断开网络连接/退出世界/关机，其他玩家就不能加入到此世界了.i P2P联机 ::: warning 保持世界开启 要保持大家都能玩，请保证： 不要退出世界，更不要退出游戏 不要断开网络连接 只有这个世界还在运转，大家才能在一起游玩。 ::: 1、总览 P2P联机的常用方式是将不同地区的电脑通过P2P网络连结在同一个虚拟的「局域网」，因此实际操作方法与局域网联机类似，但是多了一些启用P2P的步骤。接下来将介绍LauncherX P2P方法和Zerotier P2P组网方法。i ::: details 关于P2P和Radmin VPN的区别 LauncherX内置的联机方式基于P2P技术，通过软件管理一个虚拟的房间，然后将其他人连入房主的虚拟内网中映射。而Radmin相当于在房主电脑上部署了一个VPN服务器，其他人连入Radmin房间相当于直接接入了房主的本地内网。 ::: 需要注意的是，由于P2P技术的特殊性，仍然具备一定的情况会使得用户无法建立有效的连接，或是出现体验偏差的情况。这是由诸多网络环境因素导致的，比如网络运营商设置的NAT类型，可以阅读P2P学习: NAT的四种类型以及类型探测by - 山上有风景 - 博客园 来进一步了解。总而言之，NAT一般分别有以下类型:i 全锥型(Full Cone) 受限锥型(Restricted Cone)， 或者说是IP受限锥型 端口受限锥型(Port Restricted Cone)， 或者说是IP + PORT受限锥型 对称型(Symmetric) 其中，1、2、3都是锥形NAT，编号越大限制越多; 4是对称型NAT，具有这四种中最大的限制。网络环境中NAT限制越大，成功实现P2P网络的可能越小. 2、LauncherX P2P 若要使用LauncherX进行P2P联机游戏，参考：P2P联机 | 日冕知识库 构建虚拟专属网络 1、使用Radmin LAN ::: info 内容施工中 ::: 0、知道其他工具吗? ::: tip 欢迎直接向我们的文档仓库提交issue或pull request来完善本文内容! 如果你选择提交pull request来完善本文，欢迎! 不过如果你选择通过issue来告诉我们更多类似Radmin LAN的工具，亦不甚感激! ::: 内网穿透 内网穿透将内网的电脑上特定端口通过转发来在公网的某个端口暴露出来，以供连接。市面上成熟的内网穿透（FRP）服务提供商有很多，比如OpenFRP。如果你有一个性能不足以运行服务端的VPS但是它足够用来搭建FRP服务器，也可以自行搭建。你需要自行确认当前所在地区和VPS服务商对FRP的管理政策。接下来介绍两种借助内网穿透的联机方法。i 1、将局域网世界暴露到公网 ::: warning 保持世界开启 要保持大家都能玩，请保证： 不要退出世界，更不要退出游戏 不要断开网络连接 只有这个世界还在运转，大家才能在一起游玩。 ::: 这个方案相当于将自己电脑上的Minecraft的内部服务器暴露给其他人，只需要将内网的服务转到外网即可。具体操作步骤如下：i 启动游戏，进入要一起游玩的世界 暂停游戏，点击【对局域网开放】 在不同版本游戏中，这一步的操作不一样。 对于较老版本的游戏，Minecraft会寻找一个未被占用的端口，然后在那个端口上暴露游戏。具体使用的端口将会在聊天区显示出来类似如下文字： 本地游戏已在端口[11451]上开启 对于较新版本的游戏，在点击【对局域网开放】后会有另外一个界面，在这里可以自定义端口号，留空以允许Minecraft选择找到的一个随机的未被占用的端口，点击【创建局域网世界】以确认配置。端口号显示同上。 现在你已经准备好世界了，记下这个端口号，然后在你选择的 FRP服务商控制台 中挑选合适的节点以创建FRP隧道或修改现有隧道（具体操作方法参考服务商提供的文档和教程） 将端口号输入到本地端口那一栏，保存，回到自己的电脑上启动FRP启动器 确保你的隧道已创建，然后开启它 开启成功后，将该隧道的链接连同对应的端口（可能并非游戏给你的端口，而是你在FRP控制台选择或被分配的端口）发送给一起玩的玩家。一起玩的玩家只需要使用同样的游戏客户端，在【多人游戏-添加服务器/直接连接】的【服务器地址】一栏填入你提供的地址即可连接。 每次启动世界所使用的端口号可能不相同，为此你需要每次都更改隧道中记录的本地端口号。 如果需要修改这种世界的联机服务器设置，你可能需要借助Mod来修改，比如：自定义局域网联机 (Lan Server Properties) - MC百科 相关阅读：基本教程 | OpenFrp Docs | Windows 桌面启动器 | OpenFrp Docs | 我的世界（Minecraft）服务端配置 | OpenFrp Docs | 搭建内网穿透(Frp) | 笨蛋 MC 开服教程 | 基础知识 | 笨蛋 MC 开服教程 2、使用家庭电脑作为服务器 你可以下载服务端到自己的电脑上来运行，这样，在你的电脑上就相当于有一个Minecraft游戏服务器了。我们称这个行为为 开服。i 开服，就是相当于，你在这个游戏里面，创建了一个24h永久不断开的联机房间。不管是作为创建服务器的你，还是说加入到你这个服务器的玩家，你们的进入与退出都不会影响到服务器的开放使用。（引用自：服务器大体框架知识（搭建必看）） 已经有相当数量的教程介绍了如何开服。在这里，笔者仅将大体步骤抽象出来： 准备环境（可以认为是：新建文件夹存放服务端，准备Java环境，下载服务端到新建文件夹） 准备运行脚本 首次运行脚本，然后阅读创建的EULA并决定是否同意。只有同意了EULA才能继续开服。（EULA：最终用户许可协议，是一种具备法律效力的文本。在这里主要是对Minecraft知识产权的保护。至少，首先，开服不要想着赚钱。Minecraft官方的EULA原文也可以在这里看到，或者查看Usage Guidelines | Minecraft 来确认哪些可以做，哪些不可以做。） 等待服务器就绪，然后加入服务器的世界吧！ 推荐阅读： Minecraft Wiki：Tutorial: Setting up a server – Minecraft Wiki 笨蛋开服教程：开始 | 笨蛋 MC 开服教程 冬月的大体框架知识：服务器大体框架知识（搭建必看） 官方下载服务端的链接：Download server for Minecraft | Minecraft Java版服务端核心文件解释：服务端核心文件 | Minecraft Wiki 这些内容对于接下来的内容同样有用。 使用云服务器 ::: warning 谨慎辨别在线购买的服务 使用购物平台可以搜索到很多看起来很适合 “小白” 的云服务器，尤其是面板服。但是，商家可能利用信息差赚取更高额的服务费用。建议在付款前请求试用，或者在各大交流群、论坛中尝试询问有经验的 “大佬”、“菊苣”，抑或是仔细参考商品信息和商品评价，尽可能避免上当。i 此外，可以尝试通过多种渠道了解和分析商家的信用水平，以避免出现纠纷或是遇到商家跑路的问题。i 我们建议先了解的一些基础知识：基础知识 | 笨蛋 MC 开服教程i ::: 0、真的需要云服务器吗？ 据笔者所知，只有在这些情况下才真正 有必要 租用云服务器来维持多人游戏： 玩家数量较多，且需要运行世界的主机长期开启以保持玩家随时可连接 在本文中其他方法无法维持游戏体验（包括但不限于：自己电脑无法维持多人游戏） 使用云服务器来组织多人游戏是有一定技术门槛和经济能力要求的。对于新手而言，只要愿意付出精力和时间，总是能够积累起技术来运营和维护属于自己的Minecraft多人游戏服务器。在真正租用服务器之前，首先要试着做：i 在自己的电脑上练习开服，同时学习一些计算机和网络的基础概念； 学习一些JVM优化方面的概念（参考阅读：合理分配游戏内存、选择GC、配置JavaAgent | 日冕知识库，下载合适的Java运行时 | 日冕知识库，Java 相关 | 笨蛋 MC 开服教程）至少要知道如何调整服务器分配的内存、如何指定垃圾回收器（甚至 垃圾回收器 是干什么的也需要了解一下） 了解并遵守有关的 涉及版权的具备法律效力的协议 （比如 著名的 Minecraft EULA），确保你开服并不会侵犯他人权益来赚钱 了解你将要开的服务器的类型（使用 什么样的服务端？性能需求有多大？又如何使用类似Spark这样的工具来分析服务器性能和占用？参考阅读：什么是服务端？ | 笨蛋 MC 开服教程，Spark Wiki：前言 | Continue Project） 其间，如果遇到问题可以到相关社区请教有经验的人。不要忘了 你并不比别人差 ，并且无论如何 勤能补拙 ，如果能做到 虚心请教 并且 独立人格、不讨人厌 ，那么你将能获得不少人的帮助。（参考阅读：如何向大佬求助 | 笨蛋 MC 开服教程，Minecraft新手上路! #自食其力、自给自足| 日冕知识库） 然后，你才真正准备好开服了。 1、云服务器分类 可以租用的云服务器有许多种。此处不讨论《我的世界》租赁服务器。 a) Minecraft Realms 这是由Mojang提供的官方租赁服务器，存在Java版和基岩版两种版本。 i 优点： 十分稳定，随着游戏主版本更新而更新 缺点： 大多部署在中国大陆境外，连接可能存在一些延迟 相比而言不那么便宜 特性： 玩家必须拥有正版Minecraft，无法通过离线模式游玩 一般有严格的游玩人数限制，适合朋友一起玩 扩展性局限于原版游戏 基岩版和Java版Realms都有，但是分离 如何购买： 前往Minecraft官网即可购买：Wallet & Realms | Minecraft 参考阅读（官方）：Minecraft Realms 教程和指南 | Minecraft b) VPS VPS可能包含NAT类和独立IP类，对于Minecraft游戏而言，两者的区别在技术上并不会引起很大影响。如果是独立IP，那么开放默认的25565端口后，服务器地址可以不用在末尾追加端口 （比如：thatsmine.kami.su:25565中，末尾的:25565是没必要的，可以省略）；i 而如果是NAT类VPS，那么端口在暴露到公网时会被转发，也就是说原本的25565端口在暴露到公网时候会变成别的端口（具体变成什么端口请询问服务商）这时候如果想要抹掉地址末尾的端口号，需要用你的域名创建一个SRV解析指向你的服务器。相关阅读：域名申请与解析 | 笨蛋 MC 开服教程。 i 相对而言，使用VPS开服将会有最高的自由度。 i 优点： 自由度超高，完全自选服务端核心 扩展性超高，可以选用Forge、Fabric、Arclight、Mohist等服务端 可以在VPS中运行群组服，满足更多需求 缺点： 运维技术门槛更高 要求对硬件需求有明确认知 开服的经济成本相对较高 特性： 允许非正版玩家加入游戏 由于有最高的自由度，不仅可以在VPS上运行Java版服务器，还可以运行基岩版服务器；在VPS上开启的Java版服务器甚至可以做到让Java版和基岩版玩家一起游玩（参考：Geyser概览 | 笨蛋 MC 开服教程）也可以做到让正版玩家、外置登录玩家和离线玩家一起游玩（参考：MultiLogin Wiki） 如何购买： 除了阿里、腾讯云等云计算大厂，还有许多二线三线云服务商提供VPS租赁服务。一般而言，针对Minecraft特化的VPS由专注于提供游戏服务器的服务商提供，性能更贴合实际需求，价格相比大厂更便宜。但是要小心，有一些不那么正规的商家可能会兜售 “超开服务器” ，即单台宿主服务器（可以理解为一台电脑）上本来性能只够4个人平分，但是商家在上面部署了8个或更多VPS来售卖——这样会导致峰值网络性能和算力变差，使得游玩体验大打折扣。 i 在购买租赁VPS之前，请尽可能地打听商家的名誉，再三确认算力需求，然后再下单。 i c) 面板服 面板服，顾名思义，就是提供一个网页面板以供管理，系统环境配置等基本上都不需要你自己考虑。这可能是最简单的方案。有的服务商会专门出租这种服务，甚至有的服务商会在面板中提供一些整合包以供一键开服，一般情况下他们提供的预设在稳定性上有足够保障，只是快捷开服想要玩玩的话，这个方案是最合适的，但是如果需要自己排除错误，仍然需要学习一些基础知识（参考上文关于VPS的部分）。 i 与此同时，如果你租用了VPS，也可以请求技术人员为你部署类似MCSManager的面板便于管理。 i ::: warning 小心贩子 面板服市场上除了可能出现超开问题，还可能有贩子。贩子从上游渠道进货得到实例开启权限，然后将其售卖给客户，实际的技术细节很少涉及；并且由于要保证利润，实际上的价格缺乏竞争力，但是他们会为自己的宣传投资以保证成交量。有能力的情况下，请选择能没有中间商的面板服租赁。i ::: 优点： 便于随时访问和管理 可能可以很方便地进行服务端部署 缺点： 自由度受限 如果恰好买到配备功能缺失的面板的面板服，功能会进一步受到限制 被坑的可能性提升 特性： 整体会比VPS便宜一些，适合轻量化需求的服主 如何购买： 预制面板服多见于电商平台和专攻Minecraft等游戏服务器供应的服务商。 i"
  },
  "temp/docs-main/zhCN/mc-starter/start-the-game-java.html": {
    "href": "temp/docs-main/zhCN/mc-starter/start-the-game-java.html",
    "title": "| Qomicex.Core API文档",
    "summary": ""
  },
  "temp/docs-main/zhCN/mc-starter/useful-links.html": {
    "href": "temp/docs-main/zhCN/mc-starter/useful-links.html",
    "title": "有用的链接（建议收藏） | Qomicex.Core API文档",
    "summary": "有用的链接（建议收藏） 这里存放了一些游玩Minecraft Java版时可能经常用到的链接。 点击链接后可能会要求登录。 链接 介绍 Realms管理 用于管理当前账户的Realms订阅 更改皮肤 用于修改当前账户的皮肤和披风 更改ID 用于更改当前账户的玩家名称"
  },
  "temp/docs-main/zhCN/projbobcat/additionalParsers/accountProfileParser.html": {
    "href": "temp/docs-main/zhCN/projbobcat/additionalParsers/accountProfileParser.html",
    "title": "游戏账号解析器 | Qomicex.Core API文档",
    "summary": "游戏账号解析器 游戏档案解析器负责将用户账户写入到官方启动器的配置文件中。 初始化解析器 初始化解析器的方式非常简单： var launcherAccountParser = new DefaultLauncherAccountParser(rootPath，clientToken) 其中，rootPath 为核心所在的根目录（即 .minecraft 文件夹所在的目录）。 clientToken 为一个随机生成的 GUID。"
  },
  "temp/docs-main/zhCN/projbobcat/additionalParsers/gameProfileParser.html": {
    "href": "temp/docs-main/zhCN/projbobcat/additionalParsers/gameProfileParser.html",
    "title": "游戏档案解析器 | Qomicex.Core API文档",
    "summary": "游戏档案解析器 游戏档案解析器负责将搜索到的本地游戏写入到官方启动器的配置文件中。 初始化解析器 初始化解析器的方式非常简单： var launcherProfileParser = new DefaultLauncherProfileParser(rootPath，clientToken) 其中，rootPath 为核心所在的根目录（即 .minecraft 文件夹所在的目录）。 clientToken 为一个随机生成的 GUID。"
  },
  "temp/docs-main/zhCN/projbobcat/additionalParsers/index.html": {
    "href": "temp/docs-main/zhCN/projbobcat/additionalParsers/index.html",
    "title": "附加解析器 | Qomicex.Core API文档",
    "summary": "附加解析器 ProjBobcat 为了和 Mojang 官方的启动器保持同样的行为， 我们为其实现了一些额外的解析器来帮助我们和官方启动器保持数据和档案的同步。 下表是目前已经实现的解析器： 名称 说明 DefaultLauncherAccountParser 用于将验证信息写入到官方启动器的配置文件 DefaultLauncherProfileParser 用于将搜索到的本地游戏写入启动器的配置文件"
  },
  "temp/docs-main/zhCN/projbobcat/authenticators/index.html": {
    "href": "temp/docs-main/zhCN/projbobcat/authenticators/index.html",
    "title": "验证模型 | Qomicex.Core API文档",
    "summary": "验证模型 在 ProjBobcat 中，我们已经为开发者实现了您在 MineCraft 开发过程中可能遇到的所有的验证情形。 支持列表 模型名称 适用情形 OfflineAuthenticator 离线验证模型 YggdrasilAuthenticator 适用于旧版本的登录模型 MicrosoftAuthenticator 新版的微软验证模型"
  },
  "temp/docs-main/zhCN/projbobcat/authenticators/microsoft.html": {
    "href": "temp/docs-main/zhCN/projbobcat/authenticators/microsoft.html",
    "title": "Microsoft 验证模型 | Qomicex.Core API文档",
    "summary": "Microsoft 验证模型 [[toc]] 该验证模型实现了新版基于 Azure 的全新验证流程，适用于目前仍在维护的全部 MineCraft 版本。 准备工作 由于新版验证流程使用了基于 Azure 的验证方式。 因此，在开始之前请确保您已经完成了 Azure 应用的配置 在完成了 Azure 的应用注册后，请确保在程序入口点完成了微软验证器的初始化。 配置缓存凭据提供方法 由于该验证模型的特殊性，开发者需要保存首次验证返回的 刷新令牌 和 失效时间 来帮助验证器完成验证。 验证器在验证时会首次调用该方法来查询本地令牌缓存的有效性，如果本地令牌仍然有效，则直接返回验证结果。 如本地缓存的令牌已失效，则需要开发者手动请求新令牌后并返回刷新后的令牌。 下面我们提供了一个该方法的样例实现： public async Task<(bool，GraphAuthResultModel?)> CacheTokenProviderAsync() { if (string.IsNullOrEmpty(XBLToken)) return (false, default); if (string.IsNullOrEmpty(XBLRefreshToken)) return (false, default); // 计算失效时间 // [!code focus] var expireDate = LastRefreshedTime.AddSeconds(ExpiresIn); // [!code focus] // 如果本地缓存令牌依旧是有效的，则直接返回当前令牌 // [!code focus] // 否则，使用刷新令牌请求新的令牌 // [!code focus] if (expireDate > DateTime.Now) { var result = new GraphAuthResultModel // [!code focus] { // [!code focus] ExpiresIn = (int)(expireDate - DateTime.Now).TotalSeconds, // [!code focus] AccessToken = XBLToken, // [!code focus] RefreshToken = XBLRefreshToken // [!code focus] }; // [!code focus] return (true, result); // [!code focus] } // 请求新的登录令牌 // [!code focus] var refreshReqDic = new List<KeyValuePair<string, string>> // [!code focus] { // [!code focus] new(\"client_id\", MicrosoftAuthenticator.ApiSettings.ClientId), // [!code focus] new(\"refresh_token\", XBLRefreshToken), // [!code focus] new(\"grant_type\", \"refresh_token\") // [!code focus] }; // [!code focus] using var refreshReq = new HttpRequestMessage(HttpMethod.Post, MicrosoftAuthenticator.MSRefreshTokenRequestUrl) // [!code focus] { // [!code focus] Content = new FormUrlEncodedContent(refreshReqDic) // [!code focus] }; // [!code focus] using var refreshRes = await DefaultClient.SendAsync(refreshReq); var refreshContent = await refreshRes.Content.ReadAsStringAsync(); var refreshModel = MicrosoftAuthenticator.ResolveMSGraphResult(refreshContent, GraphAuthResultModelContext.Default.GraphAuthResultModel); if (refreshModel is not GraphAuthResultModel model) { if (refreshModel is GraphResponseErrorModel error) // [!code focus] { // [!code focus] // 在这里处理失败的刷新操作 // [!code focus] } // [!code focus] return (false, default); } return (true, model); } 配置首次登录设备流验证代码展示方法 由于我们采用了设备流验证的方式来验证玩家的微软账户。 因此，我们需要一个额外的方法将设备流验证所需要的一次性秘钥和验证地址展现给用户。 以下是这个方法的一个实例： private void DeviceTokenNotifier(DeviceIdResponseModel deviceIdResponseModel) { // 将获取到的回调数据展示到前端 DeviceCodeResponse = deviceIdResponseModel; } DeviceIdResponseModel 中包含了用户完成验证所需要的所有信息： 名称 作用 UserCode 用户验证所需要的秘钥 VerificationUri 验证地址，用户需访问该网址来完成后续的验证步骤 ExpiresIn 验证代码的失效时间（秒） 在下面您可以看到一个示例的展示界面： 在这个界面中，您至少需要包含以下的内容： 登录所需要的秘钥 具体的验证地址 一个简短的操作提示来帮助用户完成验证操作 初始化验证器 初次验证 :::warning 请确保在执行下面的流程前您已经准备好了 配置首次登录设备流验证代码展示方法 来确保用户能够获取到正确的初次登录信息！ ::: 初始化验证器： var microsoftAuthenticator = new MicrosoftAuthenticator { LauncherAccountParser = launcherAccountParser }; 在上述代码块中，请将这些参数按照您的实际情况替换： 项目 说明 launcherAccountParser 对于启动器账户解析器的初始化，详见此处 非初次验证 非初次验证即使用在首次验证中获取到的 Token 缓存来进行二次验证。 其主要通过 CacheTokenProviderAsync 来验证本地凭据是否依旧有效，如果本地缓存的 Token 已经失效，则会在该方法中完成刷新。 初始化验证器： var microsoftAuthenticator = new MicrosoftAuthenticator { CacheTokenProvider = CacheTokenProviderAsync, Email = \"[EMAIL]\", LauncherAccountParser = launcherAccountParser }; 在上述代码块中，请将这些参数按照您的实际情况替换： 项目 说明 launcherAccountParser 对于启动器账户解析器的初始化，详见此处 [EMAIL] 验证账户的邮箱地址 :::tip 对于 launcherAccountParser（游戏档案解析器）的初始化，请参考游戏档案解析器页面 ::: 获取验证结果（初次验证） 在您完成验证模型的初始化后，您只需要调用 Microsoft 验证器的验证方法来初次账户验证。 下面是一段样例验证代码： // 获取验证结果 // [!code focus] // DeviceTokenNotifier 即为前文提到的信息展示方法 // [!code focus] var authResult = await msAuth.GetMSAuthResult(DeviceTokenNotifier); // [!code focus] if (authResult == null) { // 处理失败的验证 // [!code focus] } // 从 Jwt Token 中解析用户字段 // [!code focus] var claims = JwtTokenHelper.GetTokenInfo(authResult.IdToken); // [!code focus] var email = claims.TryGetValue(\"email\"，out var outEmail) ? outEmail : null; // [!code focus] if (string.IsNullOrEmpty(email)) { // 无法从 Jwt 凭据中无法解析用户的电子邮件地址，视作验证失败 // [!code focus] // 这很有可能是 Azure 应用或是 Scope 配置失败导致的 // [!code focus] } // 将必要的用户信息保存至本地磁盘以便为下一次验证做准备 // [!code focus] var msInfoModel = new MSAccountInfoModel { XBLToken = authResult.AccessToken，// [!code focus] XBLRefreshToken = authResult.RefreshToken，// [!code focus] ExpiresIn = authResult.ExpiresIn，// [!code focus] Email = email // [!code focus] }; 获取验证结果（非初次验证） 在您完成验证模型的初始化后，您只需要调用 Microsoft 验证器的验证方法来完成账户验证。 在异步上下文中，使用 AuthTaskAsync 来完成验证： var authResult = await microsoftAuthenticator.AuthTaskAsync(false); 在同步上下文中，使用 Auth 来完成验证： var authResult = microsoftAuthenticator.Auth(); 解读验证结果 在验证方法完成之后，验证模型会返回验证结果，这是父类型为 AuthResultBase 的对象。 所有的验证结果都包含一个枚举值 AuthStatus，该枚举值直接指示了验证结果的成功或是失败。 在下面您可以看到对验证结果的解读： 失败的验证结果 通过判断 Error 是否为空，您可以很轻松的判断验证模型返回的验证结果是否是有效的， Error 对象会包含以下字段来告诉您一些细节： 字段 说明 authResult.Error.Cause 导致问题的具体原因 authResult.Error.Error 错误名称 authResult.Error.ErrorMessage 错误的详细信息，可能包含解决方案 成功的验证结果 如果验证结果中的 Error 字段为空，则表示本次验证是有效的，成功的验证结果会包含下面的信息： 字段 说明 authResult.Id 该用户名的唯一标识符，ProjBobcat 使用特定的生成方式来生成这个标识符 authResult.AccessToken 用户账户的授权凭据 authResult.Profiles 用户可用的角色列表，可能包含多个可用角色 authResult.SelectedProfile 用户当前选择的角色，该字段可能为空。如果为空则需要提示用户进行手动选择。 authResult.User 用户账户信息摘要，包含一些基础的账户信息 authResult.LocalId 本地 ID，通常为随机生成的 UUID authResult.RemoteId 验证服务器返回的远程 ID，通常为该用户的唯一标识符 authResult.XBoxUid XBox Live UID authResult.Email 验证所使用的邮箱地址 authResult.CurrentAuthTime 当前的验证时间，开发者需要保存这个字段来帮助确认本地缓存令牌的有效性 authResult.ExpiresIn 令牌失效时间（单位：秒），开发者需要保存这个字段来帮助确认本地缓存令牌的有效性 authResult.RefreshToken 刷新令牌，开发者需要保存这个字段来帮助刷新失效的令牌 authResult.Skin 用户账户的皮肤 URL :::warning 请使用相应的限制或是加密等操作来安全的储存用户相关令牌的机密数据，这部分数据的泄露可能会造成损失。 :::"
  },
  "temp/docs-main/zhCN/projbobcat/authenticators/offline.html": {
    "href": "temp/docs-main/zhCN/projbobcat/authenticators/offline.html",
    "title": "离线验证模型 | Qomicex.Core API文档",
    "summary": "离线验证模型 [[toc]] 该验证模型实现了最基础的验证功能。通常用于本地调试和验证。 :::warning 在生产环节使用该验证模型在部分国家和地区可能会违反版权法或是最终用户协议，详见 Mojang 最终用户协议（英文） ::: 初始化验证器 您可以通过下面的代码初始化离线验证器： var offlineAuthenticator = new OfflineAuthenticator { LauncherAccountParser = launcherAccountParser, Username = \"[DISPLAY_NAME]\" }; 在上述代码块中，请将这些参数按照您的实际情况替换： 项目 说明 launcherAccountParser 对于启动器账户解析器的初始化，详见此处 [DISPLAY_NAME] 游戏中的显示名称，通常是由英文字符、符号以及数字组成 :::tip 对于 launcherAccountParser（游戏档案解析器）的初始化，请参考游戏档案解析器页面 ::: 获取验证结果 在您完成验证模型的初始化后，您只需要调用离线验证器的验证方法来完成账户验证。 在异步上下文中，使用 AuthTaskAsync 来完成验证： var authResult = await offlineAuthenticator.AuthTaskAsync(false); 在同步上下文中，使用 Auth 来完成验证： var authResult = offlineAuthenticator.Auth(); 解读验证结果 在验证方法完成之后，验证模型会返回验证结果，这是一个类型为 AuthResultBase 的对象。 所有的验证结果都包含一个枚举值 AuthStatus，该枚举值直接指示了验证结果的成功或是失败。 在下面您可以看到对验证结果的解读： 失败的验证结果 通过判断 Error 是否为空，您可以很轻松的判断验证模型返回的验证结果是否是有效的， Error 对象会包含以下字段来告诉您一些细节： 字段 说明 authResult.Error.Cause 导致问题的具体原因 authResult.Error.Error 错误名称 authResult.Error.ErrorMessage 错误的详细信息，可能包含解决方案 成功的验证结果 如果验证结果中的 Error 字段为空，则表示本次验证是有效的，成功的验证结果会包含下面的信息： 字段 说明 authResult.Id 该用户名的唯一标识符，ProjBobcat 使用特定的生成方式来生成这个标识符 authResult.AccessToken 用户账户的授权凭据，这对于离线验证模型是没有任何意义的 authResult.User.UUID 该用户的 UUID，与 authResult.Id 类似 authResult.User.Properties 用户的属性数组，对于离线验证模型来说，该数组只包含唯一一个有效值"
  },
  "temp/docs-main/zhCN/projbobcat/authenticators/yggdrasil.html": {
    "href": "temp/docs-main/zhCN/projbobcat/authenticators/yggdrasil.html",
    "title": "Yggdrasil 验证模型 | Qomicex.Core API文档",
    "summary": "Yggdrasil 验证模型 [[toc]] 该验证模型实现了旧版 Mojang 的验证方案，目前该方案已经被弃用。 ::: warning 继续使用该模型进行官方账户的验证将被视为无效的请求。 但该模型仍然可以用于登录使用第三方验证服务的服务器（例如 AuthLib-Injector）。 ::: 初始化验证器 您可以通过下面的代码初始化离线验证器： var yggdrasilAuthenticator = new YggdrasilAuthenticator { AuthServer = \"[CUSTOM_AUTH_SERVER]\", Email = \"[EMAIL]\", LauncherAccountParser = launcherAccountParser, Password = \"[PASSWORD]\" }; 在上述代码块中，请将这些参数按照您的实际情况替换： 项目 说明 launcherAccountParser 对于启动器账户解析器的初始化，详见此处 [CUSTOM_AUTH_SERVER] 可选字段，自定义验证服务器地址，这个字段通常由第三方验证服务提供商提供，不填则使用 Mojang 官方的验证服务器地址 [EMAIL] 验证账户的邮箱地址 [PASSWORD] 验证账户的密码 :::tip 对于 launcherAccountParser（游戏档案解析器）的初始化，请参考游戏档案解析器页面 ::: :::warning 在使用第三方验证服务器时，请使用 https:// 而非 http:// 协议连接到验证服务器。 使用不安全的验证服务器可能会导致敏感数据泄露等问题。 ::: 获取验证结果 在您完成验证模型的初始化后，您只需要调用离线验证器的验证方法来完成账户验证。 在异步上下文中，使用 AuthTaskAsync 来完成验证： var authResult = await offlineAuthenticator.AuthTaskAsync(false); 在同步上下文中，使用 Auth 来完成验证： var authResult = offlineAuthenticator.Auth(); 解读验证结果 在验证方法完成之后，验证模型会返回验证结果，这是父类型为 AuthResultBase 的对象。 所有的验证结果都包含一个枚举值 AuthStatus，该枚举值直接指示了验证结果的成功或是失败。 在下面您可以看到对验证结果的解读： 失败的验证结果 通过判断 Error 是否为空，您可以很轻松的判断验证模型返回的验证结果是否是有效的， Error 对象会包含以下字段来告诉您一些细节： 字段 说明 authResult.Error.Cause 导致问题的具体原因 authResult.Error.Error 错误名称 authResult.Error.ErrorMessage 错误的详细信息，可能包含解决方案 成功的验证结果 如果验证结果中的 Error 字段为空，则表示本次验证是有效的，成功的验证结果会包含下面的信息： 字段 说明 authResult.Id 该用户名的唯一标识符，ProjBobcat 使用特定的生成方式来生成这个标识符 authResult.AccessToken 用户账户的授权凭据 authResult.Profiles 用户可用的角色列表，可能包含多个可用角色 authResult.SelectedProfile 用户当前选择的角色，该字段可能为空。如果为空则需要提示用户进行手动选择。 authResult.User 用户账户信息摘要，包含一些基础的账户信息 authResult.LocalId 本地 ID，通常为随机生成的 UUID authResult.RemoteId 验证服务器返回的远程 ID，通常为该用户的唯一标识符"
  },
  "temp/docs-main/zhCN/projbobcat/beforeWeStart.html": {
    "href": "temp/docs-main/zhCN/projbobcat/beforeWeStart.html",
    "title": "在我们开始之前 | Qomicex.Core API文档",
    "summary": "在我们开始之前 在我们正式开始使用 ProjBobcat，您需要对您的项目属性做一下必要的检查和调整以满足 ProjBobcat 的运行需要。 [[toc]] 运行时要求 您需要保证您项目的 dotNET 框架至少运行在 .NET 6.0 及更高的版本当中以满足。 目前受支持的 .NET 版本： .NET 8.0 ::: warning 我们在先前的版本更新中已经移除了对 .NET 5.0、 .NET 6.0 与 .NET 7.0 运行时的支持。 ::: 项目属性 由于 Windows 系统机制，您需要在项目属性中关闭 首选 32 位 的生成选项。否则您在使用 ProjBobcat 部分组件时会出现预料之外的结果。 您需要在 Visual Studio 中切换到项目的属性页面，并找到 首选 32 位 的勾选框，并将其取消勾选。 32 位系统支持 ::: warning ProjBobcat 从项目立项开始就决定放弃对 32 位系统的全部支持，因为它真的很老，很老了（ :::"
  },
  "temp/docs-main/zhCN/projbobcat/createNewAzureApp.html": {
    "href": "temp/docs-main/zhCN/projbobcat/createNewAzureApp.html",
    "title": "配置 Azure 应用 | Qomicex.Core API文档",
    "summary": "配置 Azure 应用 [[toc]] 开始配置 在开始之前，您首先需要一个微软账号。注册 Azure Active Directory 应用无需任何费用。 使用您的微软账户登录 Azure 门户 在完成登录后，您看到的页面应该是这样的： 点击 Azure 服务 下的 Azure Active Directory 您将会看到类似于下面的页面 接着点击左侧功能栏的 应用注册： 点击顶部工具栏的 新注册，填写应用的名称。并且在 受支持的账户类型 中选择 仅 Microsoft 个人账户。 由于我们不使用基于 URI 回调的认证方式。因此，您不需要填写表单下方的 重定向 URI。 ::: warning 请仔细核对表单中的信息，否则可能会导致后续的步骤出现意料之外的问题。 ::: 点击创建后，等待 Azure AD 完成应用的创建。在创建完成后，网页会将您重定向至该应用的详细页面： 接着点击左侧栏的 身份验证： 接着在右侧找到 高级设置 板块，确保板块中的 高级 SDK 支持 和 允许公共客户端流 为开启状态。 如果他们没有开启，请手动将他们打开。 接着点击下方的保存按钮，等待保存完成。 查看 Client ID 恭喜！您已经完成了 Azure 的应用注册，接下来您只需要前往 概述 页面查看应用的 Client ID。 点击左侧栏的 概述 按钮，即可查看应用的基础信息： 在右侧您会看到应用的详细信息，在 概要 中找到 应用程序(客户端) ID， 该 ID 将是您需要在 微软验证器配置 阶段需要使用到的 Client ID。"
  },
  "temp/docs-main/zhCN/projbobcat/index.html": {
    "href": "temp/docs-main/zhCN/projbobcat/index.html",
    "title": "ProjBobcat 开发文档 | Qomicex.Core API文档",
    "summary": "ProjBobcat 开发文档 ProjBobcat 是一个由日冕开发组开发的高度自定义、高性能、功能完善的 Minecraft 启动器核心。在这里您可以查阅到各大组件的使用教程。 项目地址 GitHub - ProjBobcat"
  },
  "temp/docs-main/zhCN/projbobcat/installationAndConfig.html": {
    "href": "temp/docs-main/zhCN/projbobcat/installationAndConfig.html",
    "title": "安装并配置 ProjBobcat | Qomicex.Core API文档",
    "summary": "安装并配置 ProjBobcat [[toc]] 从发行包安装 Nuget 目前，您可以方便的从 Nuget 上搜索并下载 ProjBobcat 的软件包，您可以在 Visual Studio 的包管理器中搜索 ProjBobcat 并将其添加到您的项目中。 或者，您也可以手动在 “程序包管理器控制台” 中执行下面的命令： NuGet\\Install-Package ProjBobcat -Version 1.40.0 .NET CLI 要通过 .NET CLI 来安装 ProjBobcat，您只需要将终端切换到包含 .csproj 文件的项目目录，并在终端中执行： dotnet add package ProjBobcat --version 1.40.0 PackageReference PackageReference 是微软为现代 .NET 项目推出的一种新的软件包管理规范， 详细信息可以在 MSDN 中查看 您只需在项目的 [项目名].csproj 文件中添加： <PackageReference Include=\"ProjBobcat\" Version=\"1.40.0\" /> ::: tip 其中，1.140.0 为 ProjBobcat 的版本号，您可以将其替换为其他的版本号， 所有的发行版本都可以在 ProjBobcat - Nuget 中查看。 ::: 从源码引用 另外一种使用 ProjBobcat 的方法是直接添加代码仓库到您的项目引用。 ::: info 在执行下面的命令前，您可能需要先安装 Git CLI ::: 克隆 ProjBobcat 仓库 使用命令行切换到项目解决方案的根目录，并在命令行中执行下面的代码来完成仓库的克隆： git clone https://github.com/Corona-Studio/ProjBobcat.git 使用 Git Submodule（子模块）的方式拉取 ProjBobcat ::: tip Git Submodule 是一个非常实用的功能，在这里我们只展示了其最基本的用例。 在 Git 官方文档 中您可以查看到更多的使用案例。 ::: 使用命令行切换到项目解决方案的根目录，并在命令行中执行下面的代码来完成仓库的克隆： git submodule add https://github.com/Corona-Studio/ProjBobcat.git 添加对 ProjBobcat 的引用 接下来，在 Visual Studio 的 解决方案资源管理器 视图中，右键点击位于树状图顶层的解决方案名称。 并选择 “添加”-“现有项目”，并在文件浏览窗口中找到刚刚克隆的 ProjBobcat 项目文件夹中的 ProjBobcat.csproj。 接着，在 解决方案资源管理器 找到您需要引用 ProjBobcat 的项目，并右键单击，选择 “添加”-“项目引用”。 最后在弹出窗口中勾选 ProjBobcat 即可完成对其的引用。 使用前配置 修改默认连接数 在使用 ProjBobcat 之前，您需要在程序的入口点（通常是 App.xaml.cs 或 Program.cs） 中添加一些代码来初始化 ProjBobcat 的相关服务。 由于 .NET 运行时默认的最大连接数限制，在使用 ProjBobcat 下载模块时可能会遭遇性能瓶颈。 因此，您需要在入口处添加下面的代码来修改默认的最大连接数： using System.Net; ServicePointManager.DefaultConnectionLimit = 512; 注册并初始化基础服务 接下来，您需要在入口点添加这些代码来完成 ProjBobcat 服务的初始化： 初始化服务容器 ServiceHelper.Init(); 初始化 CurseForge API 服务（可选） 该服务为可选项目，如果您没有使用任何 CurseForge 相关服务，您可以忽略这个步骤。 ::: tip 在注册 CurseForge 服务前，您需要准备 CurseForge 官方下发的 API KEY。 如果您还没有，请前往 申请页面 - CurseForge 来获得您的 API KEY。 ::: ::: warning API KEY 为敏感的个人凭据，请妥善保存 API KEY 并不要将其泄露给其他人。 ::: CurseForgeAPIHelper.SetApiKey(\"[YOUR API KEY]\"); 将 [YOUR API KEY] 替换为您从 CurseForge 官方获取的 API KEY。 初始化下载服务 在初始化下载服务时您可以选择自定义请求时所使用的 User Agent（默认为 \"ProjBobcat\"）。 HttpClientHelper.Ua = \"[YOUR UA]\"; // 可选 配置微软登录验证器 关于 Azure Active Directory 应用具体的注册方法请移步： 如何注册 Azure 应用 ::: tip 在配置微软验证器前，您需要在 Azure 注册您的应用，并对其进行正确的配置。 在您完成配置之后，您会获得一串 Client ID。 相关资料： Azure 官网 Device code flow ::: ::: warning CLIENT ID 为敏感的个人凭据，请妥善保存 CLIENT ID 并不要将其泄露给其他人。 ::: MicrosoftAuthenticator.Configure(new MicrosoftAuthenticatorAPISettings { ClientId = \"[YOUR CLIENT ID]\", TenentId = \"consumers\", Scopes = new[] { \"XboxLive.signin\", \"offline_access\", \"openid\", \"profile\", \"email\" } }); 在取得 Client ID 后，将 [YOUR CLIENT ID] 替换为您的 Client ID。"
  },
  "temp/docs-main/zhCN/projbobcat/installers/curseforge.html": {
    "href": "temp/docs-main/zhCN/projbobcat/installers/curseforge.html",
    "title": "CurseForge 整合包安装器 | Qomicex.Core API文档",
    "summary": "CurseForge 整合包安装器 [[toc]] ::: tip 请注意，ProjBobcat 仅实现了 CurseForge 整合包的自动化安装流程，您仍然需要自己实现 CurseForge 整合包的搜索、下载、保存流程。 ::: 实用资源 CurseForge 官方网站 CurseForge API 初始化安装器 初始化 CurseForge 安装器的方式非常简单： var curseForgeInstaller = new CurseForgeInstaller { GameId = \"[CUSTOM_INSTALL_GAME_ID]\", ModPackPath = \"[PATH_TO_YOUR_MODPACK]\", RootPath = \"[GAME_ROOT_PATH]\" }; 在上述代码块中，请将这些参数按照您的实际情况替换： 项目 说明 [GAME_ROOT_PATH] 游戏根目录，通常为 .minecraft 文件夹的路径 [CUSTOM_INSTALL_GAME_ID] 可选项，自定义即将要安装的游戏的名称 [PATH_TO_YOUR_MODPACK] CurseForge 整合包所在的路径 开始安装 在您完成安装器的初始化后，您只需要调用 CurseForge 安装器的安装方法来完成安装。 在异步上下文中，使用 InstallTaskAsync 来完成安装： await curseForgeInstaller.InstallTaskAsync(); 在同步上下文中，使用 Install 来完成安装： curseForgeInstaller.Install(); 报告安装进度 在某些情况下，CurseForge 安装器可能会需要数分钟的时间来完成安装。 因此，您可能需要实时向用户汇报安装器目前的进度。 为此，CurseForge 安装器提供了 StageChangedEventDelegate 事件来帮助您实现任务汇报。 您只需要简单地在 开始安装之前 注册下面的事件： curseForgeInstaller.StageChangedEventDelegate += (_, args) => { ReportProgress(args.Progress, args.CurrentStage); }; 其中， args.Progress 指示了安装器当前的百分比进度。args.CurrentStage 则是安装器当前进度的文字描述。"
  },
  "temp/docs-main/zhCN/projbobcat/installers/fabric.html": {
    "href": "temp/docs-main/zhCN/projbobcat/installers/fabric.html",
    "title": "Fabric 安装器 | Qomicex.Core API文档",
    "summary": "Fabric 安装器 [[toc]] ::: tip 请注意，ProjBobcat 仅实现了 Fabric 自动化安装流程，您仍然需要自己实现 Fabric 安装包的搜索、下载、保存流程。 ::: 实用资源 Fabric 官方网站 Fabric Meta API 获取 Fabric Loader Artifact 由于 ProjBobcat 的 Fabric 安装器要求您在初始化安装器时提供来自 Fabric 官方的 Loader Artifact 信息。 因此，我们将在这里简要描述如何根据指定的 MineCraft 版本来获取该信息。 ::: info 在该示例中，我们将使用 MineCraft 1.19.2 来向您展示如何获取。 ::: 向 Fabric Meta API 发送请求 首先，您需要向 https://meta.fabricmc.net/v2/versions/loader/[MC_VERSION] 发送一个 HTTP GET 请求。 将 [MC_VERSION] 替换为您想要安装的 MineCraft 版本。在这里，我们将使用 1.19.2。 您将看到类似下面的返回内容： [ { \"loader\": { \"separator\": \".\", \"build\": 11, \"maven\": \"net.fabricmc:fabric-loader:0.14.11\", \"version\": \"0.14.11\", \"stable\": true }, \"intermediary\": { \"maven\": \"net.fabricmc:intermediary:1.19.2\", \"version\": \"1.19.2\", \"stable\": true }, \"launcherMeta\": { \"version\": 1, \"libraries\": {...}, \"mainClass\": {...} } }, {...}, {...} ] Fabric Meta API 将返回一个 JSON 数组，数组中的每一个元素即是我们需要的 Loader Artifact。 将 JSON 返回转换为 ProjBobcat 类型 如果您在您的项目中使用 JSON.NET（Newtonsoft.JSON）。 您可以使用类似下面的代码来将您获取到的服务器响应转换为对应的 ProjBobcat 类型： // 从 Fabric Meta API 请求数据（示例，非实际代码） ... var responseJson = await res.Content.ReadAsStringAsync(); // 将 JSON 响应转换为 ProjBobcat 类型 // [!code focus] var artifacts = JsonConvert.DeserializeObject<List<FabricLoaderArtifactModel>>(responseJson); // [!code focus] // 获取用户想要安装的版本（示例，非实际代码） var userSelect = vm.SelectedArtifactIndex; // 获取单个 Loader Artifact // [!code focus] var selectedArtifact = artifacts[userSelect]; // [!code focus] 此处，selectedArtifact 即是 Fabric 安装器所需要的 FabricLoaderArtifactModel。 初始化安装器 初始化 Fabric 安装器的方式非常简单。您需要使用到在先前步骤中取得的 selectedArtifact 来初始化安装器： var fabricInstaller = new FabricInstaller { LoaderArtifact = selectedArtifact, VersionLocator = [VERSION_LOCATOR_INST], RootPath = \"[GAME_ROOT_PATH]\", CustomId = \"[CUSTOM_INSTALL_GAME_ID]\", InheritsFrom = \"[MC_VERSION_OR_GAME_ID]\" }; 在上述代码块中，请将这些参数按照您的实际情况替换： 项目 说明 [GAME_ROOT_PATH] 游戏根目录，通常为 .minecraft 文件夹的路径 [CUSTOM_INSTALL_GAME_ID] 可选项，自定义即将要安装的游戏的名称 [MC_VERSION_OR_GAME_ID] Forge 继承的 MineCraft 原版游戏版本，通常为游戏版本。例如：1.19.2 [VERSION_LOCATOR_INST] 游戏版本定位器实例，即初始化游戏核心时的 VersionLocator 属性 开始安装 在您完成安装器的初始化后，您只需要调用 Fabric 安装器的安装方法来完成安装。 在异步上下文中，使用 InstallTaskAsync 来完成安装： await fabricInstaller.InstallTaskAsync(); 在同步上下文中，使用 Install 来完成安装： fabricInstaller.Install(); 报告安装进度 在某些情况下，Fabric 安装器可能会需要数分钟的时间来完成安装。 因此，您可能需要实时向用户汇报安装器目前的进度。 为此，Fabric 安装器提供了 StageChangedEventDelegate 事件来帮助您实现任务汇报。 您只需要简单地在 开始安装之前 注册下面的事件： fabricInstaller.StageChangedEventDelegate += (_, args) => { ReportProgress(args.Progress, args.CurrentStage); }; 其中， args.Progress 指示了安装器当前的百分比进度。args.CurrentStage 则是安装器当前进度的文字描述。"
  },
  "temp/docs-main/zhCN/projbobcat/installers/forge.html": {
    "href": "temp/docs-main/zhCN/projbobcat/installers/forge.html",
    "title": "Forge 安装器 | Qomicex.Core API文档",
    "summary": "Forge 安装器 在 ProjBobcat 中，我们支持了几乎所有主流 MineCraft 版本的 Forge 自动化安装。 [[toc]] ::: tip 请注意，ProjBobcat 仅实现了 Forge 自动化安装流程，您仍然需要自己实现 Forge 安装包的搜索、下载、保存流程。 ::: 判断应该使用哪一种 Forge 安装器 由于 Forge 团队在后续的版本中修改了 Forge 的打包规范以及安装流程。因此，您需要手动判断应该使用哪一种安装器。 在 ProjBobcat 中，我们已经为您实现了相关的判断逻辑。您只需要简单地调用下面的方法： var mcVersion = \"[MC_VERSION]\"; var forgeJarPath = \"[PATH_TO_YOUR_FORGE_INSTALLER]\"; var forgeVersion = ForgeInstallerFactory.GetForgeArtifactVersion(mcVersion，\"[FORGE_VERSION]\"); var isLegacy = ForgeInstallerFactory.IsLegacyForgeInstaller(forgeJarPath，forgeVersion); // [!code focus] 在上述代码块中，请将这些参数按照您的实际情况替换： 项目 说明 [MC_VERSION] 将 Forge 安装到的 MineCraft 版本，例如：1.19.2 [PATH_TO_YOUR_FORGE_INSTALLER] Forge 安装器 .jar 文件所在的路径 [FORGE_VERSION] Forge 的具体版本，通常为 XX.X.X，例如：43.2.0 在您完成替换并成功执行上述的代码片段之后，isLegacy 会指示当前 Forge 安装器应当使用哪一种 Forge 安装器。 初始化旧版安装器 如果在上面的流程中，isLegacy 的值为 true，这意味着您需要使用旧版安装器来完成 Forge 的安装。 要初始化旧版安装器，只需实例化 LegacyForgeInstaller 并提供相应的参数： IForgeInstaller forgeInstaller = new LegacyForgeInstaller { ForgeExecutablePath = \"[PATH_TO_YOUR_FORGE_INSTALLER]\", RootPath = \"[GAME_ROOT_PATH]\", CustomId = \"[CUSTOM_INSTALL_GAME_ID]\", ForgeVersion = \"[FORGE_VERSION]\", InheritsFrom = \"[MC_VERSION_OR_GAME_ID]\" }; 在上述代码块中，请将这些参数按照您的实际情况替换： 项目 说明 [GAME_ROOT_PATH] 游戏根目录，通常为 .minecraft 文件夹的路径 [CUSTOM_INSTALL_GAME_ID] 可选项，自定义即将要安装的游戏的名称 [MC_VERSION_OR_GAME_ID] Forge 继承的 MineCraft 原版游戏版本，通常为游戏版本。例如：1.19.2 初始化新版安装器 IForgeInstaller forgeInstaller = new HighVersionForgeInstaller { ForgeExecutablePath = \"[PATH_TO_YOUR_FORGE_INSTALLER]\", JavaExecutablePath = \"[PATH_TO_YOUR_JAVA_RUNTIME]\", RootPath = \"[GAME_ROOT_PATH]\", VersionLocator = [VERSION_LOCATOR_INST], DownloadUrlRoot = \"[LIBRARIES_URL_ROOT]\", CustomId = \"[CUSTOM_INSTALL_GAME_ID]\", MineCraftVersion = \"[MC_VERSION]\", MineCraftVersionId = \"[ACTUAL_MC_GAME_ID]\", InheritsFrom = \"[MC_VERSION_OR_GAME_ID]\" }; 在上述代码块中，请将这些参数按照您的实际情况替换： 项目 说明 [PATH_TO_YOUR_JAVA_RUNTIME] Java （javaw.exe） 运行时所在的路径 [LIBRARIES_URL_ROOT] 下载源的根 URL，例如：\"https://bmclapi2.bangbang93.com/\" [VERSION_LOCATOR_INST] 游戏版本定位器实例，即初始化游戏核心时的 VersionLocator 属性 [ACTUAL_MC_GAME_ID] 实际的 MineCraft 游戏名称，即原版游戏在 version 文件夹下的名称。一般情况下，这个值和 [MC_VERSION] 一致。 根据 isLegacy 值进行统一初始化 由于 LegacyForgeInstaller 和 HighVersionForgeInstaller 同时实现了 IForgeInstaller 接口。 因此，您可以很方便的使用一个三元运算符来选择性的初始化对应的安装器： var isLegacy = ForgeInstallerFactory.IsLegacyForgeInstaller(forgeJarPath，forgeVersion); IForgeInstaller forgeInstaller = isLegacy ? new LegacyForgeInstaller { ForgeExecutablePath = \"[PATH_TO_YOUR_FORGE_INSTALLER]\", RootPath = \"[GAME_ROOT_PATH]\", CustomId = \"[CUSTOM_INSTALL_GAME_ID]\", ForgeVersion = \"[FORGE_VERSION]\", InheritsFrom = \"[MC_VERSION_OR_GAME_ID]\" } : new HighVersionForgeInstaller { ForgeExecutablePath = \"[PATH_TO_YOUR_FORGE_INSTALLER]\", JavaExecutablePath = \"[PATH_TO_YOUR_JAVA_RUNTIME]\", RootPath = \"[GAME_ROOT_PATH]\", VersionLocator = [VERSION_LOCATOR_INST], DownloadUrlRoot = \"[LIBRARIES_URL_ROOT]\", CustomId = \"[CUSTOM_INSTALL_GAME_ID]\", MineCraftVersion = \"[MC_VERSION]\", MineCraftVersionId = \"[ACTUAL_MC_GAME_ID]\", InheritsFrom = \"[MC_VERSION_OR_GAME_ID]\" }; 开始安装 在您完成安装器的初始化后，您只需要调用 Forge 安装器的安装方法来完成安装。 在异步上下文中，使用 InstallForgeTaskAsync 来完成安装： await forgeInstaller.InstallForgeTaskAsync(); 在同步上下文中，使用 InstallForge 来完成安装： forgeInstaller.InstallForge(); 报告安装进度 在某些情况下，Forge 安装器可能会需要数分钟的时间来完成安装。 因此，您可能需要实时向用户汇报安装器目前的进度。 为此，Forge 安装器提供了 StageChangedEventDelegate 事件来帮助您实现任务汇报。 您只需要简单地在 开始安装之前 注册下面的事件： ((InstallerBase)forgeInstaller).StageChangedEventDelegate += (_, args) => { ReportProgress(args.Progress * 100, args.CurrentStage); }; 其中， args.Progress 指示了安装器当前的百分比进度。args.CurrentStage 则是安装器当前进度的文字描述。"
  },
  "temp/docs-main/zhCN/projbobcat/installers/index.html": {
    "href": "temp/docs-main/zhCN/projbobcat/installers/index.html",
    "title": "安装器 | Qomicex.Core API文档",
    "summary": "安装器 在 ProjBobcat 中，我们已经为开发者实现了您在 MineCraft 开发过程中可能遇到的大部分模组基础设施。 支持列表 项目名称 支持状态 Forge （旧版） 受支持 ✅ Forge （新版） 受支持 ✅ LiteLoader 受支持 ✅ Fabric 受支持 ✅ Optifine 受支持 ✅ Quilt 受支持（实验性） ⚠ CurseForge 整合包 受支持 ✅"
  },
  "temp/docs-main/zhCN/projbobcat/installers/liteloader.html": {
    "href": "temp/docs-main/zhCN/projbobcat/installers/liteloader.html",
    "title": "LiteLoader 安装器 | Qomicex.Core API文档",
    "summary": "LiteLoader 安装器 [[toc]] ::: tip 请注意，ProjBobcat 仅实现了 LiteLoader 自动化安装流程，您仍然需要自己实现 LiteLoader 安装包的搜索、下载、保存流程。 ::: ::: warning LiteLoader 作为早期 MineCraft 的模组系统，已经长期缺乏维护和后续支持。 因此，我们可能会在后续的版本中移除对 LiteLoader 安装的支持。 ::: 实用资源 LiteLoader Versions API BMCLAPI 开发文档 获取 LiteLoader Download Version Model 由于 ProjBobcat 的 LiteLoader 安装器要求您在初始化安装器时提供来自 LiteLoader 的下载信息。 因此，我们将在这里简要描述如何根据指定的 MineCraft 版本来获取该信息。 ::: info 在该示例中，我们将使用 MineCraft 1.7.10 来向您展示如何获取。 ::: ::: warning 由于 LiteLoader 官方没有提供公开的 API 文档。因此，在本流程中，我们需要使用第三方的镜像源来完成数据的获取。 在这里，我们使用 BMCLAPI 来获取相关的版本信息。 ::: 首先，您需要向 https://bmclapi2.bangbang93.com/liteloader/list?mcversion=[MC_VERSION] 发送一个 HTTP GET 请求。 将 [MC_VERSION] 替换为您想要安装的 MineCraft 版本。在这里，我们将使用 1.7.10。 您将看到类似下面的返回内容： { \"_id\": \"59685511433f993503c1c879\", \"mcversion\": \"1.7.10\", \"build\": { \"tweakClass\": \"com.mumfrey.liteloader.launch.LiteLoaderTweaker\", \"libraries\": [...], \"stream\": \"RELEASE\", \"file\": \"liteloader-1.7.10.jar\", \"version\": \"1.7.10_04\", \"md5\": \"63ada46e033d0cb6782bada09ad5ca4e\", \"timestamp\": \"1414368553\", \"srcJar\": \"liteloader-1.7.10_04-mcpnames-sources.jar\", \"mcpJar\": \"liteloader-1.7.10_04-mcpnames.jar\" }, \"hash\": \"63ada46e033d0cb6782bada09ad5ca4e\", \"type\": \"RELEASE\", \"version\": \"1.7.10_04\", \"__v\": 0 } BMCLAPI 将返回一个 JSON 对象，将该对象反序列化为 ProjBobcat 类型即是我们需要的 LiteLoaderDownloadVersionModel。 将 JSON 返回转换为 ProjBobcat 类型 如果您在您的项目中使用 JSON.NET（Newtonsoft.JSON）。 您可以使用类似下面的代码来将您获取到的服务器响应转换为对应的 ProjBobcat 类型： // 从 BMCLAPI 请求数据（示例，非实际代码） ... var responseJson = await res.Content.ReadAsStringAsync(); // 将 JSON 响应转换为 ProjBobcat 类型 // [!code focus] var versionModel = JsonConvert.DeserializeObject<LiteLoaderDownloadVersionModel>(responseJson); // [!code focus] 此处，versionModel 即是 Fabric 安装器所需要的 LiteLoaderDownloadVersionMode。 获取 RawVersionModel 在初始化 LiteLoader 安装器时，安装器需要使用 LiteLoader 对应的 MineCraft 游戏版本的原始 JSON 内容。 即 [ROOT_PATH]/versions/[MC_VERSION]/[MC_VERSION].json 文件的内容。 如果您已经安装了 LiteLoader 对应的原版游戏，您可以通过下面的代码获取到 RawVersionModel： // 获取版本 JSON 文件所在的路径 var jsonPath = GamePathHelper.GetGameJsonPath(rP，id); // 读取该文件的内容 var jsonContent = await File.ReadAllTextAsync(jsonPath); // 将 JSON 内容转换为 RawVersionModel var baseVersionModel = JsonConvert.DeserializeObject<RawVersionModel>(jsonContent); 此处，baseVersionModel 即是 LiteLoader 安装器所需要的 RawVersionModel。 初始化安装器 初始化 LiteLoader 安装器的方式非常简单。 您需要使用到在先前步骤中取得的 versionModel 和 baseVersionModel 来初始化安装器： var liteLoaderInstaller = new LiteLoaderInstaller { InheritVersion = baseVersionModel, InheritsFrom = \"[MC_VERSION_OR_GAME_ID]\", RootPath = \"[GAME_ROOT_PATH]\", VersionModel = versionModel, CustomId = \"[CUSTOM_INSTALL_GAME_ID]\" }; 在上述代码块中，请将这些参数按照您的实际情况替换： 项目 说明 [GAME_ROOT_PATH] 游戏根目录，通常为 .minecraft 文件夹的路径 [CUSTOM_INSTALL_GAME_ID] 可选项，自定义即将要安装的游戏的名称 [MC_VERSION_OR_GAME_ID] Forge 继承的 MineCraft 原版游戏版本，通常为游戏版本。例如：1.19.2 [VERSION_LOCATOR_INST] 游戏版本定位器实例，即初始化游戏核心时的 VersionLocator 属性 开始安装 在您完成安装器的初始化后，您只需要调用 LiteLoader 安装器的安装方法来完成安装。 在异步上下文中，使用 InstallTaskAsync 来完成安装： await liteLoaderInstaller.InstallTaskAsync(); 在同步上下文中，使用 Install 来完成安装： liteLoaderInstaller.Install(); 报告安装进度 在某些情况下，LiteLoader 安装器可能会需要数分钟的时间来完成安装。 因此，您可能需要实时向用户汇报安装器目前的进度。 为此，LiteLoader 安装器提供了 StageChangedEventDelegate 事件来帮助您实现任务汇报。 您只需要简单地在 开始安装之前 注册下面的事件： liteLoaderInstaller.StageChangedEventDelegate += (_，args) => { ReportProgress(args.Progress，args.CurrentStage); }; 其中， args.Progress 指示了安装器当前的百分比进度。args.CurrentStage 则是安装器当前进度的文字描述。"
  },
  "temp/docs-main/zhCN/projbobcat/installers/optifine.html": {
    "href": "temp/docs-main/zhCN/projbobcat/installers/optifine.html",
    "title": "Optifine 安装器 | Qomicex.Core API文档",
    "summary": "Optifine 安装器 [[toc]] ::: tip 请注意，ProjBobcat 仅实现了 Optifine 自动化安装流程，您仍然需要自己实现 Optifine 安装包的搜索、下载、保存流程。 ::: 实用资源 BMCLAPI 开发文档 获取 Optifine Download Version Model 由于 ProjBobcat 的 LiteLoader 安装器要求您在初始化安装器时提供来自 LiteLoader 的下载信息。 因此，我们将在这里简要描述如何根据指定的 MineCraft 版本来获取该信息。 ::: info 在该示例中，我们将使用 MineCraft 1.19.2 来向您展示如何获取。 ::: ::: warning 由于 Optifine 官方没有提供公开的 API 文档。因此，在本流程中，我们需要使用第三方的镜像源来完成数据的获取。 在这里，我们使用 BMCLAPI 来获取相关的版本信息。 ::: 首先，您需要向 https://bmclapi2.bangbang93.com/optifine/[MC_VERSION] 发送一个 HTTP GET 请求。 将 [MC_VERSION] 替换为您想要安装的 MineCraft 版本。在这里，我们将使用 1.19.2。 您将看到类似下面的返回内容： [ { \"_id\": \"6307b8a38a3998ab475d139d\", \"mcversion\": \"1.19.2\", \"patch\": \"H9\", \"type\": \"HD_U\", \"__v\": 0, \"filename\": \"OptiFine_1.19.2_HD_U_H9.jar\", \"forge\": \"Forge 43.1.1\" }, {...}, {...} ] BMCLAPI 将返回一个 JSON 数组，数组中的每一个元素即是我们需要的 Download Version Model。 将 JSON 返回转换为 ProjBobcat 类型 如果您在您的项目中使用 JSON.NET（Newtonsoft.JSON）。 您可以使用类似下面的代码来将您获取到的服务器响应转换为对应的 ProjBobcat 类型： // 从 BMCLAPI 请求数据（示例，非实际代码） ... var responseJson = await res.Content.ReadAsStringAsync(); // 将 JSON 响应转换为 ProjBobcat 类型 // [!code focus] var versions = JsonConvert.DeserializeObject<List<OptifineDownloadVersionModel>>(responseJson); // [!code focus] // 获取用户想要安装的版本（示例，非实际代码） var userSelect = vm.SelectedIndex; // 获取单个 Download Version Model // [!code focus] var selectedVersion = versions[userSelect]; // [!code focus] 此处，selectedVersion 即是 Optifine 安装器所需要的 OptifineDownloadVersionModel。 初始化安装器 初始化 Optifine 安装器的方式非常简单。 您首先需要准备好的 Optifine 安装包 .jar 文件。以及一个可用的 Java 运行时。 您需要使用到在先前步骤中取得的 selectedVersion 来初始化安装器： var optifineInstaller = new OptifineInstaller { JavaExecutablePath = \"[PATH_TO_YOUR_JAVA_RUNTIME]\", OptifineDownloadVersion = selectedVersion, OptifineJarPath = \"[PATH_TO_YOUR_OPTIFINE_JAR]\", RootPath = \"[GAME_ROOT_PATH]\", CustomId = \"[CUSTOM_INSTALL_GAME_ID]\", InheritsFrom = \"[MC_VERSION_OR_GAME_ID]\" }; 在上述代码块中，请将这些参数按照您的实际情况替换： 项目 说明 [GAME_ROOT_PATH] 游戏根目录，通常为 .minecraft 文件夹的路径 [CUSTOM_INSTALL_GAME_ID] 可选项，自定义即将要安装的游戏的名称 [MC_VERSION_OR_GAME_ID] Forge 继承的 MineCraft 原版游戏版本，通常为游戏版本。例如：1.19.2 [VERSION_LOCATOR_INST] 游戏版本定位器实例，即初始化游戏核心时的 VersionLocator 属性 [PATH_TO_YOUR_OPTIFINE_JAR] Optifine 安装包所在的路径 [PATH_TO_YOUR_JAVA_RUNTIME] Java （javaw.exe） 运行时所在的路径 开始安装 在您完成安装器的初始化后，您只需要调用 Optifine 安装器的安装方法来完成安装。 在异步上下文中，使用 InstallTaskAsync 来完成安装： await optifineInstaller.InstallTaskAsync(); 在同步上下文中，使用 Install 来完成安装： optifineInstaller.Install(); 报告安装进度 在某些情况下，Optifine 安装器可能会需要数分钟的时间来完成安装。 因此，您可能需要实时向用户汇报安装器目前的进度。 为此，Optifine 安装器提供了 StageChangedEventDelegate 事件来帮助您实现任务汇报。 您只需要简单地在 开始安装之前 注册下面的事件： optifineInstaller.StageChangedEventDelegate += (_, args) => { ReportProgress(args.Progress, args.CurrentStage); }; 其中， args.Progress 指示了安装器当前的百分比进度。args.CurrentStage 则是安装器当前进度的文字描述。"
  },
  "temp/docs-main/zhCN/projbobcat/installers/quilt.html": {
    "href": "temp/docs-main/zhCN/projbobcat/installers/quilt.html",
    "title": "Quilt 安装器 | Qomicex.Core API文档",
    "summary": "Quilt 安装器 [[toc]] ::: tip 请注意，ProjBobcat 仅实现了 Quilt 自动化安装流程，您仍然需要自己实现 Quilt 安装包的搜索、下载、保存流程。 ::: ::: warning Quilt 安装器目前处于试验阶段，相关的 API 以及安装流程可能会出现较大幅度的变更。 ::: 实用资源 Quilt 官方网站 Quilt 安装指南 Quilt Meta API 兼容性检查 在开始安装 Quilt 之前，您需要通过 Quilt Meta API 来查询您将要修改的 MineCraft 版本是否受支持。 首先，您需要向 https://meta.quiltmc.org/v3/versions/game 发送一个 HTTP GET 请求。 您将看到类似下面的返回内容： [ { \"version\": \"1.19.3\", \"stable\": true }, { \"version\": \"1.19.3-rc3\", \"stable\": false }, {...}, {...} ] 在这里，您需要检查您即将要安装的游戏版本是否出现在 Quilt 官方的支持列表当中。 您需要将游戏版本与 JSON 对象中的 version 字段作比较。 如果您的游戏没有出现在支持列表当中，安装将无法继续。 获取 Quilt Loader Model 由于 ProjBobcat 的 Quilt 安装器要求您在初始化安装器时提供来自 Quilt 的下载信息。 因此，我们将在这里简要描述如何根据指定的 MineCraft 版本来获取该信息。 ::: info 在该示例中，我们将使用 MineCraft 1.19.2 来向您展示如何获取。 ::: 首先，您需要向 https://meta.quiltmc.org/v3/versions/loader 发送一个 HTTP GET 请求。 您将看到类似下面的返回内容： [ { \"separator\": \".\", \"build\": 25, \"maven\": \"org.quiltmc:quilt-loader:0.18.1-beta.25\", \"version\": \"0.18.1-beta.25\" }, {...}, {...} ] Quilt Meta API 将返回一个 JSON 数组，数组中的每一个元素即是我们需要的 Loader Artifact。 将 JSON 返回转换为 ProjBobcat 类型 如果您在您的项目中使用 JSON.NET（Newtonsoft.JSON）。 您可以使用类似下面的代码来将您获取到的服务器响应转换为对应的 ProjBobcat 类型： // 从 Quilt Meta API 请求数据（示例，非实际代码） ... var responseJson = await res.Content.ReadAsStringAsync(); // 将 JSON 响应转换为 ProjBobcat 类型 // [!code focus] var artifacts = JsonConvert.DeserializeObject<List<QuiltLoaderModel>>(responseJson); // [!code focus] // 获取用户想要安装的版本（示例，非实际代码） var userSelect = vm.SelectedArtifactIndex; // 获取单个 Loader Artifact // [!code focus] var selectedArtifact = artifacts[userSelect]; // [!code focus] 此处，selectedArtifact 即是 Fabric 安装器所需要的 QuiltLoaderModel。 初始化安装器 初始化 Quilt 安装器的方式非常简单。您需要使用到在先前步骤中取得的 selectedArtifact 来初始化安装器： var quiltInstaller = new QuiltInstaller { InheritsFrom = \"[MC_VERSION_OR_GAME_ID]\", RootPath = \"[GAME_ROOT_PATH]\", CustomId = \"[CUSTOM_INSTALL_GAME_ID]\", LoaderArtifact = selectedArtifact }; 在上述代码块中，请将这些参数按照您的实际情况替换： 项目 说明 [GAME_ROOT_PATH] 游戏根目录，通常为 .minecraft 文件夹的路径 [CUSTOM_INSTALL_GAME_ID] 可选项，自定义即将要安装的游戏的名称 [MC_VERSION_OR_GAME_ID] Forge 继承的 MineCraft 原版游戏版本，通常为游戏版本。例如：1.19.2 开始安装 在您完成安装器的初始化后，您只需要调用 Fabric 安装器的安装方法来完成安装。 在异步上下文中，使用 InstallTaskAsync 来完成安装： await quiltInstaller.InstallTaskAsync(); 在同步上下文中，使用 Install 来完成安装： quiltInstaller.Install(); 报告安装进度 在某些情况下，Quilt 安装器可能会需要数分钟的时间来完成安装。 因此，您可能需要实时向用户汇报安装器目前的进度。 为此，Quilt 安装器提供了 StageChangedEventDelegate 事件来帮助您实现任务汇报。 您只需要简单地在 开始安装之前 注册下面的事件： quiltInstaller.StageChangedEventDelegate += (_, args) => { ReportProgress(args.Progress, args.CurrentStage); }; 其中， args.Progress 指示了安装器当前的百分比进度。args.CurrentStage 则是安装器当前进度的文字描述。"
  },
  "temp/docs-main/zhCN/projbobcat/resourceCompleter/createAndConfigCompleter.html": {
    "href": "temp/docs-main/zhCN/projbobcat/resourceCompleter/createAndConfigCompleter.html",
    "title": "创建和配置补全器 | Qomicex.Core API文档",
    "summary": "创建和配置补全器 [[toc]] 初始化补全器 创建一个资源补全器的方法非常简单，您只需要使用下面的代码即可完成补全器的初始化： var completer = new DefaultResourceCompleter { MaxDegreeOfParallelism = [MAX_DEGREE_OF_PARALLELISM], ResourceInfoResolvers = new List<IResourceInfoResolver> { ..。// 资源信息解析器的初始化 }, TotalRetry = [NUMBER_OF_TOTAL_RETRY], CheckFile = [CHECK_FILE_AFTER_DOWNLOADED], DownloadParts = [TOTAL_DOWNLOAD_SEGMENTS_FOR_LARGE_FILE] }; ::: tip 资源信息解析器的初始化相关教程请参见 资源信息解析器 章节 ::: 在上述代码块中，请将这些参数按照您的实际情况替换： 项目 数据类型 说明 [MAX_DEGREE_OF_PARALLELISM] INT 资源检查并行程度（同时检查游戏资源的数量） [CHECK_FILE_AFTER_DOWNLOADED] BOOLEAN 在文件下载完成后检查文件完整性（如果存在资源校检码） [TOTAL_DOWNLOAD_SEGMENTS_FOR_LARGE_FILE] INT 大文件下载时的分片数量 ::: warning [MAX_DEGREE_OF_PARALLELISM] 和 [TOTAL_DOWNLOAD_SEGMENTS_FOR_LARGE_FILE] 的数值大小请视硬件性能酌情调整，设置过大的数值可能会导致会导致吞吐量的下降。 ::: 补全游戏资源 在完成资源补全器的初始化操作后，您只需要调用补全方法即可开始执行检查和补全操作： 在异步上下文中，使用 CheckAndDownloadTaskAsync 来完成安装： var result = await completer.CheckAndDownloadTaskAsync(); // [!code focus] if (result.TaskStatus == TaskResultStatus.Error && (result.Value?.IsLibDownloadFailed ?? false)) { // 在完成补全后，资源检查器会返回执行结果。 // 您可以检查 result 中的属性值来确定补全是否完成 // IsLibDownloadFailed 会反映启动必须的库文件是否已经成功补全 // 通常来说，如果库文件的补全失败，很有可能会导致游戏的启动失败 } 在同步上下文中，使用 CheckAndDownload 来完成安装： var result = completer.CheckAndDownload(); // [!code focus] 报告进度 在某些情况下，资源补全器可能会需要数分钟的时间来完成资源的检查和下载。 因此，您可能需要实时向用户汇报补全器目前的进度。 报告资源检查器的进度 您可以通过注册事件 GameResourceInfoResolveStatus 来获取实时的检查进度： completer.GameResourceInfoResolveStatus += (_, args) => { ReportProgress(args.Progress, args.Status); }; 其中， args.Progress 指示了检查器当前的百分比进度。args.Status 则是检查器当前进度的文字描述。 报告补全器文件下载进度 您可以通过注册事件 DownloadFileCompletedEvent 来获取实时的检查进度： completer.DownloadFileCompletedEvent += (sender, args) => { // sender 参数为补全器上一个成功下载的文件，类型为 DownloadFile // args 返回了该文件的下载状态（成功 / 失败），以及文件的重试计数， // 类型为 DownloadFileCompletedEventArgs }; ::: tip DownloadFile 类结构 DownloadFileCompletedEventArgs 事件结构 ::: 报告下载中的文件的进度信息 您可以通过注册事件 DownloadFileChangedEvent 来获取实时的检查进度： rC.DownloadFileChangedEvent += (_, args) => { // args 返回了下载中的文件的具体信息（已接收的字节数、总共的字节数、当前速度、百分比进度） // 类型为 DownloadFileChangedEventArgs }; ::: tip DownloadFileChangedEventArgs 事件结构 :::"
  },
  "temp/docs-main/zhCN/projbobcat/resourceCompleter/index.html": {
    "href": "temp/docs-main/zhCN/projbobcat/resourceCompleter/index.html",
    "title": "资源补全器 | Qomicex.Core API文档",
    "summary": "资源补全器 在 ProjBobcat 中，我们为开发者提供了用于补全 MineCraft 核心资源文件的补全器。 这些资源包括：游戏音频、材质、贴图、语言文件、启动所必须的库文件等。"
  },
  "temp/docs-main/zhCN/projbobcat/resourceCompleter/resourceInfoResolver/assetInfoResolver.html": {
    "href": "temp/docs-main/zhCN/projbobcat/resourceCompleter/resourceInfoResolver/assetInfoResolver.html",
    "title": "Assets 解析器 | Qomicex.Core API文档",
    "summary": "Assets 解析器 [[toc]] Assets 解析器提供了对游戏资产文件的解析和验证功能，这些文件一般存放在 .minecraft/assets 目录下 获取 Version Manifest Versions 列表 首先，您需要向 https://launchermeta.mojang.com/mc/game/version_manifest.json 发送一个 HTTP GET 请求。 您将看到类似下面的返回内容： { \"latest\": { \"release\": \"1.19.3\", \"snapshot\": \"23w06a\" }, \"versions\": [ { \"id\": \"23w06a\", \"type\": \"snapshot\", \"url\": \"https://piston-meta.mojang.com/v1/packages/92ed97b686fe8904d8ec00fd486c435582fd0155/23w06a.json\", \"time\": \"2023-02-08T15:11:06+00:00\", \"releaseTime\": \"2023-02-08T15:00:04+00:00\" }, ... ] } Mojang 服务器将会返回一个 JSON 对象，versions 字段则是我们所需要的 Versions 数组 将 JSON 返回转换为 ProjBobcat 类型 如果您在您的项目中使用 JSON.NET（Newtonsoft.JSON）。 您可以使用类似下面的代码来将您获取到的服务器响应转换为对应的 ProjBobcat 类型： // 从 Mojang API 请求数据（示例，非实际代码） ... var responseJson = await res.Content.ReadAsStringAsync(); // 将 JSON 响应转换为 ProjBobcat 类型 // [!code focus] var manifest = JsonConvert.DeserializeObject<VersionManifest>(responseJson); // [!code focus] // 获取 Versions 列表 // [!code focus] var versions = manifest.Versions; // [!code focus] 此处，versions 即是 Assets 解析器所需要的 Versions 数组。 初始化解析器 你可以通过下面的代码来初始化 Assets 解析器： var resolver = new AssetInfoResolver { AssetIndexUriRoot = \"https://launchermeta.mojang.com/\", AssetUriRoot = \"https://resources.download.minecraft.net/\", BasePath = \"[GAME_ROOT_PATH]\", VersionInfo = [SEARCHED_VERSION_INFO], CheckLocalFiles = [CHECK_LOCAL_FILES], Versions = versions // 在上一步获取到的 Versions 数组 }; 在上述代码块中，请将这些参数按照您的实际情况替换： 项目 说明 [GAME_ROOT_PATH] 游戏根目录，通常为 .minecraft 文件夹的路径 [SEARCHED_VERSION_INFO] 要检查的版本的 VersionInfo （通过游戏定位器获得） [CHECK_LOCAL_FILES] 检查本地文件（如果为 false，则跳过所有检查）"
  },
  "temp/docs-main/zhCN/projbobcat/resourceCompleter/resourceInfoResolver/gameLoggingInfoResolver.html": {
    "href": "temp/docs-main/zhCN/projbobcat/resourceCompleter/resourceInfoResolver/gameLoggingInfoResolver.html",
    "title": "log4j 日志格式化组件解析器 | Qomicex.Core API文档",
    "summary": "log4j 日志格式化组件解析器 [[toc]] log4j 日志格式化组件解析器提供了对游戏资产文件的解析和验证功能，这些文件存放在 .minecraft/logging 目录下 使用该资源解析器可以使 MineCraft 输出经过 log4j 格式化后的日志内容，类似于如下的内容： <log4j:Event logger=\"ekb\" timestamp=\"1676012129\" level=\"INFO\" thread=\"Render thread\"> <log4j:Message> <![CDATA[Created: 512x512x4 minecraft:textures/atlas/shulker_boxes.png-atlas]]> </log4j:Message> </log4j:Event> 初始化解析器 你可以通过下面的代码来初始化 log4j 日志格式化组件解析器： var resolver = new GameLoggingInfoResolver { BasePath = \"[GAME_ROOT_PATH]\", VersionInfo = [SEARCHED_VERSION_INFO], CheckLocalFiles = [CHECK_LOCAL_FILES] }; 在上述代码块中，请将这些参数按照您的实际情况替换： 项目 说明 [GAME_ROOT_PATH] 游戏根目录，通常为 .minecraft 文件夹的路径 [SEARCHED_VERSION_INFO] 要检查的版本的 VersionInfo （通过游戏定位器获得） [CHECK_LOCAL_FILES] 检查本地文件（如果为 false，则跳过所有检查）"
  },
  "temp/docs-main/zhCN/projbobcat/resourceCompleter/resourceInfoResolver/index.html": {
    "href": "temp/docs-main/zhCN/projbobcat/resourceCompleter/resourceInfoResolver/index.html",
    "title": "资源信息解析器 | Qomicex.Core API文档",
    "summary": "资源信息解析器 在 ProjBobcat 中，我们使用 资源信息解析器（ResourceInfoResolver） 来帮助资源补全器确定 MineCraft 缺失的文件。 下表展示了目前 ProjBobcat 所支持的资源解析器： 类名 简介 AssetInfoResolver 用于解析游戏所需要的资产（音频、语言、字体和贴图等） GameLoggingInfoResolver 用于解析 MineCraft 官方所提供的 log4j 日志格式化组件 LibraryInfoResolver 用于解析游戏启动所必须的库文件 VersionInfoResolver 用于解析游戏 JSON 中提供的 JAR 文件"
  },
  "temp/docs-main/zhCN/projbobcat/resourceCompleter/resourceInfoResolver/libraryInfoResolver.html": {
    "href": "temp/docs-main/zhCN/projbobcat/resourceCompleter/resourceInfoResolver/libraryInfoResolver.html",
    "title": "Libraries 解析器 | Qomicex.Core API文档",
    "summary": "Libraries 解析器 [[toc]] Libraries 解析器提供了对游戏资产文件的解析和验证功能，这些文件存放在 .minecraft/libraries 目录下，这些文件是启动 MineCraft 所必需的运行时文件。 初始化解析器 你可以通过下面的代码来初始化 Libraries 解析器： var resolver = new LibraryInfoResolver { BasePath = \"[GAME_ROOT_PATH]\", ForgeUriRoot = \"https://files.minecraftforge.net/maven/\", ForgeMavenUriRoot = \"https://maven.minecraftforge.net/\", ForgeMavenOldUriRoot = \"https://files.minecraftforge.net/maven/\", FabricMavenUriRoot = \"https://maven.fabricmc.net/\", LibraryUriRoot = \"https://libraries.minecraft.net/\", VersionInfo = [SEARCHED_VERSION_INFO], CheckLocalFiles = [CHECK_LOCAL_FILES] }; 在上述代码块中，请将这些参数按照您的实际情况替换： 项目 说明 [GAME_ROOT_PATH] 游戏根目录，通常为 .minecraft 文件夹的路径 [SEARCHED_VERSION_INFO] 要检查的版本的 VersionInfo （通过游戏定位器获得） [CHECK_LOCAL_FILES] 检查本地文件（如果为 false，则跳过所有检查）"
  },
  "temp/docs-main/zhCN/projbobcat/resourceCompleter/resourceInfoResolver/versionInfoResolver.html": {
    "href": "temp/docs-main/zhCN/projbobcat/resourceCompleter/resourceInfoResolver/versionInfoResolver.html",
    "title": "版本信息解析器 | Qomicex.Core API文档",
    "summary": "版本信息解析器 [[toc]] 版本信息解析器提供了对游戏资产文件的解析和验证功能，这些文件存放在 .minecraft/versions/{GAME_VERSION}/{GAME_VERSION}.jar 目录下，这些文件是启动 MineCraft 所必需的核心文件。 初始化解析器 你可以通过下面的代码来初始化初始化解析器： var resolver = new VersionInfoResolver { BasePath = \"[GAME_ROOT_PATH]\", VersionInfo = [SEARCHED_VERSION_INFO], CheckLocalFiles = [CHECK_LOCAL_FILES] }; 在上述代码块中，请将这些参数按照您的实际情况替换： 项目 说明 [GAME_ROOT_PATH] 游戏根目录，通常为 .minecraft 文件夹的路径 [SEARCHED_VERSION_INFO] 要检查的版本的 VersionInfo （通过游戏定位器获得） [CHECK_LOCAL_FILES] 检查本地文件（如果为 false，则跳过所有检查）"
  },
  "temp/docs-main/zhCN/skin/index.html": {
    "href": "temp/docs-main/zhCN/skin/index.html",
    "title": "Minecraft 皮肤规范（1.18+） | Qomicex.Core API文档",
    "summary": "Minecraft 皮肤规范（1.18+） 以下是从 Minecraft 1.18 开始的新皮肤规范 样例 1 样例2（包含网格）"
  },
  "temp/docs-main/zhCN/skript/index.html": {
    "href": "temp/docs-main/zhCN/skript/index.html",
    "title": "Skript脚本语言入门指南: 准备工作 | Qomicex.Core API文档",
    "summary": "Skript脚本语言入门指南: 准备工作 :::tip 本文将指引您构建一个编写和调试Skript的环境. ::: [[toc]] 介绍 关于Skript Skript(简称sk)：作为一种十分接近英语这一自然语言的脚本语言，一定程度上降低了服主们发挥创意的门槛。而总还是有的：首先你要对你的英语水平很有自信——能看懂文档的范例即可；其次就是在逻辑上能够理解之——作为脚本语言，并不是能用交际英语就可以解决一切问题；也不是Siri，和它描述需求它就能为你实现（Siri也不能）。所以，要想在Sk的世界随心徜徉，首先要记住，你如何与sk交流，Skript(的解释器)才能 “听懂” (实际上所有编程语言都是这样)。 与此同时，Minecraft的各个概念（实体、区块、规则之类）还有一些计算机基础知识与名词（string字符串、integer整数之类，不过skript应该说是弱类型语言吧? 有最基本的区分: string对应text，player是玩家类型，number默认是long但是可以直接无感地变成double，很多类型都可以通过parse as语法进行转换。）也是必不可少的，但是由于其容易通过搜索引擎了解，故不在此赘述。 安装 首先需要一个基于Bukkit的Minecraft服务端，并且已经初始化。然后前往SkriptLang Github Release下载最新版Skript插件构建，将下载好的.jar文件放置在~<server_root>/plugins/下，然后重新启动服务端。在将插件放置在此位置并启动服务端后，Skript将在plugins目录下创建自己的工作目录skript。 使用服务端命令/sk info 来确认Skript是否已安装，以及版本信息和附属插件版本信息. Skript文件 Skript脚本的文件存放在它的工作目录 的子文件夹scripts 下，内容是纯文本。所有Skript脚本文件它的文件扩展名是.sk，手动在文件名的最前方添加符号-将会使其内容不被加载(与命令/sk disable <script_name>.Skript是同样的效果) 在这个文件夹下新建文本文档并修改扩展名为.sk以创建你的第一个Skript脚本文件. 搭建调试环境 :::tip 为了更好地编写和调试脚本，建议自行搭建一个独立于运营服务端的环境. ::: 在最开始，请先自行寻找一个地方创建文件夹，命名最好让自己看得懂。以后我们称呼这个文件夹为「Skript 目录」 编辑器 我们推荐使用 Visual Studio Code 来编写Skript。但是实际上，可以用任意一个文本文件编辑器来编辑Skript脚本。只是根据笔者经验，VSCode是最方便的. 前往VSCode 下载页面 选择适合自己电脑的版本下载并安装。安装完成后打开VSCode，在左侧找到一个「四个方块」组成的图标 (有点类似\uE74C )，鼠标悬浮后若提示「扩展(Extension)」，则点击它。 在它的搜索框内搜索「Skript + SkriptInsight」，选择作者为「NickAc」的项目，点击「安装(Install)」 按需重启VSCode. 找到先前创建的Skript目录，右键点击它，点击“在VSCode打开” (Windows11目前貌似要先点击「显示更多选项」)，现在你的VSCode就已经将 Skript 目录作为一个项目打开了. 点击VSC窗口右上角的「上白下黑」的按钮 (切换面板，图标类似于\uE745)，以打开下方命令行面板。这个面板中命令行的起始点即为Skript目录. 用于调试脚本的服务端 在Skript 目录中放置一个Bukkit/Spigot/Paper/… 服务端，然后在上文中打开的命令行面板中操作控制台，像正常开服一样将其初始化. 初始化后，为其安装 兼容的 Skript。 在VSC左侧的竖列图标中，确保选中了从上往下数的第一个图标 (资源管理器)，然后选择到scripts文件夹。使用「新建文件…」按钮(图标类似 \uF56E 但是右下角有个+符号) 在当前选中的目录下创建新文件. 运行服务端命令 /sk help 来查看skript帮助。 其他 可以创建一个新的脚本然后粘贴以下内容来简化执行/sk reload scripts 命令。 command /skr: trigger: if sender has permission \"admin\": broadcast \"脚本将在3秒内开始重载，可能带来卡顿\" # 可选，用于提示其他玩家；如果在专用测试环境中调试，则可删除此行. wait 3 second # 配合上一条. make sender execute command \"/sk reload scripts\" broadcast \"完成重载\" stop 这样就可以使用新注册的命令/skr来重载所有脚本了。"
  },
  "temp/docs-main/zhCN/skript/register-entry.html": {
    "href": "temp/docs-main/zhCN/skript/register-entry.html",
    "title": "注册起始点 | Qomicex.Core API文档",
    "summary": "注册起始点 :::tip 本文中起始点是包含了Event、Function、Command之类触发脚本具体逻辑的、作为一段脚本第一行和其相关配置的内容. ::: [[toc]] 定义 起始点 : 是定义一段脚本触发起点的语句，一般包含事件、方法、指令。严格来说，指令注册相当于一种特殊的事件监听，而指令也可以视为一种可以在游戏或控制台中快捷调用的方法。 类型 Event 事件 事件是最基础的、与Bukkit事件关联紧密的触发器，一般随着事件触发也会附带一些和当前触发事件相关的局部变量，但是这些事实上的局部变量使用 表达(expression) 的方式使用。比如对于事件on explode，存在表达event-location表示「单个爆炸事件发生时的位置」，诸如此类。它们传递了事件相关的具体信息。此外，如果您学过JavaScript，可以将这一系列表达视为 object.addEventListener(event，eventCallback，…) 中，eventCallback可以作为参数接受的Event对象. 要注册事件，将事件以0缩进置于单行，并在事件名称后加上冒号，换行后的内容直到下一个起始点之前都属于一段脚本. # 注册投掷物击中事件监听 on projectile hit: event-block is gravel: broadcast \"Hit on a gravel\" Function 方法/函数 方法是相对安全的一段被封装的逻辑，可以返回一个值用于在调用后赋值给变量。它可以接受多个参数并进行处理. 要注册方法，以0缩进开始按照格式编写方法声明: # 如果需要返回值 (即，如果方法计算结果需要被赋值给变量(插入字符串也算赋值变量)): function NameOfFunction(argumentName: <Type> ...):: <Optional Return Type>: # 或者，如果不需要返回值(返回为void/<null>): function NameOfFunction(argumentName: <Type>): # 换行后的一个缩进内容开始即为方法的逻辑内容 # <Type>/<Optional Return Type>为传入参数的sk内置类型，比如: text，player，number... # 方法名不可重复. 并在次行以一个单位的缩进开始编写逻辑. 换行后的内容直到下一个起始点之前都属于一段脚本方法的内容. Command 命令 命令可以视为一个可通过游戏内指令触发的方法，因为它可以接受参数。但是它不能替代方法，原因是: 不能直接返回值到调用的脚本语句中。但是可以在处理逻辑的最后将结果赋值给一个全局变量. 脚本内调用任何命令都必须使用make xxx execute command， 因此传参类型的选择更少. 要开始定义一个命令，需要以0缩进开始按格式编写命令声明: # 请通过实际测试来确认同名指令覆盖的情况. command /commandName <...args>: # 在此之后一个缩进的内容是声明命令的属性. <...properties> trigger: # 在trigger后一个缩进的内容会被视为命令的逻辑内容. # <...args>: 可选的参数定义。如果希望命令能够接受参数，使用以下方式为参数添加「槽位」: # command /commandName [<Type>]: # 实际使用中，预留的参数位可以不填。对应的逻辑需要在编写脚本逻辑时候自行判断. # 依照定义的参数顺序，可以在逻辑中使用expression “arg-x” (x为从1开始的参数序号)来取得传入的值. # 比如: command /ACommand [<text>] [<text>]: 接受两个参数，arg-1即为第一个[<text>] # <...properties>: 除了trigger这个必要属性之外的一切可选属性。下文会介绍各个可选属性. # 这些属性都需要在trigger之前. :::warning 请注意 在实际运用中，可能会出现命令传入数字然后进行计算的情况。但是Skript解释器有可能将arg-1识别为「arg减去1」. 为了避免这种情况引发的意外，请尝试改用以下expression中的其他形式表达参数 ::: 源代码中，解释器接受以下表达来指代参数: [the] last arg[ument][s] [the] arg[ument][s](-| )%number% [the] (1st|2nd|3rd|4-90th) arg[ument][s] [the] arg[ument][s] [the] %type%( |-)arg[ument][( |-)%number%] [the] arg[ument]( |-)%type%[( |-)%number%] 示例: the last argument arg-1 argument 6 13th arguments the argument the player argument arg-item type-3 摘抄自: Skript Hub Tutorial文章 by Blueyescat。 扩展 Command声明时的可选属性 可选属性的值直接用双引号包裹并写在属性名的冒号后方. executable by: 可被执行的对象，可选: player，command block，console usage: 接受text，用于向客户端返回此命令的用法. description: 接受text，提供给其他插件的命令描述。 permission: 接受text，可以是权限管理插件的权限组. permission message: 接受text，在无权限使用指令时的错误信息。比如「你无权使用!」 cooldown: 接受数字+时间单位，这是命令使用的冷却时间。比如: cooldown: 10 seconds cooldown message: 接受text，在尝试于冷却期内使用命令时的错误信息. cooldown bypass: 接受text，可以绕过冷却的权限名称，可以是权限管理插件的权限组. cooldown storage: 接受一个变量，将可以通过全局变量保存玩家的冷却阶段，并且冷却将在服务器重启/插件重载后持续生效。 aliases: 接受直接输入，定义这个指令的别名 待补充 options定义 一般可以将这类入口声明在文件最开头的地方。它接受一系列预设的变量定义。它不包含具体的逻辑. 在此定义的内容可以通过{@Name}作为变量调用."
  },
  "temp/docs-main/zhCN/skript/startup.html": {
    "href": "temp/docs-main/zhCN/skript/startup.html",
    "title": "Skript脚本语言入门指南: 正式开始 | Qomicex.Core API文档",
    "summary": "Skript脚本语言入门指南: 正式开始 :::tip 学习Skript语言需要您有较好的英语基础和敢于尝试的勇气，试一试一般不会有什么坏结果。 ::: [[toc]] 前提条件 您应该先阅读了「准备工作」章节，然后再阅读下文的进阶内容. 按要素入门 按照不同的语义元素进行循序渐进的分类介绍。 Events 事件 Event(事件) 在符合条件地发生后（譬如，on shoot就是在某一实体发射了一个“projectile（发射物，比如雪球、箭之类的）”的那一瞬间触发。），才会触发脚本中对应的内容。一段脚本必须存在于一个event与表示“这是个event”的冒号之后，大概长这样： on shoot: event之前可以有空行，但是不能有空格。Event和以后会讲到的其他注册(方法注册、指令注册等)一样，都是定义了一段脚本开始执行的条件。在event之后，需要换行并打四个空格（或者在编辑器内按下tab键），之后开始写下在这个事件发生后，sk需要执行什么命令。对于Event的后续处理，sk保留了一系列可以直接调用的常/变量，详见SkriptHub文档. 值得注意的是，sk是缩进较为敏感的，类似yaml。缩进敏感这个词比较好从字面理解，就是说，对“一行字符相对输入起始的位置”有着严格要求。稍有不对的地方，都将会引发意外的问题。 (注：和yaml一样，你可以使用#开头的一段话作为注释，提醒你别忘了这段文字是要发挥什么作用的。) Condition 条件 这是sk用来判断情况的“条件”，结尾需要输入冒号，并换行，相对于这个condition再进行4个空格的缩进，然后继续输入条件或想要执行的效果（下节会讲）。当然，如果你想一次性写完所有同等级的条件，换行就不必向后缩进了。向后缩进代表着之后的内容是换行前的条件的下级。区别在于： on chat:#在玩家发消息时候触发 if player's tool is a golden sword: # 假如发消息的玩家手持金剑 broadcast \"%sender%在讲话时握紧了手中的金剑\" if player's tool is a golden shovel: # 假如手持金铲铲 message \"%sender%在讲话时握紧了手中的金拍子\" 这样子，两条if同级，会在分别满足条件的情况下执行不一样的效果。 而不同级则是 “下一条condition作为上一条的补充，细化对最终执行效果的限制条件”： 如果李华想要 史蒂夫 在 手持 铁剑 砍地 时候 说 “大宝剑！”，可能会说“If you holding an Iron sword，say ‘大宝剑！’.”。倘若需要Sk跨次元地转告史蒂夫呢？ on click: # 在玩家的点击事件发生时候： if player's name is \"Steve\": # 只有史蒂夫能触发 if player's tool is a iron sword: # 只有手持铁剑时候触发。 make player execute command \"/say 大宝剑！\" # 好吧，终于说出口了！ # 相信你也看到了，我这里使用了“a”而不是语法中对元音前冠词的要求“an”。 # 实际上二者均可，sk不会像你的英语老师一样负责任地计较这种事情。 # 对了，使用「#」来标注注释，在这个标记之后同一行的全部文本都是注释的内容，会被解释器忽略. 如此相扣，是不是有点麻烦？通过你未来的深入了解，你会发现有些条件是可以同时制约的。那么前面两条介绍的末尾都需要加冒号并换行、第二行都必须要加一层缩进，本示例中最后一行代码表示的是什么？为什么末尾又不加冒号了？ Effect 效果/执行效果 即，在满足前面限制的条件的情况下，对目标执行什么操作、会造成什么影响。这像是指令一般，让一切锦上添花，真正对游戏中的玩家或世界做出操作。而先前介绍的event、condition，则是“根”和“枝叶”。 在同一段effect或condition中需要执行的effect，必须在缩进上保持一致。换行时不会再需要向后缩进（就是说，不用在已有缩进的基础上继续往后缩进） 且分隔不同的effect只需要换行即可。（对于高级一点的编辑器，比如virtual studio code（简称vsc），在你完成一行effect的编写后换行，是直接与上一句“齐头并进”的。） :::info 关于缩进规则 类似于Python，Skript实际上接受很多缩进种类，但是要求全篇的缩进都是一致的。比如说，你可以使用Tab，或者使用2个空格，或者4个空格; 但是你不能又用Tab又用空格. ::: effect可以直接存在于event的下级： on command \"/hello\": # 当执行指令/hello时触发（即使这个指令不存在于你的服务器中） cancel event#取消操作/取消事件（取消触发本段脚本的那个事件） # 也就是说，如果没有这句话且你的服务器没有hello这条命令，服务器会告诉玩家指令不存在。 # 此举旨在制造一种“有这个指令”的假象。 broadcast \"%sender%向诸位问好！\"#在前面取消事件之后执行的指令， # 在全服务器广播“%触发事件的玩家的ID%向诸位问好！”这句话。 # 本例子中使用的缩进是2空格 也可以叠在无数层condition之后。就像李华如何跨次元让史蒂夫喊出“大宝剑！”那里的示范一样。 好了，那么那对百分号是什么？ Placeholder&Expression 占位符和表达式 一些服主在接触插件时候或许有遇到一个和某网红一点关系都没有的插件：PlaceholderAPI（简称papi）。不过这里的Placeholder在安装附属「skript-placeholders」之前和papi并不互通，但是道理是一样的：占位符。 在一段文本中插入占位符，而一旦读取到占位符所指示的变量后，占位符将被那个变量的内容替代。 比如，我们的李华同学的游戏ID叫Li_Hua，在papi中要灵活表示玩家的名字时，就应该把占位符写作%player_name%。而在sk，需要表达为%player%(玩家)或%player's name%(玩家名，稍后的文档我们将探索各种相似的Expression的不同之处)。 你应该看出来了，前面限制“只有史蒂夫能触发”时候也出现了“player's name”，那么这个限制条件除了基于“if”表示“如果”的限制条件，还和这个占位符有什么关系？ 很有关系。它们都属于expression（表达），抽象但又不完全抽象。任何表达都可以写到两个百分号之间，组成一个占位符，灵活地表示一段文字。 由此，我们可以写一个比较不好用但至少能用的玩家头衔脚本了！ on join:#每次玩家加入到服务器世界时候触发 player's name is \"Steve\":#这是Steve专用之雅号 set player's displayname to \"<gold><bold>世界之王 <aqua>史蒂夫！\"#这是最简单的实现方式。 # 一段脚本结束，另一端脚本开始。这发生在同一个sk文件中。 on chat:#在聊天时候 cancel event#把嘴捂住（不让原生的消息显示出来） broadcast \"%sender's displayname%<r>说 %message% <gray>并仰天长笑。\" # 把所有玩家发送的消息广播出来，达成目标效果。 那么，<gold>，<r>这些都是什么？ Text（文本）的美化 Minecraft里会出现各种各样颜色的字。无论是手持颜料右键点击有文本的告示牌，或是在Essentials/EssentialsX（插件，简称ess）和/或papi的帮助下，使用&1&c&l之类的代码表示，都会有“被染色”的文字出现。乱码效果、斜体、粗体、鼠标悬浮提示、可以点击执行命令的“文本按钮”等等等等，都可以通过这种<>包围的一段标签代码来达到效果。在这段代码之后、直到新的代码出现之前，效果都会持续。 表示颜色、表示字体效果、表示功能的代码，见官方文档 https://docs.skriptlang.org/text.html 以下是对官方文档的表格摘抄和翻译 (颜色代码查询请访问官方文档): 代码(原版) 名称 别名 §k magic test obfuscated §l bold b §m strikethrough strike，s §n underlined underline，u §o italic italics，i §r reset r （reset代表重置，即将其之后的显示效果还原为默认状态。） 名称 别名 描述 link open url，url Opens a link when player clicks on text run command command，cmd Makes player execute a chat command when they click on text suggest command sgt Adds a command to chat prompt of player when clicked tooltip show text，ttp Shows a tooltip when player hovers over text with their mouse font f Change the font of the text (1.16+) insertion insert，ins Will append a text at player's current cursor in chat input only while holding SHIFT。 (对于这些交互功能，需要你这样设置标签代码：<名称:执行的效果（可以是在cmd:后的一段命令）> 详见示例) 由此，你可以制作一些简单的操作交互了！ command /spawnpoint: # 回城！（前提是有这样一个主城可以返回） trigger: if {onev.%player%} is true: # 条件、效果都可以按你希望的顺序出现。把握好执行顺序即可。 message \"你有操作未完成。\" else: # 只有带if的condition可以有else在同级出现。 set {onev.%player%} to true # 变量设置为布尔值true，下节会讲到。 message \"<aqua>是<magneta>否<yellow>确<dark red>认<lime>？\" # 花花绿绿，实际上影响观感。 message \"<cmd:res tp main><lime>【是】<cmd:canceltip><pink>【否】\" # 点击“【是】”触发里面的命令只在你有residence领地插件且设置了名为main的领地时有效。可以替换为任意命令。 # 在玩家打开聊天并点击“【是】”之后，指令会执行。而“【否】”对应什么命令？ command /canceltip: # 任何取消提示都可以使用这一条。哪怕不在同一个sk文件内。 if {onev.%player%} is true: message \"已取消操作。\" to the sender # 这个to the sender指向message的发送对象。在触发event的是玩家时可以不写。 set {onev.%player%} to false#尘埃落定，既然交互结束了，那就设置为完全相反的false吧！ on command \"/res tp main\": set {onev.%player%} to false#有始有终。 broadcast \"%sender's displayname%<r>回城了！\"# 告知父老乡亲。而<r>旨在不让有displayname还染了色的玩家不会让后面的文字变色。 # 在本例中，使用了注册指令的方法来实现指令接收。以后我们会探讨各种事件和其他调用脚本的方法. 值得一提的是，不要把服务器所有不相干的功能都写在同一个sk文件里。那样不方便管理，也会影响性能。 接下来，把一些东西存下来吧！ Variables 变量 变量，存储和交换信息的必要「介质」。 局部变量 ，暂时的变量，即类似{_actions}的由大括号包括的一段字符，开头必须由_符号标记。在当前这一段脚本执行结束后，将会消失。并且在不同段落的脚本之间不可互通，因此也不会形成冲突. 临时变量 (暂定名称)，需要只在服务器开启期间于内存中存在的变量，使用-符号开头. 全局变量 ，长期的变量，即类似{actions}的由大括号包括的一段字符，且开头没有上述符号。永远会在Skript插件于服务端取消注册的时候长期存在于服务器的本地文件里。( 默认在关闭服务器时会保存到Skript的插件文件夹的variables.csv中，或者根据数据库设置存储在数据库里。) 并且，全局变量可以跨文件使用。 变量可以包含几个占位符，用于保存不同玩家的不同状态。在Skript v2.6.1之后，Skript会建议你不要以占位符作为变量的开头，而是像{adv.%player%}这样，便于区分变量来源或作用、避免同名的变量的冲突。变量可以存储很多东西：纯数字、字符串、玩家（保存玩家名），在sk不能判断你要存的是什么类型的数据时候，只需要在用\"set ..。to ...\"之后加“parsed as ”和你要存的类型即可完成转换。 变量存在列表存储方式，其格式为: {[-_]VariableName::Key}， [-_] 代表着列表也可标识为局部变量或临时变量。 列表变量可以扩展为两个Key储存的形式，比如: {VariableName::Key1::Key2}，并且Key可以为数字。使用{VariableName::*}来代指整个列表。整个列表可以被loop语法遍历. :::warning 官方建议 在Skript 2.7之后的版本中，官方建议为一个.sk文件中的所有全局变量添加固定的前缀以避免跨脚本文件的全局变量出现变量污染，即倘若脚本A包含一个{variable}被赋值为1，另外一个脚本B包含一个{variable}被赋值为\"XPX\"，将可能导致难以预测的意外。因此将脚本A中的那个全局变量命名为{A.variable}，脚本B中的那个全局变量命名为{B.variable}，将能避免这个问题. 但是我们建议，无论使用哪个版本的Skript，都要遵守这个规则。并且，若非是不得不使用全局变量的场合，不要使用全局变量。 ::: 需要注意的是，expression和字符串(text，string) 可以视为特殊的变量。前者可能包含可读写的值，会对游戏产生影响; 后者可以通过模版表达式(成对的百分号%) 进行插入值 (插入expression或变量). 同时还有一种特殊的expression，它是与玩家紧紧相伴，像一个隐形标签的存储方式：元数据（metadata）—— 与某些路灯挂件喜欢炒作的某宇宙基本没关系。利用元数据，你可以存储各种玩家信息，使用方法与变量很相似。除非服务器重启，否则不会被清空。 而元数据可以帮助我们制作一些需要指向目标的功能 (比如说暂时存储一个状态的信息)。这个方法比较简单，也比较笨拙： （假设你有安装ess） on command \"/tpatoplayer\":#这种复杂的命令最适合放在服务器菜单里。 if sender is a player:#sender可能是command block（命令方块）或console（控制台，服务器后台）。你不能指望把命令方块传送走，或者把服务端丢到世界里去。 cancel event set metadata value \"going\" of sender to true message \"在聊天框发送你要传送到的玩家的ID，发送~/取消操作。\" on chat: if metadata value \"going\" of sender is true: set metadata value \"going\" of sender to false # 有始有终 if message is \"~/\": cancel event make sender execute command \"/canceltip\" # 前面提到的万物皆可调用的取消提示信息 else:#与取消操作的可能的条件同级 make sender execute command \"/tpa %message%\" # 拼接为ess的传送指令并执行。对于较高版本的Minecraft，玩家可以在聊天框空着的时候按tab补全来选择目标玩家。然后作为消息发送即可。 Types 类型 skript针对“伤害来源（damage cause）”、“生物群系（biome）”等需要分类的不同事物有着规范化语言的要求。详见官方文档：https://docs.skriptlang.org/classes.html 试一试吧！ 在保存好你写的脚本后，在后台执行命令 sk reload all（重载所有脚本和配置）sk reload scripts（仅重载所有脚本，别把script拼成skript了）或sk reload <某个脚本文件>（重载某一个脚本）！ 不出错的情况下，就可以去看看服务器里面展示的效果了！祝你成功！ 跋 & 一些好习惯 这是我（法棍 of 日冕工作室）第一次尝试写教程。写得仓促，但绝对是我一个寒假以来所学的基础的浓缩。因此，会有不少纰漏，希望高人指出。以及我认为，相对简短的文字永远不能表达最准确的事实，所以读完这篇文章，或许需要你带着去实践、去翻阅文档，打好基础，然后迈出下一步：接触各种附属，包括且不限于SkBee、McQQBot、Skript-reflect等。另外，对于新手，我推荐尝试使用官方文档 https://docs.skriptlang.org ， 而 https://skripthub.net/ 包含除了本体之外的诸多附属的使用文档，以及更多示例。（嘛 使用文档！使用说明书啦！）按照文档示例来写，也不要忘记作合理的发散的尝试，这将有助于进步！（2022年2月17日 skript.cn的中文文档尚未就绪，将在不久的将来完成译制！ ） ⬆️ 这是本文最开始于2022年写就时候的跋。下文是2024年的跋. 时过境迁，如今我访问skript.cn指向的论坛却发现NXDOMAIN了，貌似很多skript资源都转移到了MineBBS? 但是无论如何，老腊肉想要CSKB成为汇聚Corona Studio相关所有知识的知识库，所以我把我所累不多的大脑中的知识翻了个遍，把这篇文章从我暂时消失的博客的数据库中找出来了，并且准备在CSKB这个平台上继续更新内容. 而一些好习惯呢，就是： 首先，学会听sk的诉求。你的代码、或是来自你一些新奇的尝试，可能并不能被skript理解。这时候你需要先过skript这一关。让skript载入这个脚本，看它如何报错？报错的原因是什么？理解报错原因，回去改正你很确信的错误，然后再试一次。 然后你再试了一次，可能还是不行。或许你这会应该去文档查询用法了：如果有这样的用法，那就找你的拼写错误：可能少了什么符号？可能什么地方打错了？如果没有这种用法，那么请先思考别的解决方案，然后在文档试着搜索别的解决方案的关键词。应该有所收获。甚至最终你可能发现，只是你的skript该更新了而已。skript每次更新迭代，都会带来新的功能，可能一切报错只是因为你使用的这个版本“还听不懂你要说什么”。 最终你或许成功让skript可以理解了。但是理解的对不对，有待你进入服务器的世界一探究竟。甚至可能需要你同时登录几个不同权限组的账户来测试！而且实现的效果也可能不是一蹴而就的——需要你不断地耐心调试。代码执行到哪里出现了问题？在你认为可能的地方插几句broadcast “<一个数字，能区分出问题的地方即可>”，重载，再尝试，逐渐找到问题的根源，解决它！ 倘若实在遇到瓶颈，勿忘鼻子下面有大路，不羞于求问！但是也请谨记，在保证礼貌提问虚心请教同时，“没有日志（错误报告、log之类）的问题解决无异于闭眼开车（来自apache官方文档）”，明确表述需求与问题带上错误报告，也很有必要。 还有，对于一些需要重复使用多次且不会出现关于玩家的占位符的代码，可以由指令或者方法触发，在面向客户端操作时，用一段命令要求服务端执行触发指令即可。譬如我写的日历： https://github.com/fr1g/CalendarRealCount 。 最后，愿你能早日自由地实现你所想的新奇玩法! 或者在如此面向过程的友好脚本语言的帮助下，早日参悟属于你的编程方法! 2022年2月17日 06点08分 最早发布于https://bbs.smgoro.top/threads/skript.32/ | 2024年3月22日 转移到CSKB"
  },
  "temp/docs-main/zhTW/CMFS/index.html": {
    "href": "temp/docs-main/zhTW/CMFS/index.html",
    "title": "歡迎來到 CMFS 指南 | Qomicex.Core API文档",
    "summary": "歡迎來到 CMFS 指南 首先, 感謝你選擇加入 CraftMineFun Server Minecraft群組伺服器（以下簡稱CMFS）. 本系列指南將會幫助你理解關於CMFS的一切, 併發揮你的主觀能動性, 利用我們提供的特色玩法來建設、遊覽. 和您的朋友們一起, 抑或是在這裡認識新朋友, 合作遊玩, 或者競賽角逐. 請放心, 由我們的團隊來維護您的體驗. 如果您遇到了遊玩體驗上的問題, 請立即聯絡我們！ [[toc]] :::warning 所有伺服器處於暫停運營的狀態 請等待另行通知（2022年11月27日） 或加入群 419902868 等待第一時間的通知. ::: 組成部分 CMFS-Pure 純淨生存伺服器！您可以透過特定版本的Minecraft來加入遊戲, 體驗由我們精心構思的獨特玩法. 這個伺服器正在維護 CMFS-SquareCraft 枘方世界伺服器 我們和枘方世界合作的Mod伺服器. 在我們高效能的穩定的伺服器中享受Minecraft“活的靈魂”：高度自由, 高度擴充套件. 這個伺服器處於設想狀態 CMFS-Eksamen 您可以自由地加入這個伺服器以申請進行日冕工作室的建築組（日冕重工）的稽核. 這裡本質上是個原版創造模式建築服, 在我們嚴格的環境中體現您的Minecraft建築實力. 當我們有招新需求時, 會根據已提交稽核的作品質量發出進一步稽核的邀請：通過後, 您將加入我們的建築組, 或許您不僅能在這裡發展自身能力, 還能在這裡發現同好？ 這個伺服器正在構件中 CMFS-Juego 這裡有我們準備的各種主流的小遊戲和競技場, 以及由我們構思的獨特小遊戲. 其中區分多個不同的遊戲版本, 提供了不同時代的體驗. 這個伺服器暫無負責人 CMFS-Login “四通八達. ” 這個伺服器是整個CMFS的入口, 是負責分散諸位玩家到其想要到達的伺服器的中轉伺服器. 您需要在這裡透過CMFS賬號或繫結CMFS賬號的日冕服務賬號來登入群組服. 這個伺服器需要和Pure一併重構 CMFS-Pure 指南"
  },
  "temp/docs-main/zhTW/dashboard/index.html": {
    "href": "temp/docs-main/zhTW/dashboard/index.html",
    "title": "在這裡你可以看到有關儀表盤元件的一些幫助知識 | Qomicex.Core API文档",
    "summary": "在這裡你可以看到有關儀表盤元件的一些幫助知識"
  },
  "temp/docs-main/zhTW/dashboard/search.html": {
    "href": "temp/docs-main/zhTW/dashboard/search.html",
    "title": "如何使用儀表盤搜尋 | Qomicex.Core API文档",
    "summary": "如何使用儀表盤搜尋 您可以在聚合搜尋輸入框中輸入任何您想要查詢的內容. 在您輸入內容後, 下方會彈出智慧提示來幫助您快速的導航到搜尋結果頁面 使用指定的搜尋引擎來查詢內容 在預設情況下, LauncherX 會使用 必應（Bing）來查詢您的搜尋內容. 如果您想指定聚合搜尋使用的搜尋引擎, 您可以在您的搜尋內容前加入下面的字首： 搜尋引擎 值 百度 bd: 谷歌 g: 必應 b: 樣例 使用百度搜索 “1.16.5材質包”：bd:1.16.5材質包 使用谷歌搜尋 “1.16.5材質包”：g:1.16.5材質包 使用必應搜尋 “1.16.5材質包”：b:1.16.5材質包"
  },
  "temp/docs-main/zhTW/guide/index.html": {
    "href": "temp/docs-main/zhTW/guide/index.html",
    "title": "歡迎來到日冕知識庫（CSKB） | Qomicex.Core API文档",
    "summary": "歡迎來到日冕知識庫（CSKB） 在這裡您可以查閱到日冕工作室所屬專案的部分技術文件、疑難解答, 以及 Minecraft 相關的各種技術規範和樣例"
  },
  "temp/docs-main/zhTW/index.html": {
    "href": "temp/docs-main/zhTW/index.html",
    "title": "| Qomicex.Core API文档",
    "summary": ""
  },
  "temp/docs-main/zhTW/projbobcat/beforeWeStart.html": {
    "href": "temp/docs-main/zhTW/projbobcat/beforeWeStart.html",
    "title": "在我們開始之前 | Qomicex.Core API文档",
    "summary": "在我們開始之前 在我們正式開始使用 ProjBobcat, 您需要對您的專案屬性做一下必要的檢查和調整以滿足 ProjBobcat 的執行需要. [[toc]] 執行時要求 您需要保證您專案的 dotNET 框架至少執行在 .NET 6.0 及更高的版本當中以滿足. 目前受支援的 .NET 版本： .NET 6.0 .NET 7.0 （推薦） ::: warning 我們在先前的版本更新中已經移除了對 .NET 5.0 執行時的支援. ::: 專案屬性 由於 Windows 系統機制, 您需要在專案屬性中關閉 首選 32 位 的生成選項. 否則您在使用 ProjBobcat 部分元件時會出現預料之外的結果. 您需要在 Visual Studio 中切換到專案的屬性頁面, 並找到 首選 32 位 的勾選框, 並將其取消勾選. 32 位系統支援 ::: warning ProjBobcat 從專案立項開始就決定放棄對 32 位系統的全部支援, 因為它真的很老, 很老了（ :::"
  },
  "temp/docs-main/zhTW/projbobcat/createNewAzureApp.html": {
    "href": "temp/docs-main/zhTW/projbobcat/createNewAzureApp.html",
    "title": "配置 Azure 應用 | Qomicex.Core API文档",
    "summary": "配置 Azure 應用 [[toc]] 開始配置 在開始之前, 您首先需要一個微軟賬號. 註冊 Azure Active Directory 應用無需任何費用. 使用您的微軟賬戶登入 Azure 門戶 在完成登入後, 您看到的頁面應該是這樣的： 點選 Azure 服務 下的 Azure Active Directory 您將會看到類似於下面的頁面 接著點選左側功能欄的 應用註冊： 點選頂部工具欄的 新註冊, 填寫應用的名稱. 並且在 受支援的賬戶型別 中選擇 僅 Microsoft 個人賬戶. 由於我們不使用基於 URI 回撥的認證方式. 因此, 您不需要填寫表單下方的 重定向 URI. ::: warning 請仔細核對表單中的資訊, 否則可能會導致後續的步驟出現意料之外的問題. ::: 點選建立後, 等待 Azure AD 完成應用的建立. 在建立完成後, 網頁會將您重定向至該應用的詳細頁面： 接著點選左側欄的 身份驗證： 接著在右側找到 高階設定 板塊, 確保板塊中的 高階 SDK 支援 和 允許公共客戶端流 為開啟狀態. 如果他們沒有開啟, 請手動將他們開啟. 接著點選下方的儲存按鈕, 等待儲存完成. 檢視 Client ID 恭喜！您已經完成了 Azure 的應用註冊, 接下來您只需要前往 概述 頁面檢視應用的 Client ID. 點選左側欄的 概述 按鈕, 即可檢視應用的基礎資訊： 在右側您會看到應用的詳細資訊, 在 概要 中找到 應用程式(客戶端) ID, 該 ID 將是您需要在 微軟驗證器配置 階段需要使用到的 Client ID."
  },
  "temp/docs-main/zhTW/projbobcat/index.html": {
    "href": "temp/docs-main/zhTW/projbobcat/index.html",
    "title": "ProjBobcat 開發文件 | Qomicex.Core API文档",
    "summary": "ProjBobcat 開發文件 ProjBobcat 是一個由日冕開發組開發的高度自定義、高效能、功能完善的 Minecraft 啟動器核心. 在這裡您可以查閱到各大元件的使用教程. 專案地址 GitHub - ProjBobcat"
  },
  "temp/docs-main/zhTW/projbobcat/installationAndConfig.html": {
    "href": "temp/docs-main/zhTW/projbobcat/installationAndConfig.html",
    "title": "安裝並配置 ProjBobcat | Qomicex.Core API文档",
    "summary": "安裝並配置 ProjBobcat [[toc]] 從發行包安裝 Nuget 目前, 您可以方便的從 Nuget 上搜索並下載 ProjBobcat 的軟體包, 您可以在 Visual Studio 的包管理器中搜索 ProjBobcat 並將其新增到您的專案中. 或者, 您也可以手動在 “程式包管理器控制檯” 中執行下面的命令： NuGet\\Install-Package ProjBobcat -Version 1.16.0 .NET CLI 要透過 .NET CLI 來安裝 ProjBobcat, 您只需要將終端切換到包含 .csproj 檔案的專案目錄, 並在終端中執行： dotnet add package ProjBobcat --version 1.16.0 PackageReference PackageReference 是微軟為現代 .NET 專案推出的一種新的軟體包管理規範, 詳細資訊可以在 MSDN 中檢視 您只需在專案的 [專案名].csproj 檔案中新增： <PackageReference Include=\"ProjBobcat\" Version=\"1.16.0\" /> ::: tip 其中, 1.16.0 為 ProjBobcat 的版本號, 您可以將其替換為其他的版本號, 所有的發行版本都可以在 ProjBobcat - Nuget 中檢視. ::: 從原始碼引用 另外一種使用 ProjBobcat 的方法是直接新增程式碼倉庫到您的專案引用. ::: info 在執行下面的命令前, 您可能需要先安裝 Git CLI ::: 克隆 ProjBobcat 倉庫 使用命令列切換到專案解決方案的根目錄, 並在命令列中執行下面的程式碼來完成倉庫的克隆： git clone https://github.com/Corona-Studio/ProjBobcat.git 使用 Git Submodule（子模組）的方式拉取 ProjBobcat ::: tip Git Submodule 是一個非常實用的功能, 在這裡我們只展示了其最基本的用例. 在 Git 官方文件 中您可以檢視到更多的使用案例. ::: 使用命令列切換到專案解決方案的根目錄, 並在命令列中執行下面的程式碼來完成倉庫的克隆： git submodule add https://github.com/Corona-Studio/ProjBobcat.git 新增對 ProjBobcat 的引用 接下來, 在 Visual Studio 的 解決方案資源管理器 檢視中, 右鍵點選位於樹狀圖頂層的解決方案名稱. 並選擇 “新增”-“現有專案”, 並在檔案瀏覽視窗中找到剛剛克隆的 ProjBobcat 專案資料夾中的 ProjBobcat.csproj. 接著, 在 解決方案資源管理器 找到您需要引用 ProjBobcat 的專案, 並右鍵單擊, 選擇 “新增”-“專案引用”. 最後在彈出視窗中勾選 ProjBobcat 即可完成對其的引用. 使用前配置 修改預設連線數 在使用 ProjBobcat 之前, 您需要在程式的入口點（通常是 App.xaml.cs 或 Program.cs） 中新增一些程式碼來初始化 ProjBobcat 的相關服務. 由於 .NET 執行時預設的最大連線數限制, 在使用 ProjBobcat 下載模組時可能會遭遇效能瓶頸. 因此, 您需要在入口處新增下面的程式碼來修改預設的最大連線數： using System.Net; ServicePointManager.DefaultConnectionLimit = 512; 註冊並初始化基礎服務 接下來, 您需要在入口點新增這些程式碼來完成 ProjBobcat 服務的初始化： 初始化服務容器 ServiceHelper.Init(); 初始化 CurseForge API 服務（可選） 該服務為可選專案, 如果您沒有使用任何 CurseForge 相關服務, 您可以忽略這個步驟. ::: tip 在註冊 CurseForge 服務前, 您需要準備 CurseForge 官方下發的 API KEY. 如果您還沒有, 請前往 申請頁面 - CurseForge 來獲得您的 API KEY. ::: ::: warning API KEY 為敏感的個人憑據, 請妥善儲存 API KEY 並不要將其洩露給其他人. ::: CurseForgeAPIHelper.SetApiKey(\"[YOUR API KEY]\"); 將 [YOUR API KEY] 替換為您從 CurseForge 官方獲取的 API KEY. 初始化下載服務 在初始化下載服務時您可以選擇自定義請求時所使用的 User Agent（預設為 \"ProjBobcat\"）. HttpClientHelper.Ua = \"[YOUR UA]\"; // 可選 HttpClientHelper.Init(); 配置微軟登入驗證器 關於 Azure Active Directory 應用具體的註冊方法請移步： 如何註冊 Azure 應用 ::: tip 在配置微軟驗證器前, 您需要在 Azure 註冊您的應用, 並對其進行正確的配置. 在您完成配置之後, 您會獲得一串 Client ID. 相關資料： Azure 官網 Device code flow ::: ::: warning CLIENT ID 為敏感的個人憑據, 請妥善儲存 CLIENT ID 並不要將其洩露給其他人. ::: MicrosoftAuthenticator.Configure(new MicrosoftAuthenticatorAPISettings { ClientId = \"[YOUR CLIENT ID]\", TenentId = \"consumers\", Scopes = new[] { \"XboxLive.signin\", \"offline_access\", \"openid\", \"profile\", \"email\" } }); 在取得 Client ID 後, 將 [YOUR CLIENT ID] 替換為您的 Client ID."
  },
  "temp/docs-main/zhTW/projbobcat/installers/curseforge.html": {
    "href": "temp/docs-main/zhTW/projbobcat/installers/curseforge.html",
    "title": "CurseForge 整合包安裝器 | Qomicex.Core API文档",
    "summary": "CurseForge 整合包安裝器 [[toc]] ::: tip 請注意, ProjBobcat 僅實現了 CurseForge 整合包的自動化安裝流程, 您仍然需要自己實現 CurseForge 整合包的搜尋、下載、儲存流程. ::: 實用資源 CurseForge 官方網站 CurseForge API 初始化安裝器 初始化 CurseForge 安裝器的方式非常簡單： var curseForgeInstaller = new CurseForgeInstaller { GameId = \"[CUSTOM_INSTALL_GAME_ID]\", ModPackPath = \"[PATH_TO_YOUR_MODPACK]\", RootPath = \"[GAME_ROOT_PATH]\" }; 在上述程式碼塊中, 請將這些引數按照您的實際情況替換： 專案 說明 [GAME_ROOT_PATH] 遊戲根目錄, 通常為 .minecraft 資料夾的路徑 [CUSTOM_INSTALL_GAME_ID] 可選項, 自定義即將要安裝的遊戲的名稱 [PATH_TO_YOUR_MODPACK] CurseForge 整合包所在的路徑 開始安裝 在您完成安裝器的初始化後, 您只需要呼叫 CurseForge 安裝器的安裝方法來完成安裝. 在非同步上下文中, 使用 InstallTaskAsync 來完成安裝： await curseForgeInstaller.InstallTaskAsync(); 在同步上下文中, 使用 Install 來完成安裝： curseForgeInstaller.Install(); 報告安裝進度 在某些情況下, CurseForge 安裝器可能會需要數分鐘的時間來完成安裝. 因此, 您可能需要實時向用戶彙報安裝器目前的進度. 為此, CurseForge 安裝器提供了 StageChangedEventDelegate 事件來幫助您實現任務彙報. 您只需要簡單地在 開始安裝之前 註冊下面的事件： curseForgeInstaller.StageChangedEventDelegate += (_, args) => { ReportProgress(args.Progress, args.CurrentStage); }; 其中, args.Progress 指示了安裝器當前的百分比進度. args.CurrentStage 則是安裝器當前進度的文字描述."
  },
  "temp/docs-main/zhTW/projbobcat/installers/fabric.html": {
    "href": "temp/docs-main/zhTW/projbobcat/installers/fabric.html",
    "title": "Fabric 安裝器 | Qomicex.Core API文档",
    "summary": "Fabric 安裝器 [[toc]] ::: tip 請注意, ProjBobcat 僅實現了 Fabric 自動化安裝流程, 您仍然需要自己實現 Fabric 安裝包的搜尋、下載、儲存流程. ::: 實用資源 Fabric 官方網站 Fabric Meta API 獲取 Fabric Loader Artifact 由於 ProjBobcat 的 Fabric 安裝器要求您在初始化安裝器時提供來自 Fabric 官方的 Loader Artifact 資訊. 因此, 我們將在這裡簡要描述如何根據指定的 MineCraft 版本來獲取該資訊. ::: info 在該示例中, 我們將使用 MineCraft 1.19.2 來向您展示如何獲取. ::: 向 Fabric Meta API 傳送請求 首先, 您需要向 https://meta.fabricmc.net/v2/versions/loader/[MC_VERSION] 傳送一個 HTTP GET 請求. 將 [MC_VERSION] 替換為您想要安裝的 MineCraft 版本. 在這裡, 我們將使用 1.19.2. 您將看到類似下面的返回內容： [ { \"loader\": { \"separator\": \".\", \"build\": 11, \"maven\": \"net.fabricmc:fabric-loader:0.14.11\", \"version\": \"0.14.11\", \"stable\": true }, \"intermediary\": { \"maven\": \"net.fabricmc:intermediary:1.19.2\", \"version\": \"1.19.2\", \"stable\": true }, \"launcherMeta\": { \"version\": 1, \"libraries\": {...}, \"mainClass\": {...} } }, {...}, {...} ] Fabric Meta API 將返回一個 JSON 陣列, 陣列中的每一個元素即是我們需要的 Loader Artifact. 將 JSON 返回轉換為 ProjBobcat 型別 如果您在您的專案中使用 JSON.NET（Newtonsoft.JSON）. 您可以使用類似下面的程式碼來將您獲取到的伺服器響應轉換為對應的 ProjBobcat 型別： // 從 Fabric Meta API 請求資料（示例, 非實際程式碼） ... var responseJson = await res.Content.ReadAsStringAsync(); // 將 JSON 響應轉換為 ProjBobcat 型別 // [!code focus] var artifacts = JsonConvert.DeserializeObject<List<FabricLoaderArtifactModel>>(responseJson); // [!code focus] // 獲取使用者想要安裝的版本（示例, 非實際程式碼） var userSelect = vm.SelectedArtifactIndex; // 獲取單個 Loader Artifact // [!code focus] var selectedArtifact = artifacts[userSelect]; // [!code focus] 此處, selectedArtifact 即是 Fabric 安裝器所需要的 FabricLoaderArtifactModel. 初始化安裝器 初始化 Fabric 安裝器的方式非常簡單. 您需要使用到在先前步驟中取得的 selectedArtifact 來初始化安裝器： var fabricInstaller = new FabricInstaller { LoaderArtifact = selectedArtifact, VersionLocator = [VERSION_LOCATOR_INST], RootPath = \"[GAME_ROOT_PATH]\", CustomId = \"[CUSTOM_INSTALL_GAME_ID]\", InheritsFrom = \"[MC_VERSION_OR_GAME_ID]\" }; 在上述程式碼塊中, 請將這些引數按照您的實際情況替換： 專案 說明 [GAME_ROOT_PATH] 遊戲根目錄, 通常為 .minecraft 資料夾的路徑 [CUSTOM_INSTALL_GAME_ID] 可選項, 自定義即將要安裝的遊戲的名稱 [MC_VERSION_OR_GAME_ID] Forge 繼承的 MineCraft 原版遊戲版本, 通常為遊戲版本. 例如：1.19.2 [VERSION_LOCATOR_INST] 遊戲版本定位器例項, 即初始化遊戲核心時的 VersionLocator 屬性 開始安裝 在您完成安裝器的初始化後, 您只需要呼叫 Fabric 安裝器的安裝方法來完成安裝. 在非同步上下文中, 使用 InstallTaskAsync 來完成安裝： await fabricInstaller.InstallTaskAsync(); 在同步上下文中, 使用 Install 來完成安裝： fabricInstaller.Install(); 報告安裝進度 在某些情況下, Fabric 安裝器可能會需要數分鐘的時間來完成安裝. 因此, 您可能需要實時向用戶彙報安裝器目前的進度. 為此, Fabric 安裝器提供了 StageChangedEventDelegate 事件來幫助您實現任務彙報. 您只需要簡單地在 開始安裝之前 註冊下面的事件： fabricInstaller.StageChangedEventDelegate += (_, args) => { ReportProgress(args.Progress, args.CurrentStage); }; 其中, args.Progress 指示了安裝器當前的百分比進度. args.CurrentStage 則是安裝器當前進度的文字描述."
  },
  "temp/docs-main/zhTW/projbobcat/installers/forge.html": {
    "href": "temp/docs-main/zhTW/projbobcat/installers/forge.html",
    "title": "Forge 安裝器 | Qomicex.Core API文档",
    "summary": "Forge 安裝器 在 ProjBobcat 中, 我們支援了幾乎所有主流 MineCraft 版本的 Forge 自動化安裝. [[toc]] ::: tip 請注意, ProjBobcat 僅實現了 Forge 自動化安裝流程, 您仍然需要自己實現 Forge 安裝包的搜尋、下載、儲存流程. ::: 判斷應該使用哪一種 Forge 安裝器 由於 Forge 團隊在後續的版本中修改了 Forge 的打包規範以及安裝流程. 因此, 您需要手動判斷應該使用哪一種安裝器. 在 ProjBobcat 中, 我們已經為您實現了相關的判斷邏輯. 您只需要簡單地呼叫下面的方法： var mcVersion = \"[MC_VERSION]\"; var forgeJarPath = \"[PATH_TO_YOUR_FORGE_INSTALLER]\"; var forgeVersion = ForgeInstallerFactory.GetForgeArtifactVersion(mcVersion, \"[FORGE_VERSION]\"); var isLegacy = ForgeInstallerFactory.IsLegacyForgeInstaller(forgeJarPath, forgeVersion); // [!code focus] 在上述程式碼塊中, 請將這些引數按照您的實際情況替換： 專案 說明 [MC_VERSION] 將 Forge 安裝到的 MineCraft 版本, 例如：1.19.2 [PATH_TO_YOUR_FORGE_INSTALLER] Forge 安裝器 .jar 檔案所在的路徑 [FORGE_VERSION] Forge 的具體版本, 通常為 XX.X.X, 例如：43.2.0 在您完成替換併成功執行上述的程式碼片段之後, isLegacy 會指示當前 Forge 安裝器應當使用哪一種 Forge 安裝器. 初始化舊版安裝器 如果在上面的流程中, isLegacy 的值為 true, 這意味著您需要使用舊版安裝器來完成 Forge 的安裝. 要初始化舊版安裝器, 只需例項化 LegacyForgeInstaller 並提供相應的引數： IForgeInstaller forgeInstaller = new LegacyForgeInstaller { ForgeExecutablePath = \"[PATH_TO_YOUR_FORGE_INSTALLER]\", RootPath = \"[GAME_ROOT_PATH]\", CustomId = \"[CUSTOM_INSTALL_GAME_ID]\", ForgeVersion = \"[FORGE_VERSION]\", InheritsFrom = \"[MC_VERSION_OR_GAME_ID]\" }; 在上述程式碼塊中, 請將這些引數按照您的實際情況替換： 專案 說明 [GAME_ROOT_PATH] 遊戲根目錄, 通常為 .minecraft 資料夾的路徑 [CUSTOM_INSTALL_GAME_ID] 可選項, 自定義即將要安裝的遊戲的名稱 [MC_VERSION_OR_GAME_ID] Forge 繼承的 MineCraft 原版遊戲版本, 通常為遊戲版本. 例如：1.19.2 初始化新版安裝器 IForgeInstaller forgeInstaller = new HighVersionForgeInstaller { ForgeExecutablePath = \"[PATH_TO_YOUR_FORGE_INSTALLER]\", JavaExecutablePath = \"[PATH_TO_YOUR_JAVA_RUNTIME]\", RootPath = \"[GAME_ROOT_PATH]\", VersionLocator = [VERSION_LOCATOR_INST], DownloadUrlRoot = “[LIBRARIES_URL_ROOT]”, CustomId = \"[CUSTOM_INSTALL_GAME_ID]\", MineCraftVersion = \"[MC_VERSION]\", MineCraftVersionId = \"[ACTUAL_MC_GAME_ID]\", InheritsFrom = \"[MC_VERSION_OR_GAME_ID]\" }; 在上述程式碼塊中, 請將這些引數按照您的實際情況替換： 專案 說明 [PATH_TO_YOUR_JAVA_RUNTIME] Java （javaw.exe） 執行時所在的路徑 [LIBRARIES_URL_ROOT] 下載源的根 URL, 例如：\"https://bmclapi2.bangbang93.com/\" [VERSION_LOCATOR_INST] 遊戲版本定位器例項, 即初始化遊戲核心時的 VersionLocator 屬性 [ACTUAL_MC_GAME_ID] 實際的 MineCraft 遊戲名稱, 即原版遊戲在 version 資料夾下的名稱. 一般情況下, 這個值和 [MC_VERSION] 一致. 根據 isLegacy 值進行統一初始化 由於 LegacyForgeInstaller 和 HighVersionForgeInstaller 同時實現了 IForgeInstaller 介面. 因此, 您可以很方便的使用一個三元運算子來選擇性的初始化對應的安裝器： var isLegacy = ForgeInstallerFactory.IsLegacyForgeInstaller(forgeJarPath, forgeVersion); IForgeInstaller forgeInstaller = isLegacy ? new LegacyForgeInstaller { ForgeExecutablePath = \"[PATH_TO_YOUR_FORGE_INSTALLER]\", RootPath = \"[GAME_ROOT_PATH]\", CustomId = \"[CUSTOM_INSTALL_GAME_ID]\", ForgeVersion = \"[FORGE_VERSION]\", InheritsFrom = \"[MC_VERSION_OR_GAME_ID]\" } : new HighVersionForgeInstaller { ForgeExecutablePath = \"[PATH_TO_YOUR_FORGE_INSTALLER]\", JavaExecutablePath = \"[PATH_TO_YOUR_JAVA_RUNTIME]\", RootPath = \"[GAME_ROOT_PATH]\", VersionLocator = [VERSION_LOCATOR_INST], DownloadUrlRoot = “[LIBRARIES_URL_ROOT]”, CustomId = \"[CUSTOM_INSTALL_GAME_ID]\", MineCraftVersion = \"[MC_VERSION]\", MineCraftVersionId = \"[ACTUAL_MC_GAME_ID]\", InheritsFrom = \"[MC_VERSION_OR_GAME_ID]\" }; 開始安裝 在您完成安裝器的初始化後, 您只需要呼叫 Forge 安裝器的安裝方法來完成安裝. 在非同步上下文中, 使用 InstallForgeTaskAsync 來完成安裝： await forgeInstaller.InstallForgeTaskAsync(); 在同步上下文中, 使用 InstallForge 來完成安裝： forgeInstaller.InstallForge(); 報告安裝進度 在某些情況下, Forge 安裝器可能會需要數分鐘的時間來完成安裝. 因此, 您可能需要實時向用戶彙報安裝器目前的進度. 為此, Forge 安裝器提供了 StageChangedEventDelegate 事件來幫助您實現任務彙報. 您只需要簡單地在 開始安裝之前 註冊下面的事件： ((InstallerBase)forgeInstaller).StageChangedEventDelegate += (_, args) => { ReportProgress(args.Progress * 100, args.CurrentStage); }; 其中, args.Progress 指示了安裝器當前的百分比進度. args.CurrentStage 則是安裝器當前進度的文字描述."
  },
  "temp/docs-main/zhTW/projbobcat/installers/index.html": {
    "href": "temp/docs-main/zhTW/projbobcat/installers/index.html",
    "title": "安裝器 | Qomicex.Core API文档",
    "summary": "安裝器 在 ProjBobcat 中, 我們已經為開發者實現了您在 MineCraft 開發過程中可能遇到的大部分模組基礎設施. 支援列表 專案名稱 支援狀態 Forge （舊版） 受支援 ✅ Forge （新版） 受支援 ✅ LiteLoader 受支援 ✅ Fabric 受支援 ✅ Optifine 受支援 ✅ Quilt 受支援（實驗性） ⚠ CurseForge 整合包 受支援 ✅"
  },
  "temp/docs-main/zhTW/projbobcat/installers/liteloader.html": {
    "href": "temp/docs-main/zhTW/projbobcat/installers/liteloader.html",
    "title": "LiteLoader 安裝器 | Qomicex.Core API文档",
    "summary": "LiteLoader 安裝器 [[toc]] ::: tip 請注意, ProjBobcat 僅實現了 LiteLoader 自動化安裝流程, 您仍然需要自己實現 LiteLoader 安裝包的搜尋、下載、儲存流程. ::: ::: warning LiteLoader 作為早期 MineCraft 的模組系統, 已經長期缺乏維護和後續支援. 因此, 我們可能會在後續的版本中移除對 LiteLoader 安裝的支援. ::: 實用資源 LiteLoader Versions API BMCLAPI 開發文件 獲取 LiteLoader Download Version Model 由於 ProjBobcat 的 LiteLoader 安裝器要求您在初始化安裝器時提供來自 LiteLoader 的下載資訊. 因此, 我們將在這裡簡要描述如何根據指定的 MineCraft 版本來獲取該資訊. ::: info 在該示例中, 我們將使用 MineCraft 1.7.10 來向您展示如何獲取. ::: ::: warning 由於 LiteLoader 官方沒有提供公開的 API 文件. 因此, 在本流程中, 我們需要使用第三方的映象源來完成資料的獲取. 在這裡, 我們使用 BMCLAPI 來獲取相關的版本資訊. ::: 首先, 您需要向 https://bmclapi2.bangbang93.com/liteloader/list?mcversion=[MC_VERSION] 傳送一個 HTTP GET 請求. 將 [MC_VERSION] 替換為您想要安裝的 MineCraft 版本. 在這裡, 我們將使用 1.7.10. 您將看到類似下面的返回內容： { \"_id\": \"59685511433f993503c1c879\", \"mcversion\": \"1.7.10\", \"build\": { \"tweakClass\": \"com.mumfrey.liteloader.launch.LiteLoaderTweaker\", \"libraries\": [...], \"stream\": \"RELEASE\", \"file\": \"liteloader-1.7.10.jar\", \"version\": \"1.7.10_04\", \"md5\": \"63ada46e033d0cb6782bada09ad5ca4e\", \"timestamp\": \"1414368553\", \"srcJar\": \"liteloader-1.7.10_04-mcpnames-sources.jar\", \"mcpJar\": \"liteloader-1.7.10_04-mcpnames.jar\" }, \"hash\": \"63ada46e033d0cb6782bada09ad5ca4e\", \"type\": \"RELEASE\", \"version\": \"1.7.10_04\", \"__v\": 0 } BMCLAPI 將返回一個 JSON 物件, 將該物件反序列化為 ProjBobcat 型別即是我們需要的 LiteLoaderDownloadVersionModel. 將 JSON 返回轉換為 ProjBobcat 型別 如果您在您的專案中使用 JSON.NET（Newtonsoft.JSON）. 您可以使用類似下面的程式碼來將您獲取到的伺服器響應轉換為對應的 ProjBobcat 型別： // 從 BMCLAPI 請求資料（示例, 非實際程式碼） ... var responseJson = await res.Content.ReadAsStringAsync(); // 將 JSON 響應轉換為 ProjBobcat 型別 // [!code focus] var versionModel = JsonConvert.DeserializeObject<LiteLoaderDownloadVersionModel>(responseJson); // [!code focus] 此處, versionModel 即是 Fabric 安裝器所需要的 LiteLoaderDownloadVersionMode. 獲取 RawVersionModel 在初始化 LiteLoader 安裝器時, 安裝器需要使用 LiteLoader 對應的 MineCraft 遊戲版本的原始 JSON 內容. 即 [ROOT_PATH]/versions/[MC_VERSION]/[MC_VERSION].json 檔案的內容. 如果您已經安裝了 LiteLoader 對應的原版遊戲, 您可以透過下面的程式碼獲取到 RawVersionModel： // 獲取版本 JSON 檔案所在的路徑 var jsonPath = GamePathHelper.GetGameJsonPath(rP, id); // 讀取該檔案的內容 var jsonContent = await File.ReadAllTextAsync(jsonPath); // 將 JSON 內容轉換為 RawVersionModel var baseVersionModel = JsonConvert.DeserializeObject<RawVersionModel>(jsonContent); 此處, baseVersionModel 即是 LiteLoader 安裝器所需要的 RawVersionModel. 初始化安裝器 初始化 LiteLoader 安裝器的方式非常簡單. 您需要使用到在先前步驟中取得的 versionModel 和 baseVersionModel 來初始化安裝器： var liteLoaderInstaller = new LiteLoaderInstaller { InheritVersion = baseVersionModel, InheritsFrom = \"[MC_VERSION_OR_GAME_ID]\", RootPath = \"[GAME_ROOT_PATH]\", VersionModel = versionModel, CustomId = \"[CUSTOM_INSTALL_GAME_ID]\" }; 在上述程式碼塊中, 請將這些引數按照您的實際情況替換： 專案 說明 [GAME_ROOT_PATH] 遊戲根目錄, 通常為 .minecraft 資料夾的路徑 [CUSTOM_INSTALL_GAME_ID] 可選項, 自定義即將要安裝的遊戲的名稱 [MC_VERSION_OR_GAME_ID] Forge 繼承的 MineCraft 原版遊戲版本, 通常為遊戲版本. 例如：1.19.2 [VERSION_LOCATOR_INST] 遊戲版本定位器例項, 即初始化遊戲核心時的 VersionLocator 屬性 開始安裝 在您完成安裝器的初始化後, 您只需要呼叫 LiteLoader 安裝器的安裝方法來完成安裝. 在非同步上下文中, 使用 InstallTaskAsync 來完成安裝： await liteLoaderInstaller.InstallTaskAsync(); 在同步上下文中, 使用 Install 來完成安裝： liteLoaderInstaller.Install(); 報告安裝進度 在某些情況下, LiteLoader 安裝器可能會需要數分鐘的時間來完成安裝. 因此, 您可能需要實時向用戶彙報安裝器目前的進度. 為此, LiteLoader 安裝器提供了 StageChangedEventDelegate 事件來幫助您實現任務彙報. 您只需要簡單地在 開始安裝之前 註冊下面的事件： liteLoaderInstaller.StageChangedEventDelegate += (_, args) => { ReportProgress(args.Progress, args.CurrentStage); }; 其中, args.Progress 指示了安裝器當前的百分比進度. args.CurrentStage 則是安裝器當前進度的文字描述."
  },
  "temp/docs-main/zhTW/projbobcat/installers/optifine.html": {
    "href": "temp/docs-main/zhTW/projbobcat/installers/optifine.html",
    "title": "Optifine 安裝器 | Qomicex.Core API文档",
    "summary": "Optifine 安裝器 [[toc]] ::: tip 請注意, ProjBobcat 僅實現了 Optifine 自動化安裝流程, 您仍然需要自己實現 Optifine 安裝包的搜尋、下載、儲存流程. ::: 實用資源 BMCLAPI 開發文件 獲取 Optifine Download Version Model 由於 ProjBobcat 的 LiteLoader 安裝器要求您在初始化安裝器時提供來自 LiteLoader 的下載資訊. 因此, 我們將在這裡簡要描述如何根據指定的 MineCraft 版本來獲取該資訊. ::: info 在該示例中, 我們將使用 MineCraft 1.19.2 來向您展示如何獲取. ::: ::: warning 由於 Optifine 官方沒有提供公開的 API 文件. 因此, 在本流程中, 我們需要使用第三方的映象源來完成資料的獲取. 在這裡, 我們使用 BMCLAPI 來獲取相關的版本資訊. ::: 首先, 您需要向 https://bmclapi2.bangbang93.com/optifine/[MC_VERSION] 傳送一個 HTTP GET 請求. 將 [MC_VERSION] 替換為您想要安裝的 MineCraft 版本. 在這裡, 我們將使用 1.19.2. 您將看到類似下面的返回內容： [ { \"_id\": \"6307b8a38a3998ab475d139d\", \"mcversion\": \"1.19.2\", \"patch\": \"H9\", \"type\": \"HD_U\", \"__v\": 0, \"filename\": \"OptiFine_1.19.2_HD_U_H9.jar\", \"forge\": \"Forge 43.1.1\" }, {...}, {...} ] BMCLAPI 將返回一個 JSON 陣列, 陣列中的每一個元素即是我們需要的 Download Version Model. 將 JSON 返回轉換為 ProjBobcat 型別 如果您在您的專案中使用 JSON.NET（Newtonsoft.JSON）. 您可以使用類似下面的程式碼來將您獲取到的伺服器響應轉換為對應的 ProjBobcat 型別： // 從 BMCLAPI 請求資料（示例, 非實際程式碼） ... var responseJson = await res.Content.ReadAsStringAsync(); // 將 JSON 響應轉換為 ProjBobcat 型別 // [!code focus] var versions = JsonConvert.DeserializeObject<List<OptifineDownloadVersionModel>>(responseJson); // [!code focus] // 獲取使用者想要安裝的版本（示例, 非實際程式碼） var userSelect = vm.SelectedIndex; // 獲取單個 Download Version Model // [!code focus] var selectedVersion = versions[userSelect]; // [!code focus] 此處, selectedVersion 即是 Optifine 安裝器所需要的 OptifineDownloadVersionModel. 初始化安裝器 初始化 Optifine 安裝器的方式非常簡單. 您首先需要準備好的 Optifine 安裝包 .jar 檔案. 以及一個可用的 Java 執行時. 您需要使用到在先前步驟中取得的 selectedVersion 來初始化安裝器： var optifineInstaller = new OptifineInstaller { JavaExecutablePath = \"[PATH_TO_YOUR_JAVA_RUNTIME]\", OptifineDownloadVersion = selectedVersion, OptifineJarPath = \"[PATH_TO_YOUR_OPTIFINE_JAR]\", RootPath = \"[GAME_ROOT_PATH]\", CustomId = \"[CUSTOM_INSTALL_GAME_ID]\", InheritsFrom = \"[MC_VERSION_OR_GAME_ID]\" }; 在上述程式碼塊中, 請將這些引數按照您的實際情況替換： 專案 說明 [GAME_ROOT_PATH] 遊戲根目錄, 通常為 .minecraft 資料夾的路徑 [CUSTOM_INSTALL_GAME_ID] 可選項, 自定義即將要安裝的遊戲的名稱 [MC_VERSION_OR_GAME_ID] Forge 繼承的 MineCraft 原版遊戲版本, 通常為遊戲版本. 例如：1.19.2 [VERSION_LOCATOR_INST] 遊戲版本定位器例項, 即初始化遊戲核心時的 VersionLocator 屬性 [PATH_TO_YOUR_OPTIFINE_JAR] Optifine 安裝包所在的路徑 [PATH_TO_YOUR_JAVA_RUNTIME] Java （javaw.exe） 執行時所在的路徑 開始安裝 在您完成安裝器的初始化後, 您只需要呼叫 Optifine 安裝器的安裝方法來完成安裝. 在非同步上下文中, 使用 InstallTaskAsync 來完成安裝： await optifineInstaller.InstallTaskAsync(); 在同步上下文中, 使用 Install 來完成安裝： optifineInstaller.Install(); 報告安裝進度 在某些情況下, Optifine 安裝器可能會需要數分鐘的時間來完成安裝. 因此, 您可能需要實時向用戶彙報安裝器目前的進度. 為此, Optifine 安裝器提供了 StageChangedEventDelegate 事件來幫助您實現任務彙報. 您只需要簡單地在 開始安裝之前 註冊下面的事件： optifineInstaller.StageChangedEventDelegate += (_, args) => { ReportProgress(args.Progress, args.CurrentStage); }; 其中, args.Progress 指示了安裝器當前的百分比進度. args.CurrentStage 則是安裝器當前進度的文字描述."
  },
  "temp/docs-main/zhTW/projbobcat/installers/quilt.html": {
    "href": "temp/docs-main/zhTW/projbobcat/installers/quilt.html",
    "title": "Quilt 安裝器 | Qomicex.Core API文档",
    "summary": "Quilt 安裝器 [[toc]] ::: tip 請注意, ProjBobcat 僅實現了 Quilt 自動化安裝流程, 您仍然需要自己實現 Quilt 安裝包的搜尋、下載、儲存流程. ::: ::: warning Quilt 安裝器目前處於試驗階段, 相關的 API 以及安裝流程可能會出現較大幅度的變更. ::: 實用資源 Quilt 官方網站 Quilt 安裝指南 Quilt Meta API 相容性檢查 在開始安裝 Quilt 之前, 您需要透過 Quilt Meta API 來查詢您將要修改的 MineCraft 版本是否受支援. 首先, 您需要向 https://meta.quiltmc.org/v3/versions/game 傳送一個 HTTP GET 請求. 您將看到類似下面的返回內容： [ { \"version\": \"1.19.3\", \"stable\": true }, { \"version\": \"1.19.3-rc3\", \"stable\": false }, {...}, {...} ] 在這裡, 您需要檢查您即將要安裝的遊戲版本是否出現在 Quilt 官方的支援列表當中. 您需要將遊戲版本與 JSON 物件中的 version 欄位作比較. **如果您的遊戲沒有出現在支援列表當中, 安裝將無法繼續. ** 獲取 Quilt Loader Model 由於 ProjBobcat 的 Quilt 安裝器要求您在初始化安裝器時提供來自 Quilt 的下載資訊. 因此, 我們將在這裡簡要描述如何根據指定的 MineCraft 版本來獲取該資訊. ::: info 在該示例中, 我們將使用 MineCraft 1.19.2 來向您展示如何獲取. ::: 首先, 您需要向 https://meta.quiltmc.org/v3/versions/loader 傳送一個 HTTP GET 請求. 您將看到類似下面的返回內容： [ { \"separator\": \".\", \"build\": 25, \"maven\": \"org.quiltmc:quilt-loader:0.18.1-beta.25\", \"version\": \"0.18.1-beta.25\" }, {...}, {...} ] Quilt Meta API 將返回一個 JSON 陣列, 陣列中的每一個元素即是我們需要的 Loader Artifact. 將 JSON 返回轉換為 ProjBobcat 型別 如果您在您的專案中使用 JSON.NET（Newtonsoft.JSON）. 您可以使用類似下面的程式碼來將您獲取到的伺服器響應轉換為對應的 ProjBobcat 型別： // 從 Quilt Meta API 請求資料（示例, 非實際程式碼） ... var responseJson = await res.Content.ReadAsStringAsync(); // 將 JSON 響應轉換為 ProjBobcat 型別 // [!code focus] var artifacts = JsonConvert.DeserializeObject<List<QuiltLoaderModel>>(responseJson); // [!code focus] // 獲取使用者想要安裝的版本（示例, 非實際程式碼） var userSelect = vm.SelectedArtifactIndex; // 獲取單個 Loader Artifact // [!code focus] var selectedArtifact = artifacts[userSelect]; // [!code focus] 此處, selectedArtifact 即是 Fabric 安裝器所需要的 QuiltLoaderModel. 初始化安裝器 初始化 Quilt 安裝器的方式非常簡單. 您需要使用到在先前步驟中取得的 selectedArtifact 來初始化安裝器： var quiltInstaller = new QuiltInstaller { InheritsFrom = \"[MC_VERSION_OR_GAME_ID]\", RootPath = \"[GAME_ROOT_PATH]\", CustomId = \"[CUSTOM_INSTALL_GAME_ID]\", LoaderArtifact = selectedArtifact }; 在上述程式碼塊中, 請將這些引數按照您的實際情況替換： 專案 說明 [GAME_ROOT_PATH] 遊戲根目錄, 通常為 .minecraft 資料夾的路徑 [CUSTOM_INSTALL_GAME_ID] 可選項, 自定義即將要安裝的遊戲的名稱 [MC_VERSION_OR_GAME_ID] Forge 繼承的 MineCraft 原版遊戲版本, 通常為遊戲版本. 例如：1.19.2 開始安裝 在您完成安裝器的初始化後, 您只需要呼叫 Fabric 安裝器的安裝方法來完成安裝. 在非同步上下文中, 使用 InstallTaskAsync 來完成安裝： await quiltInstaller.InstallTaskAsync(); 在同步上下文中, 使用 Install 來完成安裝： quiltInstaller.Install(); 報告安裝進度 在某些情況下, Quilt 安裝器可能會需要數分鐘的時間來完成安裝. 因此, 您可能需要實時向用戶彙報安裝器目前的進度. 為此, Quilt 安裝器提供了 StageChangedEventDelegate 事件來幫助您實現任務彙報. 您只需要簡單地在 開始安裝之前 註冊下面的事件： quiltInstaller.StageChangedEventDelegate += (_, args) => { ReportProgress(args.Progress, args.CurrentStage); }; 其中, args.Progress 指示了安裝器當前的百分比進度. args.CurrentStage 則是安裝器當前進度的文字描述."
  },
  "temp/docs-main/zhTW/projbobcat/resourceCompleter/createAndConfigCompleter.html": {
    "href": "temp/docs-main/zhTW/projbobcat/resourceCompleter/createAndConfigCompleter.html",
    "title": "建立和配置補全器 | Qomicex.Core API文档",
    "summary": "建立和配置補全器 [[toc]] 初始化補全器 建立一個資源補全器的方法非常簡單, 您只需要使用下面的程式碼即可完成補全器的初始化： var completer = new DefaultResourceCompleter { MaxDegreeOfParallelism = [MAX_DEGREE_OF_PARALLELISM], ResourceInfoResolvers = new List<IResourceInfoResolver> { ... // 資源資訊解析器的初始化 }, TotalRetry = [NUMBER_OF_TOTAL_RETRY], CheckFile = [CHECK_FILE_AFTER_DOWNLOADED], DownloadParts = [TOTAL_DOWNLOAD_SEGMENTS_FOR_LARGE_FILE] }; ::: tip 資源資訊解析器的初始化相關教程請參見 資源資訊解析器 章節 ::: 在上述程式碼塊中, 請將這些引數按照您的實際情況替換： 專案 資料型別 說明 [MAX_DEGREE_OF_PARALLELISM] INT 資源檢查並行程度（同時檢查遊戲資源的數量） [CHECK_FILE_AFTER_DOWNLOADED] BOOLEAN 在檔案下載完成後檢查檔案完整性（如果存在資源校檢碼） [TOTAL_DOWNLOAD_SEGMENTS_FOR_LARGE_FILE] INT 大檔案下載時的分片數量 ::: warning [MAX_DEGREE_OF_PARALLELISM] 和 [TOTAL_DOWNLOAD_SEGMENTS_FOR_LARGE_FILE] 的數值大小請視硬體效能酌情調整, 設定過大的數值可能會導致會導致吞吐量的下降. ::: 補全遊戲資源 在完成資源補全器的初始化操作後, 您只需要呼叫補全方法即可開始執行檢查和補全操作： 在非同步上下文中, 使用 CheckAndDownloadTaskAsync 來完成安裝： var result = await completer.CheckAndDownloadTaskAsync(); // [!code focus] if (result.TaskStatus == TaskResultStatus.Error && (result.Value?.IsLibDownloadFailed ?? false)) { // 在完成補全後, 資源檢查器會返回執行結果. // 您可以檢查 result 中的屬性值來確定補全是否完成 // IsLibDownloadFailed 會反映啟動必須的庫檔案是否已經成功補全 // 通常來說, 如果庫檔案的補全失敗, 很有可能會導致遊戲的啟動失敗 } 在同步上下文中, 使用 CheckAndDownload 來完成安裝： var result = completer.CheckAndDownload(); // [!code focus] 報告進度 在某些情況下, 資源補全器可能會需要數分鐘的時間來完成資源的檢查和下載. 因此, 您可能需要實時向用戶彙報補全器目前的進度. 報告資源檢查器的進度 您可以透過註冊事件 GameResourceInfoResolveStatus 來獲取實時的檢查進度： completer.GameResourceInfoResolveStatus += (_, args) => { ReportProgress(args.Progress, args.Status); }; 其中, args.Progress 指示了檢查器當前的百分比進度. args.Status 則是檢查器當前進度的文字描述. 報告補全器檔案下載進度 您可以透過註冊事件 DownloadFileCompletedEvent 來獲取實時的檢查進度： completer.DownloadFileCompletedEvent += (sender, args) => { // sender 引數為補全器上一個成功下載的檔案, 型別為 DownloadFile // args 返回了該檔案的下載狀態（成功 / 失敗）, 以及檔案的重試計數, // 型別為 DownloadFileCompletedEventArgs }; ::: tip DownloadFile 類結構 DownloadFileCompletedEventArgs 事件結構 ::: 報告下載中的檔案的進度資訊 您可以透過註冊事件 DownloadFileChangedEvent 來獲取實時的檢查進度： rC.DownloadFileChangedEvent += (_, args) => { // args 返回了下載中的檔案的具體資訊（已接收的位元組數、總共的位元組數、當前速度、百分比進度） // 型別為 DownloadFileChangedEventArgs }; ::: tip DownloadFileChangedEventArgs 事件結構 :::"
  },
  "temp/docs-main/zhTW/projbobcat/resourceCompleter/index.html": {
    "href": "temp/docs-main/zhTW/projbobcat/resourceCompleter/index.html",
    "title": "資源補全器 | Qomicex.Core API文档",
    "summary": "資源補全器 在 ProjBobcat 中, 我們為開發者提供了用於補全 MineCraft 核心資原始檔的補全器. 這些資源包括：遊戲音訊、材質、貼圖、語言檔案、啟動所必須的庫檔案等."
  },
  "temp/docs-main/zhTW/projbobcat/resourceCompleter/resourceInfoResolver/assetInfoResolver.html": {
    "href": "temp/docs-main/zhTW/projbobcat/resourceCompleter/resourceInfoResolver/assetInfoResolver.html",
    "title": "Assets 解析器 | Qomicex.Core API文档",
    "summary": "Assets 解析器 [[toc]] Assets 解析器提供了對遊戲資產檔案的解析和驗證功能, 這些檔案一般存放在 .minecraft/assets 目錄下 獲取 Version Manifest Versions 列表 首先, 您需要向 https://launchermeta.mojang.com/mc/game/version_manifest.json 傳送一個 HTTP GET 請求. 您將看到類似下面的返回內容： { \"latest\": { \"release\": \"1.19.3\", \"snapshot\": \"23w06a\" }, \"versions\": [ { \"id\": \"23w06a\", \"type\": \"snapshot\", \"url\": \"https://piston-meta.mojang.com/v1/packages/92ed97b686fe8904d8ec00fd486c435582fd0155/23w06a.json\", \"time\": \"2023-02-08T15:11:06+00:00\", \"releaseTime\": \"2023-02-08T15:00:04+00:00\" }, ... ] } Mojang 伺服器將會返回一個 JSON 物件, versions 欄位則是我們所需要的 Versions 陣列 將 JSON 返回轉換為 ProjBobcat 型別 如果您在您的專案中使用 JSON.NET（Newtonsoft.JSON）. 您可以使用類似下面的程式碼來將您獲取到的伺服器響應轉換為對應的 ProjBobcat 型別： // 從 Mojang API 請求資料（示例, 非實際程式碼） ... var responseJson = await res.Content.ReadAsStringAsync(); // 將 JSON 響應轉換為 ProjBobcat 型別 // [!code focus] var manifest = JsonConvert.DeserializeObject<VersionManifest>(responseJson); // [!code focus] // 獲取 Versions 列表 // [!code focus] var versions = manifest.Versions; // [!code focus] 此處, versions 即是 Assets 解析器所需要的 Versions 陣列. 初始化解析器 你可以透過下面的程式碼來初始化 Assets 解析器： var resolver = new AssetInfoResolver { AssetIndexUriRoot = \"https://launchermeta.mojang.com/\", AssetUriRoot = \"https://resources.download.minecraft.net/\", BasePath = \"[GAME_ROOT_PATH]\", VersionInfo = [SEARCHED_VERSION_INFO], CheckLocalFiles = [CHECK_LOCAL_FILES], Versions = versions // 在上一步獲取到的 Versions 陣列 }; 在上述程式碼塊中, 請將這些引數按照您的實際情況替換： 專案 說明 [GAME_ROOT_PATH] 遊戲根目錄, 通常為 .minecraft 資料夾的路徑 [SEARCHED_VERSION_INFO] 要檢查的版本的 VersionInfo （透過遊戲定位器獲得） [CHECK_LOCAL_FILES] 檢查本地檔案（如果為 false, 則跳過所有檢查）"
  },
  "temp/docs-main/zhTW/projbobcat/resourceCompleter/resourceInfoResolver/gameLoggingInfoResolver.html": {
    "href": "temp/docs-main/zhTW/projbobcat/resourceCompleter/resourceInfoResolver/gameLoggingInfoResolver.html",
    "title": "log4j 日誌格式化元件解析器 | Qomicex.Core API文档",
    "summary": "log4j 日誌格式化元件解析器 [[toc]] log4j 日誌格式化元件解析器提供了對遊戲資產檔案的解析和驗證功能, 這些檔案存放在 .minecraft/logging 目錄下 使用該資源解析器可以使 MineCraft 輸出經過 log4j 格式化後的日誌內容, 類似於如下的內容： <log4j:Event logger=\"ekb\" timestamp=\"1676012129\" level=\"INFO\" thread=\"Render thread\"> <log4j:Message> <![CDATA[Created: 512x512x4 minecraft:textures/atlas/shulker_boxes.png-atlas]]> </log4j:Message> </log4j:Event> 初始化解析器 你可以透過下面的程式碼來初始化 log4j 日誌格式化元件解析器： var resolver = new GameLoggingInfoResolver { BasePath = \"[GAME_ROOT_PATH]\", VersionInfo = [SEARCHED_VERSION_INFO], CheckLocalFiles = [CHECK_LOCAL_FILES] }; 在上述程式碼塊中, 請將這些引數按照您的實際情況替換： 專案 說明 [GAME_ROOT_PATH] 遊戲根目錄, 通常為 .minecraft 資料夾的路徑 [SEARCHED_VERSION_INFO] 要檢查的版本的 VersionInfo （透過遊戲定位器獲得） [CHECK_LOCAL_FILES] 檢查本地檔案（如果為 false, 則跳過所有檢查）"
  },
  "temp/docs-main/zhTW/projbobcat/resourceCompleter/resourceInfoResolver/index.html": {
    "href": "temp/docs-main/zhTW/projbobcat/resourceCompleter/resourceInfoResolver/index.html",
    "title": "資源資訊解析器 | Qomicex.Core API文档",
    "summary": "資源資訊解析器 在 ProjBobcat 中, 我們使用 資源資訊解析器（ResourceInfoResolver） 來幫助資源補全器確定 MineCraft 缺失的檔案. 下表展示了目前 ProjBobcat 所支援的資源解析器： 類名 簡介 AssetInfoResolver 用於解析遊戲所需要的資產（音訊、語言、字型和貼圖等） GameLoggingInfoResolver 用於解析 MineCraft 官方所提供的 log4j 日誌格式化元件 LibraryInfoResolver 用於解析遊戲啟動所必須的庫檔案 VersionInfoResolver 用於解析遊戲 JSON 中提供的 JAR 檔案"
  },
  "temp/docs-main/zhTW/projbobcat/resourceCompleter/resourceInfoResolver/libraryInfoResolver.html": {
    "href": "temp/docs-main/zhTW/projbobcat/resourceCompleter/resourceInfoResolver/libraryInfoResolver.html",
    "title": "Libraries 解析器 | Qomicex.Core API文档",
    "summary": "Libraries 解析器 [[toc]] Libraries 解析器提供了對遊戲資產檔案的解析和驗證功能, 這些檔案存放在 .minecraft/libraries 目錄下, 這些檔案是啟動 MineCraft 所必需的執行時檔案. 初始化解析器 你可以透過下面的程式碼來初始化 Libraries 解析器： var resolver = new LibraryInfoResolver { BasePath = \"[GAME_ROOT_PATH]\", ForgeUriRoot = \"https://files.minecraftforge.net/maven/\", ForgeMavenUriRoot = \"https://maven.minecraftforge.net/\", ForgeMavenOldUriRoot = \"https://files.minecraftforge.net/maven/\", FabricMavenUriRoot = \"https://maven.fabricmc.net/\", LibraryUriRoot = \"https://libraries.minecraft.net/\", VersionInfo = [SEARCHED_VERSION_INFO], CheckLocalFiles = [CHECK_LOCAL_FILES] }; 在上述程式碼塊中, 請將這些引數按照您的實際情況替換： 專案 說明 [GAME_ROOT_PATH] 遊戲根目錄, 通常為 .minecraft 資料夾的路徑 [SEARCHED_VERSION_INFO] 要檢查的版本的 VersionInfo （透過遊戲定位器獲得） [CHECK_LOCAL_FILES] 檢查本地檔案（如果為 false, 則跳過所有檢查）"
  },
  "temp/docs-main/zhTW/projbobcat/resourceCompleter/resourceInfoResolver/versionInfoResolver.html": {
    "href": "temp/docs-main/zhTW/projbobcat/resourceCompleter/resourceInfoResolver/versionInfoResolver.html",
    "title": "版本資訊解析器 | Qomicex.Core API文档",
    "summary": "版本資訊解析器 [[toc]] 版本資訊解析器提供了對遊戲資產檔案的解析和驗證功能, 這些檔案存放在 .minecraft/versions/{GAME_VERSION}/{GAME_VERSION}.jar 目錄下, 這些檔案是啟動 MineCraft 所必需的核心檔案. 初始化解析器 你可以透過下面的程式碼來初始化初始化解析器： var resolver = new VersionInfoResolver { BasePath = \"[GAME_ROOT_PATH]\", VersionInfo = [SEARCHED_VERSION_INFO], CheckLocalFiles = [CHECK_LOCAL_FILES] }; 在上述程式碼塊中, 請將這些引數按照您的實際情況替換： 專案 說明 [GAME_ROOT_PATH] 遊戲根目錄, 通常為 .minecraft 資料夾的路徑 [SEARCHED_VERSION_INFO] 要檢查的版本的 VersionInfo （透過遊戲定位器獲得） [CHECK_LOCAL_FILES] 檢查本地檔案（如果為 false, 則跳過所有檢查）"
  },
  "temp/docs-main/zhTW/skin/index.html": {
    "href": "temp/docs-main/zhTW/skin/index.html",
    "title": "Minecraft 面板規範（1.18+） | Qomicex.Core API文档",
    "summary": "Minecraft 面板規範（1.18+） 以下是從 Minecraft 1.18 開始的新面板規範 樣例 1 樣例2（包含網格）"
  },
  "temp/docs-main/zhTW/team.html": {
    "href": "temp/docs-main/zhTW/team.html",
    "title": "| Qomicex.Core API文档",
    "summary": "import { VPTeamPage, VPTeamPageTitle, VPTeamMembers } from 'vitepress/theme'; const members = [ { avatar: 'https://www.github.com/laolarou726.png', name: '老臘肉', title: '建立者', links: [ { icon: 'github', link: 'https://github.com/laolarou726' } ] }, { avatar: 'https://github.com/CodingEric.png', name: 'CodingEric', title: 'UI / UX', links: [ { icon: 'github', link: 'https://github.com/CodingEric' } ] }, { avatar: 'https://github.com/leon-o.png', name: 'Leon', title: 'UI、後端服務、運維', links: [ { icon: 'github', link: 'https://github.com/leon-o' } ] }, { avatar: 'https://github.com/komorebi64.png', name: 'Croteco', title: '後端服務、運維', links: [ { icon: 'github', link: 'https://github.com/komorebi64' } ] }, { avatar: 'https://github.com/fr1g.png', name: '法棍', title: '前端、MC 伺服器運維', links: [ { icon: 'github', link: 'https://github.com/fr1g' } ] } ]; 我們的團隊 Corona Studio（日冕工作室）是以 Minecraft 遊戲第三方服務為業務核心的、由專業人士和愛好者組成的團隊, 前身是 CMFL 啟動器開發組,"
  }
}